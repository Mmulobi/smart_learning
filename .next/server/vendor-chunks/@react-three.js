"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/MeshDistortMaterial.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/MeshDistortMaterial.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshDistortMaterial: () => (/* binding */ MeshDistortMaterial)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-0dc84b81.esm.js\");\n/* harmony import */ var _helpers_glsl_distort_vert_glsl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/glsl/distort.vert.glsl.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/glsl/distort.vert.glsl.js\");\n\n\n\n\n\nclass DistortMaterialImpl extends three__WEBPACK_IMPORTED_MODULE_2__.MeshPhysicalMaterial {\n    constructor(parameters = {}){\n        super(parameters);\n        this.setValues(parameters);\n        this._time = {\n            value: 0\n        };\n        this._distort = {\n            value: 0.4\n        };\n        this._radius = {\n            value: 1\n        };\n    }\n    // FIXME Use `THREE.WebGLProgramParametersWithUniforms` type when able to target @types/three@0.160.0\n    onBeforeCompile(shader) {\n        shader.uniforms.time = this._time;\n        shader.uniforms.radius = this._radius;\n        shader.uniforms.distort = this._distort;\n        shader.vertexShader = `\n      uniform float time;\n      uniform float radius;\n      uniform float distort;\n      ${_helpers_glsl_distort_vert_glsl_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]}\n      ${shader.vertexShader}\n    `;\n        shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `\n        float updateTime = time / 50.0;\n        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));\n        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));\n        `);\n    }\n    get time() {\n        return this._time.value;\n    }\n    set time(v) {\n        this._time.value = v;\n    }\n    get distort() {\n        return this._distort.value;\n    }\n    set distort(v) {\n        this._distort.value = v;\n    }\n    get radius() {\n        return this._radius.value;\n    }\n    set radius(v) {\n        this._radius.value = v;\n    }\n}\nconst MeshDistortMaterial = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ speed = 1, ...props }, ref)=>{\n    const [material] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        \"MeshDistortMaterial.useState\": ()=>new DistortMaterialImpl()\n    }[\"MeshDistortMaterial.useState\"]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)({\n        \"MeshDistortMaterial.useFrame\": (state)=>material && (material.time = state.clock.getElapsedTime() * speed)\n    }[\"MeshDistortMaterial.useFrame\"]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        object: material,\n        ref: ref,\n        attach: \"material\"\n    }, props));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9NZXNoRGlzdG9ydE1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDYztBQUNDO0FBQ2E7QUFFM0QsTUFBTUssNEJBQTRCSCx1REFBb0JBO0lBQ3BELFlBQVlJLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDM0IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsU0FBUyxDQUFDRDtRQUNmLElBQUksQ0FBQ0UsS0FBSyxHQUFHO1lBQ1hDLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1lBQ2RELE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQ0UsT0FBTyxHQUFHO1lBQ2JGLE9BQU87UUFDVDtJQUNGO0lBRUEscUdBQXFHO0lBQ3JHRyxnQkFBZ0JDLE1BQU0sRUFBRTtRQUN0QkEsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDUCxLQUFLO1FBQ2pDSyxPQUFPQyxRQUFRLENBQUNFLE1BQU0sR0FBRyxJQUFJLENBQUNMLE9BQU87UUFDckNFLE9BQU9DLFFBQVEsQ0FBQ1YsT0FBTyxHQUFHLElBQUksQ0FBQ00sUUFBUTtRQUN2Q0csT0FBT0ksWUFBWSxHQUFHLENBQUM7Ozs7TUFJckIsRUFBRWIsMEVBQU9BLENBQUM7TUFDVixFQUFFUyxPQUFPSSxZQUFZLENBQUM7SUFDeEIsQ0FBQztRQUNESixPQUFPSSxZQUFZLEdBQUdKLE9BQU9JLFlBQVksQ0FBQ0MsT0FBTyxDQUFDLDJCQUEyQixDQUFDOzs7O1FBSTFFLENBQUM7SUFDUDtJQUNBLElBQUlILE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ1AsS0FBSyxDQUFDQyxLQUFLO0lBQ3pCO0lBQ0EsSUFBSU0sS0FBS0ksQ0FBQyxFQUFFO1FBQ1YsSUFBSSxDQUFDWCxLQUFLLENBQUNDLEtBQUssR0FBR1U7SUFDckI7SUFDQSxJQUFJZixVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNNLFFBQVEsQ0FBQ0QsS0FBSztJQUM1QjtJQUNBLElBQUlMLFFBQVFlLENBQUMsRUFBRTtRQUNiLElBQUksQ0FBQ1QsUUFBUSxDQUFDRCxLQUFLLEdBQUdVO0lBQ3hCO0lBQ0EsSUFBSUgsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDTCxPQUFPLENBQUNGLEtBQUs7SUFDM0I7SUFDQSxJQUFJTyxPQUFPRyxDQUFDLEVBQUU7UUFDWixJQUFJLENBQUNSLE9BQU8sQ0FBQ0YsS0FBSyxHQUFHVTtJQUN2QjtBQUNGO0FBQ0EsTUFBTUMsc0JBQXNCLGFBQWEsaUJBQUVuQiw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQzNEcUIsUUFBUSxDQUFDLEVBQ1QsR0FBR0MsT0FDSixFQUFFQztJQUNELE1BQU0sQ0FBQ0MsU0FBUyxHQUFHeEIsMkNBQWM7d0NBQUMsSUFBTSxJQUFJSTs7SUFDNUNGLHFEQUFRQTt3Q0FBQ3dCLENBQUFBLFFBQVNGLFlBQWFBLENBQUFBLFNBQVNWLElBQUksR0FBR1ksTUFBTUMsS0FBSyxDQUFDQyxjQUFjLEtBQUtQLEtBQUk7O0lBQ2xGLE9BQU8sV0FBVyxHQUFFckIsZ0RBQW1CLENBQUMsYUFBYUQsOEVBQVFBLENBQUM7UUFDNUQrQixRQUFRTjtRQUNSRCxLQUFLQTtRQUNMUSxRQUFRO0lBQ1YsR0FBR1Q7QUFDTDtBQUUrQiIsInNvdXJjZXMiOlsiL2hvbWUvY29kZXIvRGVza3RvcC9zbWFydF9sZWFybmluZy9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9NZXNoRGlzdG9ydE1hdGVyaWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1lc2hQaHlzaWNhbE1hdGVyaWFsIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IGRpc3RvcnQgZnJvbSAnLi4vaGVscGVycy9nbHNsL2Rpc3RvcnQudmVydC5nbHNsLmpzJztcblxuY2xhc3MgRGlzdG9ydE1hdGVyaWFsSW1wbCBleHRlbmRzIE1lc2hQaHlzaWNhbE1hdGVyaWFsIHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG4gICAgdGhpcy5fdGltZSA9IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfTtcbiAgICB0aGlzLl9kaXN0b3J0ID0ge1xuICAgICAgdmFsdWU6IDAuNFxuICAgIH07XG4gICAgdGhpcy5fcmFkaXVzID0ge1xuICAgICAgdmFsdWU6IDFcbiAgICB9O1xuICB9XG5cbiAgLy8gRklYTUUgVXNlIGBUSFJFRS5XZWJHTFByb2dyYW1QYXJhbWV0ZXJzV2l0aFVuaWZvcm1zYCB0eXBlIHdoZW4gYWJsZSB0byB0YXJnZXQgQHR5cGVzL3RocmVlQDAuMTYwLjBcbiAgb25CZWZvcmVDb21waWxlKHNoYWRlcikge1xuICAgIHNoYWRlci51bmlmb3Jtcy50aW1lID0gdGhpcy5fdGltZTtcbiAgICBzaGFkZXIudW5pZm9ybXMucmFkaXVzID0gdGhpcy5fcmFkaXVzO1xuICAgIHNoYWRlci51bmlmb3Jtcy5kaXN0b3J0ID0gdGhpcy5fZGlzdG9ydDtcbiAgICBzaGFkZXIudmVydGV4U2hhZGVyID0gYFxuICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgICB1bmlmb3JtIGZsb2F0IGRpc3RvcnQ7XG4gICAgICAke2Rpc3RvcnR9XG4gICAgICAke3NoYWRlci52ZXJ0ZXhTaGFkZXJ9XG4gICAgYDtcbiAgICBzaGFkZXIudmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlci5yZXBsYWNlKCcjaW5jbHVkZSA8YmVnaW5fdmVydGV4PicsIGBcbiAgICAgICAgZmxvYXQgdXBkYXRlVGltZSA9IHRpbWUgLyA1MC4wO1xuICAgICAgICBmbG9hdCBub2lzZSA9IHNub2lzZSh2ZWMzKHBvc2l0aW9uIC8gMi4wICsgdXBkYXRlVGltZSAqIDUuMCkpO1xuICAgICAgICB2ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyhwb3NpdGlvbiAqIChub2lzZSAqIHBvdyhkaXN0b3J0LCAyLjApICsgcmFkaXVzKSk7XG4gICAgICAgIGApO1xuICB9XG4gIGdldCB0aW1lKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLnZhbHVlO1xuICB9XG4gIHNldCB0aW1lKHYpIHtcbiAgICB0aGlzLl90aW1lLnZhbHVlID0gdjtcbiAgfVxuICBnZXQgZGlzdG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzdG9ydC52YWx1ZTtcbiAgfVxuICBzZXQgZGlzdG9ydCh2KSB7XG4gICAgdGhpcy5fZGlzdG9ydC52YWx1ZSA9IHY7XG4gIH1cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzLnZhbHVlO1xuICB9XG4gIHNldCByYWRpdXModikge1xuICAgIHRoaXMuX3JhZGl1cy52YWx1ZSA9IHY7XG4gIH1cbn1cbmNvbnN0IE1lc2hEaXN0b3J0TWF0ZXJpYWwgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHNwZWVkID0gMSxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBbbWF0ZXJpYWxdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IERpc3RvcnRNYXRlcmlhbEltcGwoKSk7XG4gIHVzZUZyYW1lKHN0YXRlID0+IG1hdGVyaWFsICYmIChtYXRlcmlhbC50aW1lID0gc3RhdGUuY2xvY2suZ2V0RWxhcHNlZFRpbWUoKSAqIHNwZWVkKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7XG4gICAgb2JqZWN0OiBtYXRlcmlhbCxcbiAgICByZWY6IHJlZixcbiAgICBhdHRhY2g6IFwibWF0ZXJpYWxcIlxuICB9LCBwcm9wcykpO1xufSk7XG5cbmV4cG9ydCB7IE1lc2hEaXN0b3J0TWF0ZXJpYWwgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIlJlYWN0IiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJ1c2VGcmFtZSIsImRpc3RvcnQiLCJEaXN0b3J0TWF0ZXJpYWxJbXBsIiwicGFyYW1ldGVycyIsInNldFZhbHVlcyIsIl90aW1lIiwidmFsdWUiLCJfZGlzdG9ydCIsIl9yYWRpdXMiLCJvbkJlZm9yZUNvbXBpbGUiLCJzaGFkZXIiLCJ1bmlmb3JtcyIsInRpbWUiLCJyYWRpdXMiLCJ2ZXJ0ZXhTaGFkZXIiLCJyZXBsYWNlIiwidiIsIk1lc2hEaXN0b3J0TWF0ZXJpYWwiLCJmb3J3YXJkUmVmIiwic3BlZWQiLCJwcm9wcyIsInJlZiIsIm1hdGVyaWFsIiwidXNlU3RhdGUiLCJzdGF0ZSIsImNsb2NrIiwiZ2V0RWxhcHNlZFRpbWUiLCJjcmVhdGVFbGVtZW50Iiwib2JqZWN0IiwiYXR0YWNoIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/MeshDistortMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/OrbitControls.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-0dc84b81.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js\");\n\n\n\n\nconst OrbitControls = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ makeDefault, camera, regress, domElement, enableDamping = true, keyEvents = false, onChange, onStart, onEnd, ...restProps }, ref)=>{\n    const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[invalidate]\": (state)=>state.invalidate\n    }[\"OrbitControls.useThree[invalidate]\"]);\n    const defaultCamera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[defaultCamera]\": (state)=>state.camera\n    }[\"OrbitControls.useThree[defaultCamera]\"]);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[gl]\": (state)=>state.gl\n    }[\"OrbitControls.useThree[gl]\"]);\n    const events = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[events]\": (state)=>state.events\n    }[\"OrbitControls.useThree[events]\"]);\n    const setEvents = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[setEvents]\": (state)=>state.setEvents\n    }[\"OrbitControls.useThree[setEvents]\"]);\n    const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[set]\": (state)=>state.set\n    }[\"OrbitControls.useThree[set]\"]);\n    const get = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[get]\": (state)=>state.get\n    }[\"OrbitControls.useThree[get]\"]);\n    const performance = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)({\n        \"OrbitControls.useThree[performance]\": (state)=>state.performance\n    }[\"OrbitControls.useThree[performance]\"]);\n    const explCamera = camera || defaultCamera;\n    const explDomElement = domElement || events.connected || gl.domElement;\n    const controls = react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"OrbitControls.useMemo[controls]\": ()=>new three_stdlib__WEBPACK_IMPORTED_MODULE_3__.OrbitControls(explCamera)\n    }[\"OrbitControls.useMemo[controls]\"], [\n        explCamera\n    ]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)({\n        \"OrbitControls.useFrame\": ()=>{\n            if (controls.enabled) controls.update();\n        }\n    }[\"OrbitControls.useFrame\"], -1);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"OrbitControls.useEffect\": ()=>{\n            if (keyEvents) {\n                controls.connect(keyEvents === true ? explDomElement : keyEvents);\n            }\n            controls.connect(explDomElement);\n            return ({\n                \"OrbitControls.useEffect\": ()=>void controls.dispose()\n            })[\"OrbitControls.useEffect\"];\n        }\n    }[\"OrbitControls.useEffect\"], [\n        keyEvents,\n        explDomElement,\n        regress,\n        controls,\n        invalidate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"OrbitControls.useEffect\": ()=>{\n            const callback = {\n                \"OrbitControls.useEffect.callback\": (e)=>{\n                    invalidate();\n                    if (regress) performance.regress();\n                    if (onChange) onChange(e);\n                }\n            }[\"OrbitControls.useEffect.callback\"];\n            const onStartCb = {\n                \"OrbitControls.useEffect.onStartCb\": (e)=>{\n                    if (onStart) onStart(e);\n                }\n            }[\"OrbitControls.useEffect.onStartCb\"];\n            const onEndCb = {\n                \"OrbitControls.useEffect.onEndCb\": (e)=>{\n                    if (onEnd) onEnd(e);\n                }\n            }[\"OrbitControls.useEffect.onEndCb\"];\n            controls.addEventListener('change', callback);\n            controls.addEventListener('start', onStartCb);\n            controls.addEventListener('end', onEndCb);\n            return ({\n                \"OrbitControls.useEffect\": ()=>{\n                    controls.removeEventListener('start', onStartCb);\n                    controls.removeEventListener('end', onEndCb);\n                    controls.removeEventListener('change', callback);\n                }\n            })[\"OrbitControls.useEffect\"];\n        }\n    }[\"OrbitControls.useEffect\"], [\n        onChange,\n        onStart,\n        onEnd,\n        controls,\n        invalidate,\n        setEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"OrbitControls.useEffect\": ()=>{\n            if (makeDefault) {\n                const old = get().controls;\n                set({\n                    controls\n                });\n                return ({\n                    \"OrbitControls.useEffect\": ()=>set({\n                            controls: old\n                        })\n                })[\"OrbitControls.useEffect\"];\n            }\n        }\n    }[\"OrbitControls.useEffect\"], [\n        makeDefault,\n        controls\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: ref,\n        object: controls,\n        enableDamping: enableDamping\n    }, restProps));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PcmJpdENvbnRyb2xzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwRDtBQUNGO0FBQ3pCO0FBQ2lDO0FBRWhFLE1BQU1JLGdCQUFnQixhQUFhLGlCQUFFRCw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3JESSxXQUFXLEVBQ1hDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLGdCQUFnQixJQUFJLEVBQ3BCQyxZQUFZLEtBQUssRUFDakJDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxLQUFLLEVBQ0wsR0FBR0MsV0FDSixFQUFFQztJQUNELE1BQU1DLGFBQWFqQixxREFBUUE7OENBQUNrQixDQUFBQSxRQUFTQSxNQUFNRCxVQUFVOztJQUNyRCxNQUFNRSxnQkFBZ0JuQixxREFBUUE7aURBQUNrQixDQUFBQSxRQUFTQSxNQUFNWCxNQUFNOztJQUNwRCxNQUFNYSxLQUFLcEIscURBQVFBO3NDQUFDa0IsQ0FBQUEsUUFBU0EsTUFBTUUsRUFBRTs7SUFDckMsTUFBTUMsU0FBU3JCLHFEQUFRQTswQ0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1HLE1BQU07O0lBQzdDLE1BQU1DLFlBQVl0QixxREFBUUE7NkNBQUNrQixDQUFBQSxRQUFTQSxNQUFNSSxTQUFTOztJQUNuRCxNQUFNQyxNQUFNdkIscURBQVFBO3VDQUFDa0IsQ0FBQUEsUUFBU0EsTUFBTUssR0FBRzs7SUFDdkMsTUFBTUMsTUFBTXhCLHFEQUFRQTt1Q0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1NLEdBQUc7O0lBQ3ZDLE1BQU1DLGNBQWN6QixxREFBUUE7K0NBQUNrQixDQUFBQSxRQUFTQSxNQUFNTyxXQUFXOztJQUN2RCxNQUFNQyxhQUFhbkIsVUFBVVk7SUFDN0IsTUFBTVEsaUJBQWlCbEIsY0FBY1ksT0FBT08sU0FBUyxJQUFJUixHQUFHWCxVQUFVO0lBQ3RFLE1BQU1vQixXQUFXM0IsMENBQWE7MkNBQUMsSUFBTSxJQUFJRSx1REFBZUEsQ0FBQ3NCOzBDQUFhO1FBQUNBO0tBQVc7SUFDbEZ6QixxREFBUUE7a0NBQUM7WUFDUCxJQUFJNEIsU0FBU0UsT0FBTyxFQUFFRixTQUFTRyxNQUFNO1FBQ3ZDO2lDQUFHLENBQUM7SUFDSjlCLDRDQUFlO21DQUFDO1lBQ2QsSUFBSVMsV0FBVztnQkFDYmtCLFNBQVNLLE9BQU8sQ0FBQ3ZCLGNBQWMsT0FBT2dCLGlCQUFpQmhCO1lBQ3pEO1lBQ0FrQixTQUFTSyxPQUFPLENBQUNQO1lBQ2pCOzJDQUFPLElBQU0sS0FBS0UsU0FBU00sT0FBTzs7UUFDcEM7a0NBQUc7UUFBQ3hCO1FBQVdnQjtRQUFnQm5CO1FBQVNxQjtRQUFVWjtLQUFXO0lBQzdEZiw0Q0FBZTttQ0FBQztZQUNkLE1BQU1rQztvREFBV0MsQ0FBQUE7b0JBQ2ZwQjtvQkFDQSxJQUFJVCxTQUFTaUIsWUFBWWpCLE9BQU87b0JBQ2hDLElBQUlJLFVBQVVBLFNBQVN5QjtnQkFDekI7O1lBQ0EsTUFBTUM7cURBQVlELENBQUFBO29CQUNoQixJQUFJeEIsU0FBU0EsUUFBUXdCO2dCQUN2Qjs7WUFDQSxNQUFNRTttREFBVUYsQ0FBQUE7b0JBQ2QsSUFBSXZCLE9BQU9BLE1BQU11QjtnQkFDbkI7O1lBQ0FSLFNBQVNXLGdCQUFnQixDQUFDLFVBQVVKO1lBQ3BDUCxTQUFTVyxnQkFBZ0IsQ0FBQyxTQUFTRjtZQUNuQ1QsU0FBU1csZ0JBQWdCLENBQUMsT0FBT0Q7WUFDakM7MkNBQU87b0JBQ0xWLFNBQVNZLG1CQUFtQixDQUFDLFNBQVNIO29CQUN0Q1QsU0FBU1ksbUJBQW1CLENBQUMsT0FBT0Y7b0JBQ3BDVixTQUFTWSxtQkFBbUIsQ0FBQyxVQUFVTDtnQkFDekM7O1FBQ0Y7a0NBQUc7UUFBQ3hCO1FBQVVDO1FBQVNDO1FBQU9lO1FBQVVaO1FBQVlLO0tBQVU7SUFDOURwQiw0Q0FBZTttQ0FBQztZQUNkLElBQUlJLGFBQWE7Z0JBQ2YsTUFBTW9DLE1BQU1sQixNQUFNSyxRQUFRO2dCQUMxQk4sSUFBSTtvQkFDRk07Z0JBQ0Y7Z0JBQ0E7K0NBQU8sSUFBTU4sSUFBSTs0QkFDZk0sVUFBVWE7d0JBQ1o7O1lBQ0Y7UUFDRjtrQ0FBRztRQUFDcEM7UUFBYXVCO0tBQVM7SUFDMUIsT0FBTyxXQUFXLEdBQUUzQixnREFBbUIsQ0FBQyxhQUFhSCw4RUFBUUEsQ0FBQztRQUM1RGlCLEtBQUtBO1FBQ0w0QixRQUFRZjtRQUNSbkIsZUFBZUE7SUFDakIsR0FBR0s7QUFDTDtBQUV5QiIsInNvdXJjZXMiOlsiL2hvbWUvY29kZXIvRGVza3RvcC9zbWFydF9sZWFybmluZy9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PcmJpdENvbnRyb2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIGFzIE9yYml0Q29udHJvbHMkMSB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5cbmNvbnN0IE9yYml0Q29udHJvbHMgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIG1ha2VEZWZhdWx0LFxuICBjYW1lcmEsXG4gIHJlZ3Jlc3MsXG4gIGRvbUVsZW1lbnQsXG4gIGVuYWJsZURhbXBpbmcgPSB0cnVlLFxuICBrZXlFdmVudHMgPSBmYWxzZSxcbiAgb25DaGFuZ2UsXG4gIG9uU3RhcnQsXG4gIG9uRW5kLFxuICAuLi5yZXN0UHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBpbnZhbGlkYXRlID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuaW52YWxpZGF0ZSk7XG4gIGNvbnN0IGRlZmF1bHRDYW1lcmEgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5jYW1lcmEpO1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3QgZXZlbnRzID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZXZlbnRzKTtcbiAgY29uc3Qgc2V0RXZlbnRzID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2V0RXZlbnRzKTtcbiAgY29uc3Qgc2V0ID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2V0KTtcbiAgY29uc3QgZ2V0ID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2V0KTtcbiAgY29uc3QgcGVyZm9ybWFuY2UgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5wZXJmb3JtYW5jZSk7XG4gIGNvbnN0IGV4cGxDYW1lcmEgPSBjYW1lcmEgfHwgZGVmYXVsdENhbWVyYTtcbiAgY29uc3QgZXhwbERvbUVsZW1lbnQgPSBkb21FbGVtZW50IHx8IGV2ZW50cy5jb25uZWN0ZWQgfHwgZ2wuZG9tRWxlbWVudDtcbiAgY29uc3QgY29udHJvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IG5ldyBPcmJpdENvbnRyb2xzJDEoZXhwbENhbWVyYSksIFtleHBsQ2FtZXJhXSk7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBpZiAoY29udHJvbHMuZW5hYmxlZCkgY29udHJvbHMudXBkYXRlKCk7XG4gIH0sIC0xKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoa2V5RXZlbnRzKSB7XG4gICAgICBjb250cm9scy5jb25uZWN0KGtleUV2ZW50cyA9PT0gdHJ1ZSA/IGV4cGxEb21FbGVtZW50IDoga2V5RXZlbnRzKTtcbiAgICB9XG4gICAgY29udHJvbHMuY29ubmVjdChleHBsRG9tRWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IHZvaWQgY29udHJvbHMuZGlzcG9zZSgpO1xuICB9LCBba2V5RXZlbnRzLCBleHBsRG9tRWxlbWVudCwgcmVncmVzcywgY29udHJvbHMsIGludmFsaWRhdGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGUgPT4ge1xuICAgICAgaW52YWxpZGF0ZSgpO1xuICAgICAgaWYgKHJlZ3Jlc3MpIHBlcmZvcm1hbmNlLnJlZ3Jlc3MoKTtcbiAgICAgIGlmIChvbkNoYW5nZSkgb25DaGFuZ2UoZSk7XG4gICAgfTtcbiAgICBjb25zdCBvblN0YXJ0Q2IgPSBlID0+IHtcbiAgICAgIGlmIChvblN0YXJ0KSBvblN0YXJ0KGUpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmRDYiA9IGUgPT4ge1xuICAgICAgaWYgKG9uRW5kKSBvbkVuZChlKTtcbiAgICB9O1xuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNhbGxiYWNrKTtcbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdzdGFydCcsIG9uU3RhcnRDYik7XG4gICAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgb25FbmRDYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXJ0Jywgb25TdGFydENiKTtcbiAgICAgIGNvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIG9uRW5kQ2IpO1xuICAgICAgY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2FsbGJhY2spO1xuICAgIH07XG4gIH0sIFtvbkNoYW5nZSwgb25TdGFydCwgb25FbmQsIGNvbnRyb2xzLCBpbnZhbGlkYXRlLCBzZXRFdmVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFrZURlZmF1bHQpIHtcbiAgICAgIGNvbnN0IG9sZCA9IGdldCgpLmNvbnRyb2xzO1xuICAgICAgc2V0KHtcbiAgICAgICAgY29udHJvbHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHNldCh7XG4gICAgICAgIGNvbnRyb2xzOiBvbGRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW21ha2VEZWZhdWx0LCBjb250cm9sc10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIG9iamVjdDogY29udHJvbHMsXG4gICAgZW5hYmxlRGFtcGluZzogZW5hYmxlRGFtcGluZ1xuICB9LCByZXN0UHJvcHMpKTtcbn0pO1xuXG5leHBvcnQgeyBPcmJpdENvbnRyb2xzIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJ1c2VUaHJlZSIsInVzZUZyYW1lIiwiUmVhY3QiLCJPcmJpdENvbnRyb2xzIiwiT3JiaXRDb250cm9scyQxIiwiZm9yd2FyZFJlZiIsIm1ha2VEZWZhdWx0IiwiY2FtZXJhIiwicmVncmVzcyIsImRvbUVsZW1lbnQiLCJlbmFibGVEYW1waW5nIiwia2V5RXZlbnRzIiwib25DaGFuZ2UiLCJvblN0YXJ0Iiwib25FbmQiLCJyZXN0UHJvcHMiLCJyZWYiLCJpbnZhbGlkYXRlIiwic3RhdGUiLCJkZWZhdWx0Q2FtZXJhIiwiZ2wiLCJldmVudHMiLCJzZXRFdmVudHMiLCJzZXQiLCJnZXQiLCJwZXJmb3JtYW5jZSIsImV4cGxDYW1lcmEiLCJleHBsRG9tRWxlbWVudCIsImNvbm5lY3RlZCIsImNvbnRyb2xzIiwidXNlTWVtbyIsImVuYWJsZWQiLCJ1cGRhdGUiLCJ1c2VFZmZlY3QiLCJjb25uZWN0IiwiZGlzcG9zZSIsImNhbGxiYWNrIiwiZSIsIm9uU3RhcnRDYiIsIm9uRW5kQ2IiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9sZCIsImNyZWF0ZUVsZW1lbnQiLCJvYmplY3QiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/shapes.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/shapes.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Box: () => (/* binding */ Box),\n/* harmony export */   Capsule: () => (/* binding */ Capsule),\n/* harmony export */   Circle: () => (/* binding */ Circle),\n/* harmony export */   Cone: () => (/* binding */ Cone),\n/* harmony export */   Cylinder: () => (/* binding */ Cylinder),\n/* harmony export */   Dodecahedron: () => (/* binding */ Dodecahedron),\n/* harmony export */   Extrude: () => (/* binding */ Extrude),\n/* harmony export */   Icosahedron: () => (/* binding */ Icosahedron),\n/* harmony export */   Lathe: () => (/* binding */ Lathe),\n/* harmony export */   Octahedron: () => (/* binding */ Octahedron),\n/* harmony export */   Plane: () => (/* binding */ Plane),\n/* harmony export */   Polyhedron: () => (/* binding */ Polyhedron),\n/* harmony export */   Ring: () => (/* binding */ Ring),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   Sphere: () => (/* binding */ Sphere),\n/* harmony export */   Tetrahedron: () => (/* binding */ Tetrahedron),\n/* harmony export */   Torus: () => (/* binding */ Torus),\n/* harmony export */   TorusKnot: () => (/* binding */ TorusKnot),\n/* harmony export */   Tube: () => (/* binding */ Tube)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\n\nfunction create(type, effect) {\n    const El = type + 'Geometry';\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ args, children, ...props }, fref)=>{\n        const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n        react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, {\n            \"create.useImperativeHandle\": ()=>ref.current\n        }[\"create.useImperativeHandle\"]);\n        react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect({\n            \"create.useLayoutEffect\": ()=>void (effect == null ? void 0 : effect(ref.current))\n        }[\"create.useLayoutEffect\"]);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            ref: ref\n        }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(El, {\n            attach: \"geometry\",\n            args: args\n        }), children);\n    });\n}\nconst Box = /* @__PURE__ */ create('box');\nconst Circle = /* @__PURE__ */ create('circle');\nconst Cone = /* @__PURE__ */ create('cone');\nconst Cylinder = /* @__PURE__ */ create('cylinder');\nconst Sphere = /* @__PURE__ */ create('sphere');\nconst Plane = /* @__PURE__ */ create('plane');\nconst Tube = /* @__PURE__ */ create('tube');\nconst Torus = /* @__PURE__ */ create('torus');\nconst TorusKnot = /* @__PURE__ */ create('torusKnot');\nconst Tetrahedron = /* @__PURE__ */ create('tetrahedron');\nconst Ring = /* @__PURE__ */ create('ring');\nconst Polyhedron = /* @__PURE__ */ create('polyhedron');\nconst Icosahedron = /* @__PURE__ */ create('icosahedron');\nconst Octahedron = /* @__PURE__ */ create('octahedron');\nconst Dodecahedron = /* @__PURE__ */ create('dodecahedron');\nconst Extrude = /* @__PURE__ */ create('extrude');\nconst Lathe = /* @__PURE__ */ create('lathe');\nconst Capsule = /* @__PURE__ */ create('capsule');\nconst Shape = /* @__PURE__ */ create('shape', ({ geometry })=>{\n    // Calculate UVs (by https://discourse.threejs.org/u/prisoner849)\n    // https://discourse.threejs.org/t/custom-shape-in-image-not-working/49348/10\n    const pos = geometry.attributes.position;\n    const b3 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromBufferAttribute(pos);\n    const b3size = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    b3.getSize(b3size);\n    const uv = [];\n    let x = 0, y = 0, u = 0, v = 0;\n    for(let i = 0; i < pos.count; i++){\n        x = pos.getX(i);\n        y = pos.getY(i);\n        u = (x - b3.min.x) / b3size.x;\n        v = (y - b3.min.y) / b3size.y;\n        uv.push(u, v);\n    }\n    geometry.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(uv, 2));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUUvQixTQUFTRyxPQUFPQyxJQUFJLEVBQUVDLE1BQU07SUFDMUIsTUFBTUMsS0FBS0YsT0FBTztJQUNsQixPQUFPLFdBQVcsR0FBRUgsNkNBQWdCLENBQUMsQ0FBQyxFQUNwQ08sSUFBSSxFQUNKQyxRQUFRLEVBQ1IsR0FBR0MsT0FDSixFQUFFQztRQUNELE1BQU1DLE1BQU1YLHlDQUFZLENBQUM7UUFDekJBLHNEQUF5QixDQUFDVTswQ0FBTSxJQUFNQyxJQUFJRyxPQUFPOztRQUNqRGQsa0RBQXFCO3NDQUFDLElBQU0sS0FBTUksQ0FBQUEsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT08sSUFBSUcsT0FBTzs7UUFDOUUsT0FBTyxXQUFXLEdBQUVkLGdEQUFtQixDQUFDLFFBQVFELDhFQUFRQSxDQUFDO1lBQ3ZEWSxLQUFLQTtRQUNQLEdBQUdGLFFBQVEsV0FBVyxHQUFFVCxnREFBbUIsQ0FBQ0ssSUFBSTtZQUM5Q1ksUUFBUTtZQUNSVixNQUFNQTtRQUNSLElBQUlDO0lBQ047QUFDRjtBQUNBLE1BQU1VLE1BQU0sYUFBYSxHQUFFaEIsT0FBTztBQUNsQyxNQUFNaUIsU0FBUyxhQUFhLEdBQUVqQixPQUFPO0FBQ3JDLE1BQU1rQixPQUFPLGFBQWEsR0FBRWxCLE9BQU87QUFDbkMsTUFBTW1CLFdBQVcsYUFBYSxHQUFFbkIsT0FBTztBQUN2QyxNQUFNb0IsU0FBUyxhQUFhLEdBQUVwQixPQUFPO0FBQ3JDLE1BQU1xQixRQUFRLGFBQWEsR0FBRXJCLE9BQU87QUFDcEMsTUFBTXNCLE9BQU8sYUFBYSxHQUFFdEIsT0FBTztBQUNuQyxNQUFNdUIsUUFBUSxhQUFhLEdBQUV2QixPQUFPO0FBQ3BDLE1BQU13QixZQUFZLGFBQWEsR0FBRXhCLE9BQU87QUFDeEMsTUFBTXlCLGNBQWMsYUFBYSxHQUFFekIsT0FBTztBQUMxQyxNQUFNMEIsT0FBTyxhQUFhLEdBQUUxQixPQUFPO0FBQ25DLE1BQU0yQixhQUFhLGFBQWEsR0FBRTNCLE9BQU87QUFDekMsTUFBTTRCLGNBQWMsYUFBYSxHQUFFNUIsT0FBTztBQUMxQyxNQUFNNkIsYUFBYSxhQUFhLEdBQUU3QixPQUFPO0FBQ3pDLE1BQU04QixlQUFlLGFBQWEsR0FBRTlCLE9BQU87QUFDM0MsTUFBTStCLFVBQVUsYUFBYSxHQUFFL0IsT0FBTztBQUN0QyxNQUFNZ0MsUUFBUSxhQUFhLEdBQUVoQyxPQUFPO0FBQ3BDLE1BQU1pQyxVQUFVLGFBQWEsR0FBRWpDLE9BQU87QUFDdEMsTUFBTWtDLFFBQVEsYUFBYSxHQUFFbEMsT0FBTyxTQUFTLENBQUMsRUFDNUNtQyxRQUFRLEVBQ1Q7SUFDQyxpRUFBaUU7SUFDakUsNkVBQTZFO0lBQzdFLE1BQU1DLE1BQU1ELFNBQVNFLFVBQVUsQ0FBQ0MsUUFBUTtJQUN4QyxNQUFNQyxLQUFLLElBQUl4Qyx1Q0FBVSxHQUFHMEMsc0JBQXNCLENBQUNMO0lBQ25ELE1BQU1NLFNBQVMsSUFBSTNDLDBDQUFhO0lBQ2hDd0MsR0FBR0ssT0FBTyxDQUFDRjtJQUNYLE1BQU1HLEtBQUssRUFBRTtJQUNiLElBQUlDLElBQUksR0FDTkMsSUFBSSxHQUNKQyxJQUFJLEdBQ0pDLElBQUk7SUFDTixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWQsSUFBSWUsS0FBSyxFQUFFRCxJQUFLO1FBQ2xDSixJQUFJVixJQUFJZ0IsSUFBSSxDQUFDRjtRQUNiSCxJQUFJWCxJQUFJaUIsSUFBSSxDQUFDSDtRQUNiRixJQUFJLENBQUNGLElBQUlQLEdBQUdlLEdBQUcsQ0FBQ1IsQ0FBQyxJQUFJSixPQUFPSSxDQUFDO1FBQzdCRyxJQUFJLENBQUNGLElBQUlSLEdBQUdlLEdBQUcsQ0FBQ1AsQ0FBQyxJQUFJTCxPQUFPSyxDQUFDO1FBQzdCRixHQUFHVSxJQUFJLENBQUNQLEdBQUdDO0lBQ2I7SUFDQWQsU0FBU3FCLFlBQVksQ0FBQyxNQUFNLElBQUl6RCx5REFBNEIsQ0FBQzhDLElBQUk7QUFDbkU7QUFFb0wiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL0Rlc2t0b3Avc21hcnRfbGVhcm5pbmcvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvc2hhcGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuZnVuY3Rpb24gY3JlYXRlKHR5cGUsIGVmZmVjdCkge1xuICBjb25zdCBFbCA9IHR5cGUgKyAnR2VvbWV0cnknO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgICBhcmdzLFxuICAgIGNoaWxkcmVuLFxuICAgIC4uLnByb3BzXG4gIH0sIGZyZWYpID0+IHtcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmcmVmLCAoKSA9PiByZWYuY3VycmVudCk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKGVmZmVjdCA9PSBudWxsID8gdm9pZCAwIDogZWZmZWN0KHJlZi5jdXJyZW50KSkpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiByZWZcbiAgICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVsLCB7XG4gICAgICBhdHRhY2g6IFwiZ2VvbWV0cnlcIixcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KSwgY2hpbGRyZW4pO1xuICB9KTtcbn1cbmNvbnN0IEJveCA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnYm94Jyk7XG5jb25zdCBDaXJjbGUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ2NpcmNsZScpO1xuY29uc3QgQ29uZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnY29uZScpO1xuY29uc3QgQ3lsaW5kZXIgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ2N5bGluZGVyJyk7XG5jb25zdCBTcGhlcmUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ3NwaGVyZScpO1xuY29uc3QgUGxhbmUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ3BsYW5lJyk7XG5jb25zdCBUdWJlID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCd0dWJlJyk7XG5jb25zdCBUb3J1cyA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgndG9ydXMnKTtcbmNvbnN0IFRvcnVzS25vdCA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgndG9ydXNLbm90Jyk7XG5jb25zdCBUZXRyYWhlZHJvbiA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgndGV0cmFoZWRyb24nKTtcbmNvbnN0IFJpbmcgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ3JpbmcnKTtcbmNvbnN0IFBvbHloZWRyb24gPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ3BvbHloZWRyb24nKTtcbmNvbnN0IEljb3NhaGVkcm9uID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCdpY29zYWhlZHJvbicpO1xuY29uc3QgT2N0YWhlZHJvbiA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnb2N0YWhlZHJvbicpO1xuY29uc3QgRG9kZWNhaGVkcm9uID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCdkb2RlY2FoZWRyb24nKTtcbmNvbnN0IEV4dHJ1ZGUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ2V4dHJ1ZGUnKTtcbmNvbnN0IExhdGhlID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCdsYXRoZScpO1xuY29uc3QgQ2Fwc3VsZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnY2Fwc3VsZScpO1xuY29uc3QgU2hhcGUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ3NoYXBlJywgKHtcbiAgZ2VvbWV0cnlcbn0pID0+IHtcbiAgLy8gQ2FsY3VsYXRlIFVWcyAoYnkgaHR0cHM6Ly9kaXNjb3Vyc2UudGhyZWVqcy5vcmcvdS9wcmlzb25lcjg0OSlcbiAgLy8gaHR0cHM6Ly9kaXNjb3Vyc2UudGhyZWVqcy5vcmcvdC9jdXN0b20tc2hhcGUtaW4taW1hZ2Utbm90LXdvcmtpbmcvNDkzNDgvMTBcbiAgY29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgYjMgPSBuZXcgVEhSRUUuQm94MygpLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUocG9zKTtcbiAgY29uc3QgYjNzaXplID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgYjMuZ2V0U2l6ZShiM3NpemUpO1xuICBjb25zdCB1diA9IFtdO1xuICBsZXQgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgdSA9IDAsXG4gICAgdiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zLmNvdW50OyBpKyspIHtcbiAgICB4ID0gcG9zLmdldFgoaSk7XG4gICAgeSA9IHBvcy5nZXRZKGkpO1xuICAgIHUgPSAoeCAtIGIzLm1pbi54KSAvIGIzc2l6ZS54O1xuICAgIHYgPSAoeSAtIGIzLm1pbi55KSAvIGIzc2l6ZS55O1xuICAgIHV2LnB1c2godSwgdik7XG4gIH1cbiAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2LCAyKSk7XG59KTtcblxuZXhwb3J0IHsgQm94LCBDYXBzdWxlLCBDaXJjbGUsIENvbmUsIEN5bGluZGVyLCBEb2RlY2FoZWRyb24sIEV4dHJ1ZGUsIEljb3NhaGVkcm9uLCBMYXRoZSwgT2N0YWhlZHJvbiwgUGxhbmUsIFBvbHloZWRyb24sIFJpbmcsIFNoYXBlLCBTcGhlcmUsIFRldHJhaGVkcm9uLCBUb3J1cywgVG9ydXNLbm90LCBUdWJlIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJSZWFjdCIsIlRIUkVFIiwiY3JlYXRlIiwidHlwZSIsImVmZmVjdCIsIkVsIiwiZm9yd2FyZFJlZiIsImFyZ3MiLCJjaGlsZHJlbiIsInByb3BzIiwiZnJlZiIsInJlZiIsInVzZVJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjdXJyZW50IiwidXNlTGF5b3V0RWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsImF0dGFjaCIsIkJveCIsIkNpcmNsZSIsIkNvbmUiLCJDeWxpbmRlciIsIlNwaGVyZSIsIlBsYW5lIiwiVHViZSIsIlRvcnVzIiwiVG9ydXNLbm90IiwiVGV0cmFoZWRyb24iLCJSaW5nIiwiUG9seWhlZHJvbiIsIkljb3NhaGVkcm9uIiwiT2N0YWhlZHJvbiIsIkRvZGVjYWhlZHJvbiIsIkV4dHJ1ZGUiLCJMYXRoZSIsIkNhcHN1bGUiLCJTaGFwZSIsImdlb21ldHJ5IiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiYjMiLCJCb3gzIiwic2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSIsImIzc2l6ZSIsIlZlY3RvcjMiLCJnZXRTaXplIiwidXYiLCJ4IiwieSIsInUiLCJ2IiwiaSIsImNvdW50IiwiZ2V0WCIsImdldFkiLCJtaW4iLCJwdXNoIiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/shapes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/glsl/distort.vert.glsl.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/glsl/distort.vert.glsl.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ distort)\n/* harmony export */ });\nvar distort = \"#define GLSLIFY 1\\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\"; // eslint-disable-line\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9nbHNsL2Rpc3RvcnQudmVydC5nbHNsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxVQUFVLDI1Q0FBMjVDLHNCQUFzQjtBQUVqNkMiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL0Rlc2t0b3Avc21hcnRfbGVhcm5pbmcvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvZ2xzbC9kaXN0b3J0LnZlcnQuZ2xzbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzdG9ydCA9IFwiI2RlZmluZSBHTFNMSUZZIDFcXG52ZWMzIG1vZDI4OSh2ZWMzIHgpe3JldHVybiB4LWZsb29yKHgqKDEuMC8yODkuMCkpKjI4OS4wO312ZWM0IG1vZDI4OSh2ZWM0IHgpe3JldHVybiB4LWZsb29yKHgqKDEuMC8yODkuMCkpKjI4OS4wO312ZWM0IHBlcm11dGUodmVjNCB4KXtyZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO312ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OS0wLjg1MzczNDcyMDk1MzE0KnI7fWZsb2F0IHNub2lzZSh2ZWMzIHYpe2NvbnN0IHZlYzIgQz12ZWMyKDEuMC82LjAsMS4wLzMuMCk7Y29uc3QgdmVjNCBEPXZlYzQoMC4wLDAuNSwxLjAsMi4wKTt2ZWMzIGk9Zmxvb3Ioditkb3QodixDLnl5eSkpO3ZlYzMgeDA9di1pK2RvdChpLEMueHh4KTt2ZWMzIGc9c3RlcCh4MC55engseDAueHl6KTt2ZWMzIGw9MS4wLWc7dmVjMyBpMT1taW4oZy54eXosbC56eHkpO3ZlYzMgaTI9bWF4KGcueHl6LGwuenh5KTt2ZWMzIHgxPXgwLWkxK0MueHh4O3ZlYzMgeDI9eDAtaTIrQy55eXk7dmVjMyB4Mz14MC1ELnl5eTtpPW1vZDI4OShpKTt2ZWM0IHA9cGVybXV0ZShwZXJtdXRlKHBlcm11dGUoaS56K3ZlYzQoMC4wLGkxLnosaTIueiwxLjApKStpLnkrdmVjNCgwLjAsaTEueSxpMi55LDEuMCkpK2kueCt2ZWM0KDAuMCxpMS54LGkyLngsMS4wKSk7ZmxvYXQgbl89MC4xNDI4NTcxNDI4NTc7dmVjMyBucz1uXypELnd5ei1ELnh6eDt2ZWM0IGo9cC00OS4wKmZsb29yKHAqbnMueipucy56KTt2ZWM0IHhfPWZsb29yKGoqbnMueik7dmVjNCB5Xz1mbG9vcihqLTcuMCp4Xyk7dmVjNCB4PXhfKm5zLngrbnMueXl5eTt2ZWM0IHk9eV8qbnMueCtucy55eXl5O3ZlYzQgaD0xLjAtYWJzKHgpLWFicyh5KTt2ZWM0IGIwPXZlYzQoeC54eSx5Lnh5KTt2ZWM0IGIxPXZlYzQoeC56dyx5Lnp3KTt2ZWM0IHMwPWZsb29yKGIwKSoyLjArMS4wO3ZlYzQgczE9Zmxvb3IoYjEpKjIuMCsxLjA7dmVjNCBzaD0tc3RlcChoLHZlYzQoMC4wKSk7dmVjNCBhMD1iMC54enl3K3MwLnh6eXcqc2gueHh5eTt2ZWM0IGExPWIxLnh6eXcrczEueHp5dypzaC56end3O3ZlYzMgcDA9dmVjMyhhMC54eSxoLngpO3ZlYzMgcDE9dmVjMyhhMC56dyxoLnkpO3ZlYzMgcDI9dmVjMyhhMS54eSxoLnopO3ZlYzMgcDM9dmVjMyhhMS56dyxoLncpO3ZlYzQgbm9ybT10YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSxkb3QocDEscDEpLGRvdChwMixwMiksZG90KHAzLHAzKSkpO3AwKj1ub3JtLng7cDEqPW5vcm0ueTtwMio9bm9ybS56O3AzKj1ub3JtLnc7dmVjNCBtPW1heCgwLjYtdmVjNChkb3QoeDAseDApLGRvdCh4MSx4MSksZG90KHgyLHgyKSxkb3QoeDMseDMpKSwwLjApO209bSptO3JldHVybiA0Mi4wKmRvdChtKm0sdmVjNChkb3QocDAseDApLGRvdChwMSx4MSksZG90KHAyLHgyKSxkb3QocDMseDMpKSk7fVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmV4cG9ydCB7IGRpc3RvcnQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImRpc3RvcnQiLCJkZWZhdWx0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/glsl/distort.vert.glsl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-0dc84b81.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-0dc84b81.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useThree),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useFrame),\n/* harmony export */   D: () => (/* binding */ useGraph),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useLoader),\n/* harmony export */   _: () => (/* binding */ _roots),\n/* harmony export */   a: () => (/* binding */ useMutableCallback),\n/* harmony export */   b: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   c: () => (/* binding */ createRoot),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createPointerEvents),\n/* harmony export */   g: () => (/* binding */ createEvents),\n/* harmony export */   h: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ addEffect),\n/* harmony export */   k: () => (/* binding */ addAfterEffect),\n/* harmony export */   l: () => (/* binding */ addTail),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ createPortal),\n/* harmony export */   p: () => (/* binding */ context),\n/* harmony export */   q: () => (/* binding */ applyProps),\n/* harmony export */   r: () => (/* binding */ reconciler),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useBridge),\n/* harmony export */   v: () => (/* binding */ dispose),\n/* harmony export */   w: () => (/* binding */ act),\n/* harmony export */   x: () => (/* binding */ buildGraph),\n/* harmony export */   y: () => (/* binding */ useInstanceHandle),\n/* harmony export */   z: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\n/**\r\n * Returns the instance's initial (outmost) root.\r\n */ function findInitialRoot(instance) {\n    let root = instance.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n/**\r\n * Safely flush async effects when testing, simulating a legacy root.\r\n */ const act = react__WEBPACK_IMPORTED_MODULE_0__.act;\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty('current');\nconst isColorRepresentation = (value)=>value != null && (typeof value === 'string' || typeof value === 'number' || value.isColor);\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */ const useIsomorphicLayoutEffect = /* @__PURE__ */ ((_window$document, _window$navigator)=> false && (0))() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect({\n        \"useMutableCallback.useIsomorphicLayoutEffect\": ()=>void (ref.current = fn)\n    }[\"useMutableCallback.useIsomorphicLayoutEffect\"], [\n        fn\n    ]);\n    return ref;\n}\n/**\r\n * Bridges renderer Context and StrictMode from a primary renderer.\r\n */ function useBridge() {\n    const fiber = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useFiber)();\n    const ContextBridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useContextBridge)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useBridge.useMemo\": ()=>({\n                \"useBridge.useMemo\": ({ children })=>{\n                    const strict = !!(0,its_fine__WEBPACK_IMPORTED_MODULE_5__.traverseFiber)(fiber, true, {\n                        \"useBridge.useMemo\": (node)=>node.type === react__WEBPACK_IMPORTED_MODULE_0__.StrictMode\n                    }[\"useBridge.useMemo\"]);\n                    const Root = strict ? react__WEBPACK_IMPORTED_MODULE_0__.StrictMode : react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n                    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Root, {\n                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ContextBridge, {\n                            children: children\n                        })\n                    });\n                }\n            })[\"useBridge.useMemo\"]\n    }[\"useBridge.useMemo\"], [\n        fiber,\n        ContextBridge\n    ]);\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect({\n        \"Block.useIsomorphicLayoutEffect\": ()=>{\n            set(new Promise({\n                \"Block.useIsomorphicLayoutEffect\": ()=>null\n            }[\"Block.useIsomorphicLayoutEffect\"]));\n            return ({\n                \"Block.useIsomorphicLayoutEffect\": ()=>set(false)\n            })[\"Block.useIsomorphicLayoutEffect\"];\n        }\n    }[\"Block.useIsomorphicLayoutEffect\"], [\n        set\n    ]);\n    return null;\n}\n// NOTE: static members get down-level transpiled to mutations which break tree-shaking\nconst ErrorBoundary = /* @__PURE__ */ ((_ErrorBoundary)=>(_ErrorBoundary = class ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n        constructor(...args){\n            super(...args);\n            this.state = {\n                error: false\n            };\n        }\n        componentDidCatch(err) {\n            this.props.set(err);\n        }\n        render() {\n            return this.state.error ? null : this.props.children;\n        }\n    }, _ErrorBoundary.getDerivedStateFromError = ()=>({\n            error: true\n        }), _ErrorBoundary))();\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\r\n * Returns instance root state\r\n */ function getRootState(obj) {\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== 'function',\n    fun: (a)=>typeof a === 'function',\n    str: (a)=>typeof a === 'string',\n    num: (a)=>typeof a === 'number',\n    boo: (a)=>typeof a === 'boolean',\n    und: (a)=>a === void 0,\n    nul: (a)=>a === null,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = 'shallow', objects = 'reference', strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === 'reference') return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === 'reference') return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === 'shallow' && objects === 'shallow') {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: 'reference'\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.type !== 'Scene') obj.dispose == null ? void 0 : obj.dispose();\n    for(const p in obj){\n        const prop = obj[p];\n        if ((prop == null ? void 0 : prop.type) !== 'Scene') prop == null ? void 0 : prop.dispose == null ? void 0 : prop.dispose();\n    }\n}\nconst REACT_INTERNAL_PROPS = [\n    'children',\n    'key',\n    'ref'\n];\n// Gets only instance props from reconciler fibers\nfunction getInstanceProps(queue) {\n    const props = {};\n    for(const key in queue){\n        if (!REACT_INTERNAL_PROPS.includes(key)) props[key] = queue[key];\n    }\n    return props;\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(target, root, type, props) {\n    const object = target;\n    // Create instance descriptor\n    let instance = object == null ? void 0 : object.__r3f;\n    if (!instance) {\n        instance = {\n            root,\n            type,\n            parent: null,\n            children: [],\n            props: getInstanceProps(props),\n            object,\n            eventCount: 0,\n            handlers: {},\n            isHidden: false\n        };\n        if (object) object.__r3f = instance;\n    }\n    return instance;\n}\nfunction resolve(root, key) {\n    var _target;\n    let target = root[key];\n    if (!key.includes('-')) return {\n        root,\n        key,\n        target\n    };\n    // Resolve pierced target\n    const chain = key.split('-');\n    target = chain.reduce((acc, key)=>acc[key], root);\n    key = chain.pop();\n    // Switch root if atomic\n    if (!((_target = target) != null && _target.set)) root = chain.reduce((acc, key)=>acc[key], root);\n    return {\n        root,\n        key,\n        target\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child) {\n    if (is.str(child.props.attach)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(child.props.attach)) {\n            const index = child.props.attach.replace(INDEX_REGEX, '');\n            const { root, key } = resolve(parent.object, index);\n            if (!Array.isArray(root[key])) root[key] = [];\n        }\n        const { root, key } = resolve(parent.object, child.props.attach);\n        child.previousAttach = root[key];\n        root[key] = child.object;\n    } else if (is.fun(child.props.attach)) {\n        child.previousAttach = child.props.attach(parent.object, child.object);\n    }\n}\nfunction detach(parent, child) {\n    if (is.str(child.props.attach)) {\n        const { root, key } = resolve(parent.object, child.props.attach);\n        const previous = child.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete root[key];\n        else root[key] = previous;\n    } else {\n        child.previousAttach == null ? void 0 : child.previousAttach(parent.object, child.object);\n    }\n    delete child.previousAttach;\n}\nconst RESERVED_PROPS = [\n    ...REACT_INTERNAL_PROPS,\n    // Instance props\n    'args',\n    'dispose',\n    'attach',\n    'object',\n    'onUpdate',\n    // Behavior flags\n    'dispose'\n];\nconst MEMOIZED_PROTOTYPES = new Map();\nfunction getMemoizedPrototype(root) {\n    let ctor = MEMOIZED_PROTOTYPES.get(root.constructor);\n    try {\n        if (!ctor) {\n            ctor = new root.constructor();\n            MEMOIZED_PROTOTYPES.set(root.constructor, ctor);\n        }\n    } catch (e) {\n    // ...\n    }\n    return ctor;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, newProps) {\n    const changedProps = {};\n    // Sort through props\n    for(const prop in newProps){\n        // Skip reserved keys\n        if (RESERVED_PROPS.includes(prop)) continue;\n        // Skip if props match\n        if (is.equ(newProps[prop], instance.props[prop])) continue;\n        // Props changed, add them\n        changedProps[prop] = newProps[prop];\n        // Reset pierced props\n        for(const other in newProps){\n            if (other.startsWith(`${prop}-`)) changedProps[other] = newProps[other];\n        }\n    }\n    // Reset removed props for HMR\n    for(const prop in instance.props){\n        if (RESERVED_PROPS.includes(prop) || newProps.hasOwnProperty(prop)) continue;\n        const { root, key } = resolve(instance.object, prop);\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (root.constructor && root.constructor.length === 0) {\n            // create a blank slate of the instance and copy the particular parameter.\n            const ctor = getMemoizedPrototype(root);\n            if (!is.und(ctor)) changedProps[key] = ctor[key];\n        } else {\n            // instance does not have constructor, just set it to 0\n            changedProps[key] = 0;\n        }\n    }\n    return changedProps;\n}\n// https://github.com/mrdoob/three.js/pull/27042\n// https://github.com/mrdoob/three.js/pull/22748\nconst colorMaps = [\n    'map',\n    'emissiveMap',\n    'sheenColorMap',\n    'specularColorMap',\n    'envMap'\n];\nconst EVENT_REGEX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;\n// This function applies a set of changes to the instance\nfunction applyProps(object, props) {\n    var _instance$object;\n    const instance = object.__r3f;\n    const rootState = instance && findInitialRoot(instance).getState();\n    const prevHandlers = instance == null ? void 0 : instance.eventCount;\n    for(const prop in props){\n        let value = props[prop];\n        // Don't mutate reserved keys\n        if (RESERVED_PROPS.includes(prop)) continue;\n        // Deal with pointer events, including removing them if undefined\n        if (instance && EVENT_REGEX.test(prop)) {\n            if (typeof value === 'function') instance.handlers[prop] = value;\n            else delete instance.handlers[prop];\n            instance.eventCount = Object.keys(instance.handlers).length;\n            continue;\n        }\n        // Ignore setting undefined props\n        // https://github.com/pmndrs/react-three-fiber/issues/274\n        if (value === undefined) continue;\n        let { root, key, target } = resolve(object, prop);\n        // Layers must be written to the mask property\n        if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers) {\n            target.mask = value.mask;\n        } else if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Color && isColorRepresentation(value)) {\n            target.set(value);\n        } else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof target.copy === 'function' && value != null && value.constructor && target.constructor === value.constructor) {\n            target.copy(value);\n        } else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && Array.isArray(value)) {\n            if (typeof target.fromArray === 'function') target.fromArray(value);\n            else target.set(...value);\n        } else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof value === 'number') {\n            // Allow setting array scalars\n            if (typeof target.setScalar === 'function') target.setScalar(value);\n            else target.set(value);\n        } else {\n            var _root$key;\n            root[key] = value;\n            // Auto-convert sRGB texture parameters for built-in materials\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            // https://github.com/mrdoob/three.js/pull/25857\n            if (rootState && !rootState.linear && colorMaps.includes(key) && (_root$key = root[key]) != null && _root$key.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            root[key].format === three__WEBPACK_IMPORTED_MODULE_6__.RGBAFormat && root[key].type === three__WEBPACK_IMPORTED_MODULE_6__.UnsignedByteType) {\n                // NOTE: this cannot be set from the renderer (e.g. sRGB source textures rendered to P3)\n                root[key].colorSpace = three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n            }\n        }\n    }\n    // Register event handlers\n    if (instance != null && instance.parent && rootState != null && rootState.internal && (_instance$object = instance.object) != null && _instance$object.isObject3D && prevHandlers !== instance.eventCount) {\n        const object = instance.object;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = rootState.internal.interaction.indexOf(object);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (instance.eventCount && object.raycast !== null) {\n            rootState.internal.interaction.push(object);\n        }\n    }\n    // Auto-attach geometries and materials\n    if (instance && instance.props.attach === undefined) {\n        if (instance.object.isBufferGeometry) instance.props.attach = 'geometry';\n        else if (instance.object.isMaterial) instance.props.attach = 'material';\n    }\n    // Instance was updated, request a frame\n    if (instance) invalidateInstance(instance);\n    return object;\n}\nfunction invalidateInstance(instance) {\n    var _instance$root;\n    if (!instance.parent) return;\n    instance.props.onUpdate == null ? void 0 : instance.props.onUpdate(instance.object);\n    const state = (_instance$root = instance.root) == null ? void 0 : _instance$root.getState == null ? void 0 : _instance$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateCamera(camera, size) {\n    // Do not mess with the camera if it belongs to the user\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    if (camera.manual) return;\n    if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n    } else {\n        camera.aspect = size.width / size.height;\n    }\n    camera.updateProjectionMatrix();\n}\nconst isObject3D = (object)=>object == null ? void 0 : object.isObject3D;\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                'Move',\n                'Over',\n                'Enter',\n                'Out',\n                'Leave'\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                let state = getRootState(hit.object);\n                // If the object is not managed by R3F, it might be parented to an element which is.\n                // Traverse upwards until we find a managed parent and use its state instead.\n                if (!state) {\n                    hit.object.traverseAncestors((obj)=>{\n                        const parentState = getRootState(obj);\n                        if (parentState) {\n                            state = parentState;\n                            return false;\n                        }\n                    });\n                }\n                if (state) {\n                    const { raycaster, pointer, camera, internal } = state;\n                    const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                    const hasPointerCapture = (id)=>{\n                        var _internal$capturedMap, _internal$capturedMap2;\n                        return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                    };\n                    const setPointerCapture = (id)=>{\n                        const captureData = {\n                            intersection: hit,\n                            target: event.target\n                        };\n                        if (internal.capturedMap.has(id)) {\n                            // if the pointerId was previously captured, we add the hit to the\n                            // event capturedMap.\n                            internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                        } else {\n                            // if the pointerId was not previously captured, we create a map\n                            // containing the hitObject, and the hit. hitObject is used for\n                            // faster access.\n                            internal.capturedMap.set(id, new Map([\n                                [\n                                    hit.eventObject,\n                                    captureData\n                                ]\n                            ]));\n                        }\n                        event.target.setPointerCapture(id);\n                    };\n                    const releasePointerCapture = (id)=>{\n                        const captures = internal.capturedMap.get(id);\n                        if (captures) {\n                            releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                        }\n                    };\n                    // Add native event props\n                    let extractEventProps = {};\n                    // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                    for(let prop in event){\n                        let property = event[prop];\n                        // Only copy over atomics, leave functions alone as these should be\n                        // called as event.nativeEvent.fn()\n                        if (typeof property !== 'function') extractEventProps[prop] = property;\n                    }\n                    let raycastEvent = {\n                        ...hit,\n                        ...extractEventProps,\n                        pointer,\n                        intersections,\n                        stopped: localState.stopped,\n                        delta,\n                        unprojectedPoint,\n                        ray: raycaster.ray,\n                        camera: camera,\n                        // Hijack stopPropagation, which just sets a flag\n                        stopPropagation () {\n                            // https://github.com/pmndrs/react-three-fiber/issues/596\n                            // Events are not allowed to stop propagation if the pointer has been captured\n                            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n                            // We only authorize stopPropagation...\n                            if (// ...if this pointer hasn't been captured\n                            !capturesForPointer || // ... or if the hit object is capturing the pointer\n                            capturesForPointer.has(hit.eventObject)) {\n                                raycastEvent.stopped = localState.stopped = true;\n                                // Propagation is stopped, remove all other hover records\n                                // An event handler is only allowed to flush other handlers if it is hovered itself\n                                if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                    // Objects cannot flush out higher up objects that have already caught the event\n                                    const higher = intersections.slice(0, intersections.indexOf(hit));\n                                    cancelPointer([\n                                        ...higher,\n                                        hit\n                                    ]);\n                                }\n                            }\n                        },\n                        // there should be a distinction between target and currentTarget\n                        target: {\n                            hasPointerCapture,\n                            setPointerCapture,\n                            releasePointerCapture\n                        },\n                        currentTarget: {\n                            hasPointerCapture,\n                            setPointerCapture,\n                            releasePointerCapture\n                        },\n                        nativeEvent: event\n                    };\n                    // Call subscribers\n                    callback(raycastEvent);\n                    // Event bubbling may be interrupted by stopPropagation\n                    if (localState.stopped === true) break;\n                }\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    const handlers = instance.handlers;\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case 'onPointerLeave':\n            case 'onPointerCancel':\n                return ()=>cancelPointer([]);\n            case 'onLostPointerCapture':\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === 'onPointerMove';\n            const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === 'onPointerDown') {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                const handlers = instance.handlers;\n                /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootStore = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target.isVector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_6__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            scene: null,\n            xr: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_6__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: 'always',\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, top = 0, left = 0)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top,\n                    left\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = 'always')=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== 'never') {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                // Events\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                // Updates\n                active: false,\n                frames: 0,\n                priority: 0,\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootStore.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootStore.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootStore.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            if (viewport.dpr > 0) gl.setPixelRatio(viewport.dpr);\n            const updateStyle = typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootStore.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootStore;\n};\n/**\r\n * Exposes an object's {@link Instance}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(instance, {\n        \"useInstanceHandle.useImperativeHandle\": ()=>ref.current.__r3f\n    }[\"useInstanceHandle.useImperativeHandle\"], [\n        ref\n    ]);\n    return instance;\n}\n/**\r\n * Returns the R3F Canvas' Zustand store. Useful for [transient updates](https://github.com/pmndrs/zustand#transient-updates-for-often-occurring-state-changes).\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usestore\r\n */ function useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n    return store;\n}\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect({\n        \"useFrame.useIsomorphicLayoutEffect\": ()=>subscribe(ref, renderPriority, store)\n    }[\"useFrame.useIsomorphicLayoutEffect\"], [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useGraph.useMemo\": ()=>buildGraph(object)\n    }[\"useGraph.useMemo\"], [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nconst isConstructor$1 = (value)=>{\n    var _value$prototype;\n    return typeof value === 'function' && (value == null ? void 0 : (_value$prototype = value.prototype) == null ? void 0 : _value$prototype.constructor) === value;\n};\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        let loader;\n        // Construct and cache loader if constructor was passed\n        if (isConstructor$1(Proto)) {\n            loader = memoizedLoaders.get(Proto);\n            if (!loader) {\n                loader = new Proto();\n                memoizedLoaders.set(Proto, loader);\n            }\n        } else {\n            loader = Proto;\n        }\n        // Apply loader extensions\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (isObject3D(data == null ? void 0 : data.scene)) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n    };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */ function useLoader(loader, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.suspend)(loadingFn(extensions, onProgress), [\n        loader,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object(s)\n    return Array.isArray(input) ? results : results[0];\n}\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */ useLoader.preload = function(loader, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.preload)(loadingFn(extensions), [\n        loader,\n        ...keys\n    ]);\n};\n/**\r\n * Removes a loaded asset from cache.\r\n */ useLoader.clear = function(loader, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.clear)([\n        loader,\n        ...keys\n    ]);\n};\n// TODO: upstream to DefinitelyTyped for React 19\n// https://github.com/facebook/react/issues/28956\nfunction createReconciler(config) {\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()(config);\n    reconciler.injectIntoDevTools({\n        bundleType: typeof process !== 'undefined' && \"development\" !== 'production' ? 1 : 0,\n        rendererPackageName: '@react-three/fiber',\n        version: react__WEBPACK_IMPORTED_MODULE_0__.version\n    });\n    return reconciler;\n}\nconst NoEventPriority = 0;\n// TODO: handle constructor overloads\n// https://github.com/pmndrs/react-three-fiber/pull/2931\n// https://github.com/microsoft/TypeScript/issues/37079\nconst catalogue = {};\nconst PREFIX_REGEX = /^three(?=[A-Z])/;\nconst toPascalCase = (type)=>`${type[0].toUpperCase()}${type.slice(1)}`;\nlet i = 0;\nconst isConstructor = (object)=>typeof object === 'function';\nfunction extend(objects) {\n    if (isConstructor(objects)) {\n        const Component = `${i++}`;\n        catalogue[Component] = objects;\n        return Component;\n    } else {\n        Object.assign(catalogue, objects);\n    }\n}\nfunction validateInstance(type, props) {\n    // Get target from catalogue\n    const name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    const target = catalogue[name];\n    // Validate element target\n    if (type !== 'primitive' && !target) throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n    // Validate primitives\n    if (type === 'primitive' && !props.object) throw new Error(`R3F: Primitives without 'object' are invalid!`);\n    // Throw if an object or literal was passed for args\n    if (props.args !== undefined && !Array.isArray(props.args)) throw new Error('R3F: The args prop must be an array!');\n}\nfunction createInstance(type, props, root) {\n    var _props$object;\n    // Remove three* prefix from elements\n    type = type.replace(PREFIX_REGEX, '');\n    validateInstance(type, props);\n    // Regenerate the R3F instance for primitives to simulate a new object\n    if (type === 'primitive' && (_props$object = props.object) != null && _props$object.__r3f) delete props.object.__r3f;\n    return prepare(props.object, root, type, props);\n}\nfunction hideInstance(instance) {\n    if (!instance.isHidden) {\n        var _instance$parent;\n        if (instance.props.attach && (_instance$parent = instance.parent) != null && _instance$parent.object) {\n            detach(instance.parent, instance);\n        } else if (isObject3D(instance.object)) {\n            instance.object.visible = false;\n        }\n        instance.isHidden = true;\n        invalidateInstance(instance);\n    }\n}\nfunction unhideInstance(instance) {\n    if (instance.isHidden) {\n        var _instance$parent2;\n        if (instance.props.attach && (_instance$parent2 = instance.parent) != null && _instance$parent2.object) {\n            attach(instance.parent, instance);\n        } else if (isObject3D(instance.object) && instance.props.visible !== false) {\n            instance.object.visible = true;\n        }\n        instance.isHidden = false;\n        invalidateInstance(instance);\n    }\n}\n// https://github.com/facebook/react/issues/20271\n// This will make sure events and attach are only handled once when trees are complete\nfunction handleContainerEffects(parent, child, beforeChild) {\n    // Bail if tree isn't mounted or parent is not a container.\n    // This ensures that the tree is finalized and React won't discard results to Suspense\n    const state = child.root.getState();\n    if (!parent.parent && parent.object !== state.scene) return;\n    // Create & link object on first run\n    if (!child.object) {\n        var _child$props$object, _child$props$args;\n        // Get target from catalogue\n        const target = catalogue[toPascalCase(child.type)];\n        // Create object\n        child.object = (_child$props$object = child.props.object) != null ? _child$props$object : new target(...(_child$props$args = child.props.args) != null ? _child$props$args : []);\n        child.object.__r3f = child;\n    }\n    // Set initial props\n    applyProps(child.object, child.props);\n    // Append instance\n    if (child.props.attach) {\n        attach(parent, child);\n    } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n        const childIndex = parent.object.children.indexOf(beforeChild == null ? void 0 : beforeChild.object);\n        if (beforeChild && childIndex !== -1) {\n            child.object.parent = parent.object;\n            parent.object.children.splice(childIndex, 0, child.object);\n            child.object.dispatchEvent({\n                type: 'added'\n            });\n            parent.object.dispatchEvent({\n                type: 'childadded',\n                child: child.object\n            });\n        } else {\n            parent.object.add(child.object);\n        }\n    }\n    // Link subtree\n    for (const childInstance of child.children)handleContainerEffects(child, childInstance);\n    // Tree was updated, request a frame\n    invalidateInstance(child);\n}\nfunction appendChild(parent, child) {\n    if (!child) return;\n    // Link instances\n    child.parent = parent;\n    parent.children.push(child);\n    // Attach tree once complete\n    handleContainerEffects(parent, child);\n}\nfunction insertBefore(parent, child, beforeChild) {\n    if (!child || !beforeChild) return;\n    // Link instances\n    child.parent = parent;\n    const childIndex = parent.children.indexOf(beforeChild);\n    if (childIndex !== -1) parent.children.splice(childIndex, 0, child);\n    else parent.children.push(child);\n    // Attach tree once complete\n    handleContainerEffects(parent, child, beforeChild);\n}\nfunction disposeOnIdle(object) {\n    if (typeof object.dispose === 'function') {\n        const handleDispose = ()=>{\n            try {\n                object.dispose();\n            } catch  {\n            // no-op\n            }\n        };\n        // In a testing environment, cleanup immediately\n        if (typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined') handleDispose();\n        else (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, handleDispose);\n    }\n}\nfunction removeChild(parent, child, dispose) {\n    if (!child) return;\n    // Unlink instances\n    child.parent = null;\n    const childIndex = parent.children.indexOf(child);\n    if (childIndex !== -1) parent.children.splice(childIndex, 1);\n    // Eagerly tear down tree\n    if (child.props.attach) {\n        detach(parent, child);\n    } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n        parent.object.remove(child.object);\n        removeInteractivity(findInitialRoot(child), child.object);\n    }\n    // Allow objects to bail out of unmount disposal with dispose={null}\n    const shouldDispose = child.props.dispose !== null && dispose !== false;\n    // Recursively remove instance children\n    for(let i = child.children.length - 1; i >= 0; i--){\n        const node = child.children[i];\n        removeChild(child, node, shouldDispose);\n    }\n    child.children.length = 0;\n    // Unlink instance object\n    delete child.object.__r3f;\n    // Dispose object whenever the reconciler feels like it.\n    // Never dispose of primitives because their state may be kept outside of React!\n    // In order for an object to be able to dispose it\n    //   - has a dispose method\n    //   - cannot be a <primitive object={...} />\n    //   - cannot be a THREE.Scene, because three has broken its own API\n    if (shouldDispose && child.type !== 'primitive' && child.object.type !== 'Scene') {\n        disposeOnIdle(child.object);\n    }\n    // Tree was updated, request a frame for top-level instance\n    if (dispose === undefined) invalidateInstance(child);\n}\nfunction setFiberRef(fiber, publicInstance) {\n    for (const _fiber of [\n        fiber,\n        fiber.alternate\n    ]){\n        if (_fiber !== null) {\n            if (typeof _fiber.ref === 'function') {\n                _fiber.refCleanup == null ? void 0 : _fiber.refCleanup();\n                const cleanup = _fiber.ref(publicInstance);\n                if (typeof cleanup === 'function') _fiber.refCleanup = cleanup;\n            } else if (_fiber.ref) {\n                _fiber.ref.current = publicInstance;\n            }\n        }\n    }\n}\nconst reconstructed = [];\nfunction swapInstances() {\n    // Detach instance\n    for (const [instance] of reconstructed){\n        const parent = instance.parent;\n        if (parent) {\n            if (instance.props.attach) {\n                detach(parent, instance);\n            } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n                parent.object.remove(instance.object);\n            }\n            for (const child of instance.children){\n                if (child.props.attach) {\n                    detach(instance, child);\n                } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n                    instance.object.remove(child.object);\n                }\n            }\n        }\n        // If the old instance is hidden, we need to unhide it.\n        // React assumes it can discard instances since they're pure for DOM.\n        // This isn't true for us since our lifetimes are impure and longliving.\n        // So, we manually check if an instance was hidden and unhide it.\n        if (instance.isHidden) unhideInstance(instance);\n        // Dispose of old object if able\n        if (instance.object.__r3f) delete instance.object.__r3f;\n        if (instance.type !== 'primitive') disposeOnIdle(instance.object);\n    }\n    // Update instance\n    for (const [instance, props, fiber] of reconstructed){\n        instance.props = props;\n        const parent = instance.parent;\n        if (parent) {\n            var _instance$props$objec, _instance$props$args;\n            // Get target from catalogue\n            const target = catalogue[toPascalCase(instance.type)];\n            // Create object\n            instance.object = (_instance$props$objec = instance.props.object) != null ? _instance$props$objec : new target(...(_instance$props$args = instance.props.args) != null ? _instance$props$args : []);\n            instance.object.__r3f = instance;\n            setFiberRef(fiber, instance.object);\n            // Set initial props\n            applyProps(instance.object, instance.props);\n            if (instance.props.attach) {\n                attach(parent, instance);\n            } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n                parent.object.add(instance.object);\n            }\n            for (const child of instance.children){\n                if (child.props.attach) {\n                    attach(instance, child);\n                } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n                    instance.object.add(child.object);\n                }\n            }\n            // Tree was updated, request a frame\n            invalidateInstance(instance);\n        }\n    }\n    reconstructed.length = 0;\n}\n// Don't handle text instances, make it no-op\nconst handleTextInstance = ()=>{};\nconst NO_CONTEXT = {};\nlet currentUpdatePriority = NoEventPriority;\n// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberFlags.js\nconst NoFlags = 0;\nconst Update = 4;\nconst reconciler = /* @__PURE__ */ createReconciler({\n    isPrimaryRenderer: false,\n    warnsIfNotActing: false,\n    supportsMutation: true,\n    supportsPersistence: false,\n    supportsHydration: false,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    appendChildToContainer (container, child) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !scene) return;\n        appendChild(scene, child);\n    },\n    removeChildFromContainer (container, child) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !scene) return;\n        removeChild(scene, child);\n    },\n    insertInContainerBefore (container, child, beforeChild) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !beforeChild || !scene) return;\n        insertBefore(scene, child, beforeChild);\n    },\n    getRootHostContext: ()=>NO_CONTEXT,\n    getChildHostContext: ()=>NO_CONTEXT,\n    commitUpdate (instance, type, oldProps, newProps, fiber) {\n        var _newProps$args, _oldProps$args, _newProps$args2;\n        validateInstance(type, newProps);\n        let reconstruct = false;\n        // Reconstruct primitives if object prop changes\n        if (instance.type === 'primitive' && oldProps.object !== newProps.object) reconstruct = true;\n        else if (((_newProps$args = newProps.args) == null ? void 0 : _newProps$args.length) !== ((_oldProps$args = oldProps.args) == null ? void 0 : _oldProps$args.length)) reconstruct = true;\n        else if ((_newProps$args2 = newProps.args) != null && _newProps$args2.some((value, index)=>{\n            var _oldProps$args2;\n            return value !== ((_oldProps$args2 = oldProps.args) == null ? void 0 : _oldProps$args2[index]);\n        })) reconstruct = true;\n        // Reconstruct when args or <primitive object={...} have changes\n        if (reconstruct) {\n            reconstructed.push([\n                instance,\n                {\n                    ...newProps\n                },\n                fiber\n            ]);\n        } else {\n            // Create a diff-set, flag if there are any changes\n            const changedProps = diffProps(instance, newProps);\n            if (Object.keys(changedProps).length) {\n                Object.assign(instance.props, changedProps);\n                applyProps(instance.object, changedProps);\n            }\n        }\n        // Flush reconstructed siblings when we hit the last updated child in a sequence\n        const isTailSibling = fiber.sibling === null || (fiber.flags & Update) === NoFlags;\n        if (isTailSibling) swapInstances();\n    },\n    finalizeInitialChildren: ()=>false,\n    commitMount () {},\n    getPublicInstance: (instance)=>instance == null ? void 0 : instance.object,\n    prepareForCommit: ()=>null,\n    preparePortalMount: (container)=>prepare(container.getState().scene, container, '', {}),\n    resetAfterCommit: ()=>{},\n    shouldSetTextContent: ()=>false,\n    clearContainer: ()=>false,\n    hideInstance,\n    unhideInstance,\n    createTextInstance: handleTextInstance,\n    hideTextInstance: handleTextInstance,\n    unhideTextInstance: handleTextInstance,\n    scheduleTimeout: typeof setTimeout === 'function' ? setTimeout : undefined,\n    cancelTimeout: typeof clearTimeout === 'function' ? clearTimeout : undefined,\n    noTimeout: -1,\n    getInstanceFromNode: ()=>null,\n    beforeActiveInstanceBlur () {},\n    afterActiveInstanceBlur () {},\n    detachDeletedInstance () {},\n    prepareScopeUpdate () {},\n    getInstanceFromScope: ()=>null,\n    shouldAttemptEagerTransition: ()=>false,\n    trackSchedulerEvent: ()=>{},\n    resolveEventType: ()=>null,\n    resolveEventTimeStamp: ()=>-1.1,\n    requestPostPaintCallback () {},\n    maySuspendCommit: ()=>false,\n    preloadInstance: ()=>true,\n    // true indicates already loaded\n    startSuspendingCommit () {},\n    suspendInstance () {},\n    waitForCommitToBeReady: ()=>null,\n    NotPendingTransition: null,\n    HostTransitionContext: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null),\n    setCurrentUpdatePriority (newPriority) {\n        currentUpdatePriority = newPriority;\n    },\n    getCurrentUpdatePriority () {\n        return currentUpdatePriority;\n    },\n    resolveUpdatePriority () {\n        var _window$event;\n        if (currentUpdatePriority !== NoEventPriority) return currentUpdatePriority;\n        switch( false && (0)){\n            case 'click':\n            case 'contextmenu':\n            case 'dblclick':\n            case 'pointercancel':\n            case 'pointerdown':\n            case 'pointerup':\n                return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n            case 'pointermove':\n            case 'pointerout':\n            case 'pointerover':\n            case 'pointerenter':\n            case 'pointerleave':\n            case 'wheel':\n                return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n            default:\n                return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n        }\n    },\n    resetFormInstance () {}\n});\nconst _roots = new Map();\nconst shallowLoose = {\n    objects: 'shallow',\n    strict: false\n};\nfunction computeInitialSize(canvas, size) {\n    if (!size && typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left\n        };\n    } else if (!size && typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        ...size\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = _roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === 'function' ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, // container\n    react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, // tag\n    null, // hydration callbacks\n    false, // isStrictMode\n    null, // concurrentUpdatesByDefaultOverride\n    '', // identifierPrefix\n    logRecoverableError, // onUncaughtError\n    logRecoverableError, // onCaughtError\n    logRecoverableError, // onRecoverableError\n    null // transitionCallbacks\n    );\n    // Map it\n    if (!prevRoot) _roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let lastCamera;\n    let configured = false;\n    let pending = null;\n    return {\n        async configure (props = {}) {\n            let resolve;\n            pending = new Promise((_resolve)=>resolve = _resolve);\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = 'always', dpr = [\n                1,\n                2\n            ], performance, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) {\n                const defaultProps = {\n                    canvas: canvas,\n                    powerPreference: 'high-performance',\n                    antialias: true,\n                    alpha: true\n                };\n                const customRenderer = typeof glConfig === 'function' ? await glConfig(defaultProps) : glConfig;\n                if (isRenderer(customRenderer)) {\n                    gl = customRenderer;\n                } else {\n                    gl = new three__WEBPACK_IMPORTED_MODULE_6__.WebGLRenderer({\n                        ...defaultProps,\n                        ...glConfig\n                    });\n                }\n                state.set({\n                    gl\n                });\n            }\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions == null ? void 0 : cameraOptions.isCamera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_6__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_6__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) {\n                        applyProps(camera, cameraOptions);\n                        // Preserve user-defined frustum if possible\n                        // https://github.com/pmndrs/react-three-fiber/issues/3160\n                        if (!camera.manual) {\n                            if ('aspect' in cameraOptions || 'left' in cameraOptions || 'right' in cameraOptions || 'bottom' in cameraOptions || 'top' in cameraOptions) {\n                                camera.manual = true;\n                                camera.updateProjectionMatrix();\n                            }\n                        }\n                    }\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions != null && sceneOptions.isScene) {\n                    scene = sceneOptions;\n                    prepare(scene, store, '', {});\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_6__.Scene();\n                    prepare(scene, store, '', {});\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene\n                });\n            }\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance\n                    }\n                }));\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === 'never') return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener('sessionstart', handleSessionChange);\n                        gl.xr.addEventListener('sessionend', handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener('sessionstart', handleSessionChange);\n                        gl.xr.removeEventListener('sessionend', handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_6__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_6__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_6__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            three__WEBPACK_IMPORTED_MODULE_6__.ColorManagement.enabled = !legacy;\n            // Set color space and tonemapping preferences\n            if (!configured) {\n                gl.outputColorSpace = linear ? three__WEBPACK_IMPORTED_MODULE_6__.LinearSRGBColorSpace : three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n                gl.toneMapping = flat ? three__WEBPACK_IMPORTED_MODULE_6__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_6__.ACESFilmicToneMapping;\n            }\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            resolve();\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured && !pending) this.configure();\n            pending.then(()=>{\n                reconciler.updateContainer(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Provider, {\n                    store: store,\n                    children: children,\n                    onCreated: onCreated,\n                    rootElement: canvas\n                }), fiber, null, ()=>undefined);\n            });\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect({\n        \"Provider.useIsomorphicLayoutEffect\": ()=>{\n            const state = store.getState();\n            // Flag the canvas active, rendering will now begin\n            state.set({\n                \"Provider.useIsomorphicLayoutEffect\": (state)=>({\n                        internal: {\n                            ...state.internal,\n                            active: true\n                        }\n                    })\n            }[\"Provider.useIsomorphicLayoutEffect\"]);\n            // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n            if (onCreated) onCreated(state);\n            // Connect events to the targets parent, this is done to ensure events are registered on\n            // a shared target, and not on the canvas itself\n            if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"Provider.useIsomorphicLayoutEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n        value: store,\n        children: children\n    });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = _roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state.scene);\n                        _roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Portal, {\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"Portal.useState\": ()=>new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster()\n    }[\"Portal.useState\"]);\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"Portal.useState\": ()=>new three__WEBPACK_IMPORTED_MODULE_6__.Vector2()\n    }[\"Portal.useState\"]);\n    const inject = useMutableCallback({\n        \"Portal.useMutableCallback[inject]\": (rootState, injectState)=>{\n            let viewport = undefined;\n            if (injectState.camera && size) {\n                const camera = injectState.camera;\n                // Calculate the override viewport, if present\n                viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(), size);\n                // Update the portal camera, if it differs from the previous layer\n                if (camera !== rootState.camera) updateCamera(camera, size);\n            }\n            return {\n                // The intersect consists of the previous root state\n                ...rootState,\n                ...injectState,\n                // Portals have their own scene, which forms the root, a raycaster and a pointer\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                // Their previous root is the layer before it\n                previousRoot,\n                // Events, size and viewport can be overridden by the inject layer\n                events: {\n                    ...rootState.events,\n                    ...injectState.events,\n                    ...events\n                },\n                size: {\n                    ...rootState.size,\n                    ...size\n                },\n                viewport: {\n                    ...rootState.viewport,\n                    ...viewport\n                },\n                // Layers are allowed to override events\n                setEvents: ({\n                    \"Portal.useMutableCallback[inject]\": (events)=>injectState.set({\n                            \"Portal.useMutableCallback[inject]\": (state)=>({\n                                    ...state,\n                                    events: {\n                                        ...state.events,\n                                        ...events\n                                    }\n                                })\n                        }[\"Portal.useMutableCallback[inject]\"])\n                })[\"Portal.useMutableCallback[inject]\"]\n            };\n        }\n    }[\"Portal.useMutableCallback[inject]\"]);\n    const usePortalStore = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"Portal.useMemo[usePortalStore]\": ()=>{\n            // Create a mirrored store, based on the previous root with a few overrides ...\n            const store = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)({\n                \"Portal.useMemo[usePortalStore].store\": (set, get)=>({\n                        ...rest,\n                        set,\n                        get\n                    })\n            }[\"Portal.useMemo[usePortalStore].store\"]);\n            // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n            const onMutate = {\n                \"Portal.useMemo[usePortalStore].onMutate\": (prev)=>store.setState({\n                        \"Portal.useMemo[usePortalStore].onMutate\": (state)=>inject.current(prev, state)\n                    }[\"Portal.useMemo[usePortalStore].onMutate\"])\n            }[\"Portal.useMemo[usePortalStore].onMutate\"];\n            onMutate(previousRoot.getState());\n            previousRoot.subscribe(onMutate);\n            return store;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"Portal.useMemo[usePortalStore]\"], [\n        previousRoot,\n        container\n    ]);\n    return(/*#__PURE__*/ // @ts-ignore, reconciler types are not maintained\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n        children: reconciler.createPortal(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n            value: usePortalStore,\n            children: children\n        }), usePortalStore, null)\n    }));\n}\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nconst globalEffects = new Set();\nconst globalAfterEffects = new Set();\nconst globalTailEffects = new Set();\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case 'before':\n            return run(globalEffects, timestamp);\n        case 'after':\n            return run(globalAfterEffects, timestamp);\n        case 'tail':\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction update(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === 'never' && typeof timestamp === 'number') {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(let i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nlet running = false;\nlet useFrameInProgress = false;\nlet repeat;\nlet frame;\nlet state;\nfunction loop(timestamp) {\n    frame = requestAnimationFrame(loop);\n    running = true;\n    repeat = 0;\n    // Run effects\n    flushGlobalEffects('before', timestamp);\n    // Render all roots\n    useFrameInProgress = true;\n    for (const root of _roots.values()){\n        var _state$gl$xr;\n        state = root.store.getState();\n        // If the frameloop is invalidated, do not run another frame\n        if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n            repeat += update(timestamp, state);\n        }\n    }\n    useFrameInProgress = false;\n    // Run after-effects\n    flushGlobalEffects('after', timestamp);\n    // Stop the loop if nothing invalidates it\n    if (repeat === 0) {\n        // Tail call effects, they are called when rendering stops\n        flushGlobalEffects('tail', timestamp);\n        // Flag end of operation\n        running = false;\n        return cancelAnimationFrame(frame);\n    }\n}\n/**\r\n * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\r\n */ function invalidate(state, frames = 1) {\n    var _state$gl$xr2;\n    if (!state) return _roots.forEach((root)=>invalidate(root.store.getState(), frames));\n    if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n    if (frames > 1) {\n        // legacy support for people using frames parameters\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n    } else {\n        if (useFrameInProgress) {\n            //called from within a useFrame, it means the user wants an additional frame\n            state.internal.frames = 2;\n        } else {\n            //the user need a new frame, no need to increment further than 1\n            state.internal.frames = 1;\n        }\n    }\n    // If the render-loop isn't active, start it\n    if (!running) {\n        running = true;\n        requestAnimationFrame(loop);\n    }\n}\n/**\r\n * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\r\n */ function advance(timestamp, runGlobalEffects = true, state, frame) {\n    if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n    if (!state) for (const root of _roots.values())update(timestamp, root.store.getState());\n    else update(timestamp, state, frame);\n    if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n}\nconst DOM_EVENTS = {\n    onClick: [\n        'click',\n        false\n    ],\n    onContextMenu: [\n        'contextmenu',\n        false\n    ],\n    onDoubleClick: [\n        'dblclick',\n        false\n    ],\n    onWheel: [\n        'wheel',\n        true\n    ],\n    onPointerDown: [\n        'pointerdown',\n        true\n    ],\n    onPointerUp: [\n        'pointerup',\n        true\n    ],\n    onPointerLeave: [\n        'pointerleave',\n        true\n    ],\n    onPointerMove: [\n        'pointermove',\n        true\n    ],\n    onPointerCancel: [\n        'pointercancel',\n        true\n    ],\n    onLostPointerCapture: [\n        'lostpointercapture',\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = createEvents(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            if (events.handlers) {\n                for(const name in events.handlers){\n                    const event = events.handlers[name];\n                    const [eventName, passive] = DOM_EVENTS[name];\n                    target.addEventListener(eventName, event, {\n                        passive\n                    });\n                }\n            }\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                if (events.handlers) {\n                    for(const name in events.handlers){\n                        const event = events.handlers[name];\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                }\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLTBkYzg0YjgxLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNtRztBQUN2RTtBQUNqQjtBQUNtQztBQUNyQjtBQUNOO0FBQ21CO0FBRXJFLElBQUlrQixhQUFhLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQzFDQyxXQUFXO0FBQ2I7QUFFQTs7Q0FFQyxHQUNELFNBQVNDLGdCQUFnQkMsUUFBUTtJQUMvQixJQUFJQyxPQUFPRCxTQUFTQyxJQUFJO0lBQ3hCLE1BQU9BLEtBQUtDLFFBQVEsR0FBR0MsWUFBWSxDQUFFRixPQUFPQSxLQUFLQyxRQUFRLEdBQUdDLFlBQVk7SUFDeEUsT0FBT0Y7QUFDVDtBQUNBOztDQUVDLEdBQ0QsTUFBTUcsTUFBTTFCLHNDQUFTO0FBQ3JCLE1BQU0yQix1QkFBdUJDLENBQUFBLE1BQU9BLE9BQU9BLElBQUlELG9CQUFvQjtBQUNuRSxNQUFNRSxRQUFRQyxDQUFBQSxNQUFPQSxPQUFPQSxJQUFJQyxjQUFjLENBQUM7QUFDL0MsTUFBTUMsd0JBQXdCQyxDQUFBQSxRQUFTQSxTQUFTLFFBQVMsUUFBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsWUFBWUEsTUFBTUMsT0FBTztBQUVoSTs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1DLDRCQUEyQyxhQUFGLEdBQUcsRUFBQ0Msa0JBQWtCQyxvQkFBc0IsTUFBNkIsSUFBSyxFQUFrTSxDQUFDLE1BQU9yQyxrREFBcUIsR0FBR0EsNENBQWU7QUFDOVcsU0FBUzZDLG1CQUFtQkMsRUFBRTtJQUM1QixNQUFNQyxNQUFNL0MseUNBQVksQ0FBQzhDO0lBQ3pCWDt3REFBMEIsSUFBTSxLQUFNWSxDQUFBQSxJQUFJRSxPQUFPLEdBQUdILEVBQUM7dURBQUk7UUFBQ0E7S0FBRztJQUM3RCxPQUFPQztBQUNUO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRztJQUNQLE1BQU1DLFFBQVFyQyxrREFBUUE7SUFDdEIsTUFBTXNDLGdCQUFnQnJDLDBEQUFnQkE7SUFDdEMsT0FBT2YsMENBQWE7NkJBQUM7cUNBQU0sQ0FBQyxFQUMxQnNELFFBQVEsRUFDVDtvQkFDQyxNQUFNQyxTQUFTLENBQUMsQ0FBQ3ZDLHVEQUFhQSxDQUFDbUMsT0FBTzs2Q0FBTUssQ0FBQUEsT0FBUUEsS0FBS0MsSUFBSSxLQUFLekQsNkNBQWdCOztvQkFDbEYsTUFBTTJELE9BQU9KLFNBQVN2RCw2Q0FBZ0IsR0FBR0EsMkNBQWM7b0JBQ3ZELE9BQU8sV0FBVyxHQUFFWSxzREFBR0EsQ0FBQytDLE1BQU07d0JBQzVCTCxVQUFVLFdBQVcsR0FBRTFDLHNEQUFHQSxDQUFDd0MsZUFBZTs0QkFDeENFLFVBQVVBO3dCQUNaO29CQUNGO2dCQUNGOzs0QkFBRztRQUFDSDtRQUFPQztLQUFjO0FBQzNCO0FBQ0EsU0FBU1EsTUFBTSxFQUNiQyxHQUFHLEVBQ0o7SUFDQzFCOzJDQUEwQjtZQUN4QjBCLElBQUksSUFBSUM7bURBQVEsSUFBTTs7WUFDdEI7bURBQU8sSUFBTUQsSUFBSTs7UUFDbkI7MENBQUc7UUFBQ0E7S0FBSTtJQUNSLE9BQU87QUFDVDtBQUVBLHVGQUF1RjtBQUN2RixNQUFNRSxnQkFBK0IsYUFBRixHQUFHQyxDQUFBQSxDQUFBQSxpQkFBbUJBLENBQUFBLGlCQUFpQixNQUFNRCxzQkFBc0IvRCw0Q0FBZTtRQUNuSCxZQUFZLEdBQUdrRSxJQUFJLENBQUU7WUFDbkIsS0FBSyxJQUFJQTtZQUNULElBQUksQ0FBQ0MsS0FBSyxHQUFHO2dCQUNYQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBQyxrQkFBa0JDLEdBQUcsRUFBRTtZQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsR0FBRyxDQUFDUztRQUNqQjtRQUNBRSxTQUFTO1lBQ1AsT0FBTyxJQUFJLENBQUNMLEtBQUssQ0FBQ0MsS0FBSyxHQUFHLE9BQU8sSUFBSSxDQUFDRyxLQUFLLENBQUNqQixRQUFRO1FBQ3REO0lBQ0YsR0FBR1UsZUFBZVMsd0JBQXdCLEdBQUcsSUFBTztZQUNsREwsT0FBTztRQUNULElBQUlKLGNBQWEsQ0FBQztBQUNsQixTQUFTVSxhQUFhQyxHQUFHO0lBQ3ZCLElBQUlDO0lBQ0osdUVBQXVFO0lBQ3ZFLHFFQUFxRTtJQUNyRSxNQUFNQyxTQUFTLE1BQTZCLEdBQUcsQ0FBcUYsR0FBRztJQUN2SSxPQUFPRSxNQUFNQyxPQUFPLENBQUNMLE9BQU9NLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDUixHQUFHLENBQUMsRUFBRSxFQUFFRSxTQUFTRixHQUFHLENBQUMsRUFBRSxJQUFJQTtBQUMzRTtBQUVBOztDQUVDLEdBQ0QsU0FBU1MsYUFBYXRELEdBQUc7SUFDdkIsSUFBSXVEO0lBQ0osT0FBTyxDQUFDQSxPQUFPdkQsSUFBSXdELEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUQsS0FBSzlELElBQUksQ0FBQ0MsUUFBUTtBQUNqRTtBQUNBLG9DQUFvQztBQUNwQyxNQUFNK0QsS0FBSztJQUNUekQsS0FBSzBELENBQUFBLElBQUtBLE1BQU10RSxPQUFPc0UsTUFBTSxDQUFDRCxHQUFHRSxHQUFHLENBQUNELE1BQU0sT0FBT0EsTUFBTTtJQUN4REUsS0FBS0YsQ0FBQUEsSUFBSyxPQUFPQSxNQUFNO0lBQ3ZCRyxLQUFLSCxDQUFBQSxJQUFLLE9BQU9BLE1BQU07SUFDdkJJLEtBQUtKLENBQUFBLElBQUssT0FBT0EsTUFBTTtJQUN2QkssS0FBS0wsQ0FBQUEsSUFBSyxPQUFPQSxNQUFNO0lBQ3ZCTSxLQUFLTixDQUFBQSxJQUFLQSxNQUFNLEtBQUs7SUFDckJPLEtBQUtQLENBQUFBLElBQUtBLE1BQU07SUFDaEJDLEtBQUtELENBQUFBLElBQUtULE1BQU1DLE9BQU8sQ0FBQ1E7SUFDeEJRLEtBQUlSLENBQUMsRUFBRVMsQ0FBQyxFQUFFLEVBQ1JDLFNBQVMsU0FBUyxFQUNsQkMsVUFBVSxXQUFXLEVBQ3JCNUMsU0FBUyxJQUFJLEVBQ2QsR0FBRyxDQUFDLENBQUM7UUFDSix3REFBd0Q7UUFDeEQsSUFBSSxPQUFPaUMsTUFBTSxPQUFPUyxLQUFLLENBQUMsQ0FBQ1QsTUFBTSxDQUFDLENBQUNTLEdBQUcsT0FBTztRQUNqRCxtQ0FBbUM7UUFDbkMsSUFBSVYsR0FBR0ksR0FBRyxDQUFDSCxNQUFNRCxHQUFHSyxHQUFHLENBQUNKLE1BQU1ELEdBQUdNLEdBQUcsQ0FBQ0wsSUFBSSxPQUFPQSxNQUFNUztRQUN0RCxNQUFNRyxRQUFRYixHQUFHekQsR0FBRyxDQUFDMEQ7UUFDckIsSUFBSVksU0FBU0QsWUFBWSxhQUFhLE9BQU9YLE1BQU1TO1FBQ25ELE1BQU1JLFFBQVFkLEdBQUdFLEdBQUcsQ0FBQ0Q7UUFDckIsSUFBSWEsU0FBU0gsV0FBVyxhQUFhLE9BQU9WLE1BQU1TO1FBQ2xELGdFQUFnRTtRQUNoRSxJQUFJLENBQUNJLFNBQVNELEtBQUksS0FBTVosTUFBTVMsR0FBRyxPQUFPO1FBQ3hDLCtCQUErQjtRQUMvQixJQUFJSztRQUNKLG1DQUFtQztRQUNuQyxJQUFLQSxLQUFLZCxFQUFHLElBQUksQ0FBRWMsQ0FBQUEsS0FBS0wsQ0FBQUEsR0FBSSxPQUFPO1FBQ25DLHFDQUFxQztRQUNyQyxJQUFJRyxTQUFTRixXQUFXLGFBQWFDLFlBQVksV0FBVztZQUMxRCxJQUFLRyxLQUFLL0MsU0FBUzBDLElBQUlULEVBQUcsSUFBSSxDQUFDRCxHQUFHUyxHQUFHLENBQUNSLENBQUMsQ0FBQ2MsRUFBRSxFQUFFTCxDQUFDLENBQUNLLEVBQUUsRUFBRTtnQkFDaEQvQztnQkFDQTRDLFNBQVM7WUFDWCxJQUFJLE9BQU87UUFDYixPQUFPO1lBQ0wsSUFBS0csS0FBSy9DLFNBQVMwQyxJQUFJVCxFQUFHLElBQUlBLENBQUMsQ0FBQ2MsRUFBRSxLQUFLTCxDQUFDLENBQUNLLEVBQUUsRUFBRSxPQUFPO1FBQ3REO1FBQ0Esb0JBQW9CO1FBQ3BCLElBQUlmLEdBQUdPLEdBQUcsQ0FBQ1EsSUFBSTtZQUNiLGtEQUFrRDtZQUNsRCxJQUFJRCxTQUFTYixFQUFFZSxNQUFNLEtBQUssS0FBS04sRUFBRU0sTUFBTSxLQUFLLEdBQUcsT0FBTztZQUN0RCxtREFBbUQ7WUFDbkQsSUFBSUgsU0FBU2xGLE9BQU9zRixJQUFJLENBQUNoQixHQUFHZSxNQUFNLEtBQUssS0FBS3JGLE9BQU9zRixJQUFJLENBQUNQLEdBQUdNLE1BQU0sS0FBSyxHQUFHLE9BQU87WUFDaEYsZ0NBQWdDO1lBQ2hDLElBQUlmLE1BQU1TLEdBQUcsT0FBTztRQUN0QjtRQUNBLE9BQU87SUFDVDtBQUNGO0FBRUEscURBQXFEO0FBQ3JELFNBQVNRLFdBQVdDLE1BQU07SUFDeEIsTUFBTUMsT0FBTztRQUNYQyxPQUFPLENBQUM7UUFDUkMsV0FBVyxDQUFDO0lBQ2Q7SUFDQSxJQUFJSCxRQUFRO1FBQ1ZBLE9BQU9JLFFBQVEsQ0FBQ2hGLENBQUFBO1lBQ2QsSUFBSUEsSUFBSWlGLElBQUksRUFBRUosS0FBS0MsS0FBSyxDQUFDOUUsSUFBSWlGLElBQUksQ0FBQyxHQUFHakY7WUFDckMsSUFBSUEsSUFBSWtGLFFBQVEsSUFBSSxDQUFDTCxLQUFLRSxTQUFTLENBQUMvRSxJQUFJa0YsUUFBUSxDQUFDRCxJQUFJLENBQUMsRUFBRUosS0FBS0UsU0FBUyxDQUFDL0UsSUFBSWtGLFFBQVEsQ0FBQ0QsSUFBSSxDQUFDLEdBQUdqRixJQUFJa0YsUUFBUTtRQUMxRztJQUNGO0lBQ0EsT0FBT0w7QUFDVDtBQUNBLDRDQUE0QztBQUM1QyxTQUFTTSxRQUFRbkYsR0FBRztJQUNsQixJQUFJQSxJQUFJMkIsSUFBSSxLQUFLLFNBQVMzQixJQUFJbUYsT0FBTyxJQUFJLE9BQU8sS0FBSyxJQUFJbkYsSUFBSW1GLE9BQU87SUFDcEUsSUFBSyxNQUFNQyxLQUFLcEYsSUFBSztRQUNuQixNQUFNcUYsT0FBT3JGLEdBQUcsQ0FBQ29GLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLMUQsSUFBSSxNQUFNLFNBQVMwRCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLRixPQUFPLElBQUksT0FBTyxLQUFLLElBQUlFLEtBQUtGLE9BQU87SUFDM0g7QUFDRjtBQUNBLE1BQU1HLHVCQUF1QjtJQUFDO0lBQVk7SUFBTztDQUFNO0FBRXZELGtEQUFrRDtBQUNsRCxTQUFTQyxpQkFBaUJDLEtBQUs7SUFDN0IsTUFBTS9DLFFBQVEsQ0FBQztJQUNmLElBQUssTUFBTWdELE9BQU9ELE1BQU87UUFDdkIsSUFBSSxDQUFDRixxQkFBcUJJLFFBQVEsQ0FBQ0QsTUFBTWhELEtBQUssQ0FBQ2dELElBQUksR0FBR0QsS0FBSyxDQUFDQyxJQUFJO0lBQ2xFO0lBQ0EsT0FBT2hEO0FBQ1Q7QUFFQSxpRUFBaUU7QUFDakUsU0FBU2tELFFBQVE1QyxNQUFNLEVBQUV0RCxJQUFJLEVBQUVrQyxJQUFJLEVBQUVjLEtBQUs7SUFDeEMsTUFBTW1DLFNBQVM3QjtJQUVmLDZCQUE2QjtJQUM3QixJQUFJdkQsV0FBV29GLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9wQixLQUFLO0lBQ3JELElBQUksQ0FBQ2hFLFVBQVU7UUFDYkEsV0FBVztZQUNUQztZQUNBa0M7WUFDQWlFLFFBQVE7WUFDUnBFLFVBQVUsRUFBRTtZQUNaaUIsT0FBTzhDLGlCQUFpQjlDO1lBQ3hCbUM7WUFDQWlCLFlBQVk7WUFDWkMsVUFBVSxDQUFDO1lBQ1hDLFVBQVU7UUFDWjtRQUNBLElBQUluQixRQUFRQSxPQUFPcEIsS0FBSyxHQUFHaEU7SUFDN0I7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU3dHLFFBQVF2RyxJQUFJLEVBQUVnRyxHQUFHO0lBQ3hCLElBQUlRO0lBQ0osSUFBSWxELFNBQVN0RCxJQUFJLENBQUNnRyxJQUFJO0lBQ3RCLElBQUksQ0FBQ0EsSUFBSUMsUUFBUSxDQUFDLE1BQU0sT0FBTztRQUM3QmpHO1FBQ0FnRztRQUNBMUM7SUFDRjtJQUVBLHlCQUF5QjtJQUN6QixNQUFNbUQsUUFBUVQsSUFBSVUsS0FBSyxDQUFDO0lBQ3hCcEQsU0FBU21ELE1BQU1FLE1BQU0sQ0FBQyxDQUFDQyxLQUFLWixNQUFRWSxHQUFHLENBQUNaLElBQUksRUFBRWhHO0lBQzlDZ0csTUFBTVMsTUFBTUksR0FBRztJQUVmLHdCQUF3QjtJQUN4QixJQUFJLENBQUUsRUFBQ0wsVUFBVWxELE1BQUssS0FBTSxRQUFRa0QsUUFBUWxFLEdBQUcsR0FBR3RDLE9BQU95RyxNQUFNRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS1osTUFBUVksR0FBRyxDQUFDWixJQUFJLEVBQUVoRztJQUM5RixPQUFPO1FBQ0xBO1FBQ0FnRztRQUNBMUM7SUFDRjtBQUNGO0FBRUEscURBQXFEO0FBQ3JELE1BQU13RCxjQUFjO0FBQ3BCLFNBQVNDLE9BQU9aLE1BQU0sRUFBRWEsS0FBSztJQUMzQixJQUFJaEQsR0FBR0ksR0FBRyxDQUFDNEMsTUFBTWhFLEtBQUssQ0FBQytELE1BQU0sR0FBRztRQUM5QixpREFBaUQ7UUFDakQsSUFBSUQsWUFBWUcsSUFBSSxDQUFDRCxNQUFNaEUsS0FBSyxDQUFDK0QsTUFBTSxHQUFHO1lBQ3hDLE1BQU1HLFFBQVFGLE1BQU1oRSxLQUFLLENBQUMrRCxNQUFNLENBQUNJLE9BQU8sQ0FBQ0wsYUFBYTtZQUN0RCxNQUFNLEVBQ0o5RyxJQUFJLEVBQ0pnRyxHQUFHLEVBQ0osR0FBR08sUUFBUUosT0FBT2hCLE1BQU0sRUFBRStCO1lBQzNCLElBQUksQ0FBQzFELE1BQU1DLE9BQU8sQ0FBQ3pELElBQUksQ0FBQ2dHLElBQUksR0FBR2hHLElBQUksQ0FBQ2dHLElBQUksR0FBRyxFQUFFO1FBQy9DO1FBQ0EsTUFBTSxFQUNKaEcsSUFBSSxFQUNKZ0csR0FBRyxFQUNKLEdBQUdPLFFBQVFKLE9BQU9oQixNQUFNLEVBQUU2QixNQUFNaEUsS0FBSyxDQUFDK0QsTUFBTTtRQUM3Q0MsTUFBTUksY0FBYyxHQUFHcEgsSUFBSSxDQUFDZ0csSUFBSTtRQUNoQ2hHLElBQUksQ0FBQ2dHLElBQUksR0FBR2dCLE1BQU03QixNQUFNO0lBQzFCLE9BQU8sSUFBSW5CLEdBQUdHLEdBQUcsQ0FBQzZDLE1BQU1oRSxLQUFLLENBQUMrRCxNQUFNLEdBQUc7UUFDckNDLE1BQU1JLGNBQWMsR0FBR0osTUFBTWhFLEtBQUssQ0FBQytELE1BQU0sQ0FBQ1osT0FBT2hCLE1BQU0sRUFBRTZCLE1BQU03QixNQUFNO0lBQ3ZFO0FBQ0Y7QUFDQSxTQUFTa0MsT0FBT2xCLE1BQU0sRUFBRWEsS0FBSztJQUMzQixJQUFJaEQsR0FBR0ksR0FBRyxDQUFDNEMsTUFBTWhFLEtBQUssQ0FBQytELE1BQU0sR0FBRztRQUM5QixNQUFNLEVBQ0ovRyxJQUFJLEVBQ0pnRyxHQUFHLEVBQ0osR0FBR08sUUFBUUosT0FBT2hCLE1BQU0sRUFBRTZCLE1BQU1oRSxLQUFLLENBQUMrRCxNQUFNO1FBQzdDLE1BQU1PLFdBQVdOLE1BQU1JLGNBQWM7UUFDckMsd0ZBQXdGO1FBQ3hGLElBQUlFLGFBQWFDLFdBQVcsT0FBT3ZILElBQUksQ0FBQ2dHLElBQUk7YUFFdkNoRyxJQUFJLENBQUNnRyxJQUFJLEdBQUdzQjtJQUNuQixPQUFPO1FBQ0xOLE1BQU1JLGNBQWMsSUFBSSxPQUFPLEtBQUssSUFBSUosTUFBTUksY0FBYyxDQUFDakIsT0FBT2hCLE1BQU0sRUFBRTZCLE1BQU03QixNQUFNO0lBQzFGO0lBQ0EsT0FBTzZCLE1BQU1JLGNBQWM7QUFDN0I7QUFDQSxNQUFNSSxpQkFBaUI7T0FBSTNCO0lBQzNCLGlCQUFpQjtJQUNqQjtJQUFRO0lBQVc7SUFBVTtJQUFVO0lBQ3ZDLGlCQUFpQjtJQUNqQjtDQUFVO0FBQ1YsTUFBTTRCLHNCQUFzQixJQUFJQztBQUNoQyxTQUFTQyxxQkFBcUIzSCxJQUFJO0lBQ2hDLElBQUk0SCxPQUFPSCxvQkFBb0JJLEdBQUcsQ0FBQzdILEtBQUssV0FBVztJQUNuRCxJQUFJO1FBQ0YsSUFBSSxDQUFDNEgsTUFBTTtZQUNUQSxPQUFPLElBQUk1SCxLQUFLLFdBQVc7WUFDM0J5SCxvQkFBb0JuRixHQUFHLENBQUN0QyxLQUFLLFdBQVcsRUFBRTRIO1FBQzVDO0lBQ0YsRUFBRSxPQUFPRSxHQUFHO0lBQ1YsTUFBTTtJQUNSO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLHdFQUF3RTtBQUN4RSxTQUFTRyxVQUFVaEksUUFBUSxFQUFFaUksUUFBUTtJQUNuQyxNQUFNQyxlQUFlLENBQUM7SUFFdEIscUJBQXFCO0lBQ3JCLElBQUssTUFBTXJDLFFBQVFvQyxTQUFVO1FBQzNCLHFCQUFxQjtRQUNyQixJQUFJUixlQUFldkIsUUFBUSxDQUFDTCxPQUFPO1FBQ25DLHNCQUFzQjtRQUN0QixJQUFJNUIsR0FBR1MsR0FBRyxDQUFDdUQsUUFBUSxDQUFDcEMsS0FBSyxFQUFFN0YsU0FBU2lELEtBQUssQ0FBQzRDLEtBQUssR0FBRztRQUVsRCwwQkFBMEI7UUFDMUJxQyxZQUFZLENBQUNyQyxLQUFLLEdBQUdvQyxRQUFRLENBQUNwQyxLQUFLO1FBRW5DLHNCQUFzQjtRQUN0QixJQUFLLE1BQU1zQyxTQUFTRixTQUFVO1lBQzVCLElBQUlFLE1BQU1DLFVBQVUsQ0FBQyxHQUFHdkMsS0FBSyxDQUFDLENBQUMsR0FBR3FDLFlBQVksQ0FBQ0MsTUFBTSxHQUFHRixRQUFRLENBQUNFLE1BQU07UUFDekU7SUFDRjtJQUVBLDhCQUE4QjtJQUM5QixJQUFLLE1BQU10QyxRQUFRN0YsU0FBU2lELEtBQUssQ0FBRTtRQUNqQyxJQUFJd0UsZUFBZXZCLFFBQVEsQ0FBQ0wsU0FBU29DLFNBQVN4SCxjQUFjLENBQUNvRixPQUFPO1FBQ3BFLE1BQU0sRUFDSjVGLElBQUksRUFDSmdHLEdBQUcsRUFDSixHQUFHTyxRQUFReEcsU0FBU29GLE1BQU0sRUFBRVM7UUFFN0Isa0RBQWtEO1FBQ2xELDBFQUEwRTtRQUMxRSwrRUFBK0U7UUFDL0Usa0RBQWtEO1FBQ2xELDREQUE0RDtRQUM1RCxJQUFJNUYsS0FBSyxXQUFXLElBQUlBLEtBQUssV0FBVyxDQUFDZ0YsTUFBTSxLQUFLLEdBQUc7WUFDckQsMEVBQTBFO1lBQzFFLE1BQU00QyxPQUFPRCxxQkFBcUIzSDtZQUNsQyxJQUFJLENBQUNnRSxHQUFHTyxHQUFHLENBQUNxRCxPQUFPSyxZQUFZLENBQUNqQyxJQUFJLEdBQUc0QixJQUFJLENBQUM1QixJQUFJO1FBQ2xELE9BQU87WUFDTCx1REFBdUQ7WUFDdkRpQyxZQUFZLENBQUNqQyxJQUFJLEdBQUc7UUFDdEI7SUFDRjtJQUNBLE9BQU9pQztBQUNUO0FBRUEsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxNQUFNRyxZQUFZO0lBQUM7SUFBTztJQUFlO0lBQWlCO0lBQW9CO0NBQVM7QUFDdkYsTUFBTUMsY0FBYztBQUNwQix5REFBeUQ7QUFDekQsU0FBU0MsV0FBV25ELE1BQU0sRUFBRW5DLEtBQUs7SUFDL0IsSUFBSXVGO0lBQ0osTUFBTXhJLFdBQVdvRixPQUFPcEIsS0FBSztJQUM3QixNQUFNeUUsWUFBWXpJLFlBQVlELGdCQUFnQkMsVUFBVUUsUUFBUTtJQUNoRSxNQUFNd0ksZUFBZTFJLFlBQVksT0FBTyxLQUFLLElBQUlBLFNBQVNxRyxVQUFVO0lBQ3BFLElBQUssTUFBTVIsUUFBUTVDLE1BQU87UUFDeEIsSUFBSXRDLFFBQVFzQyxLQUFLLENBQUM0QyxLQUFLO1FBRXZCLDZCQUE2QjtRQUM3QixJQUFJNEIsZUFBZXZCLFFBQVEsQ0FBQ0wsT0FBTztRQUVuQyxpRUFBaUU7UUFDakUsSUFBSTdGLFlBQVlzSSxZQUFZcEIsSUFBSSxDQUFDckIsT0FBTztZQUN0QyxJQUFJLE9BQU9sRixVQUFVLFlBQVlYLFNBQVNzRyxRQUFRLENBQUNULEtBQUssR0FBR2xGO2lCQUFXLE9BQU9YLFNBQVNzRyxRQUFRLENBQUNULEtBQUs7WUFDcEc3RixTQUFTcUcsVUFBVSxHQUFHekcsT0FBT3NGLElBQUksQ0FBQ2xGLFNBQVNzRyxRQUFRLEVBQUVyQixNQUFNO1lBQzNEO1FBQ0Y7UUFFQSxpQ0FBaUM7UUFDakMseURBQXlEO1FBQ3pELElBQUl0RSxVQUFVNkcsV0FBVztRQUN6QixJQUFJLEVBQ0Z2SCxJQUFJLEVBQ0pnRyxHQUFHLEVBQ0gxQyxNQUFNLEVBQ1AsR0FBR2lELFFBQVFwQixRQUFRUztRQUVwQiw4Q0FBOEM7UUFDOUMsSUFBSXRDLGtCQUFrQjlFLHlDQUFZLElBQUlrQyxpQkFBaUJsQyx5Q0FBWSxFQUFFO1lBQ25FOEUsT0FBT3FGLElBQUksR0FBR2pJLE1BQU1pSSxJQUFJO1FBQzFCLE9BRUssSUFBSXJGLGtCQUFrQjlFLHdDQUFXLElBQUlpQyxzQkFBc0JDLFFBQVE7WUFDdEU0QyxPQUFPaEIsR0FBRyxDQUFDNUI7UUFDYixPQUVLLElBQUk0QyxXQUFXLFFBQVEsT0FBT0EsV0FBVyxZQUFZLE9BQU9BLE9BQU9oQixHQUFHLEtBQUssY0FBYyxPQUFPZ0IsT0FBT3VGLElBQUksS0FBSyxjQUFjbkksU0FBUyxRQUFRQSxNQUFNLFdBQVcsSUFBSTRDLE9BQU8sV0FBVyxLQUFLNUMsTUFBTSxXQUFXLEVBQUU7WUFDak40QyxPQUFPdUYsSUFBSSxDQUFDbkk7UUFDZCxPQUVLLElBQUk0QyxXQUFXLFFBQVEsT0FBT0EsV0FBVyxZQUFZLE9BQU9BLE9BQU9oQixHQUFHLEtBQUssY0FBY2tCLE1BQU1DLE9BQU8sQ0FBQy9DLFFBQVE7WUFDbEgsSUFBSSxPQUFPNEMsT0FBT3dGLFNBQVMsS0FBSyxZQUFZeEYsT0FBT3dGLFNBQVMsQ0FBQ3BJO2lCQUFZNEMsT0FBT2hCLEdBQUcsSUFBSTVCO1FBQ3pGLE9BRUssSUFBSTRDLFdBQVcsUUFBUSxPQUFPQSxXQUFXLFlBQVksT0FBT0EsT0FBT2hCLEdBQUcsS0FBSyxjQUFjLE9BQU81QixVQUFVLFVBQVU7WUFDdkgsOEJBQThCO1lBQzlCLElBQUksT0FBTzRDLE9BQU95RixTQUFTLEtBQUssWUFBWXpGLE9BQU95RixTQUFTLENBQUNySTtpQkFFeEQ0QyxPQUFPaEIsR0FBRyxDQUFDNUI7UUFDbEIsT0FFSztZQUNILElBQUlzSTtZQUNKaEosSUFBSSxDQUFDZ0csSUFBSSxHQUFHdEY7WUFFWiw4REFBOEQ7WUFDOUQseURBQXlEO1lBQ3pELGdEQUFnRDtZQUNoRCxJQUFJOEgsYUFBYSxDQUFDQSxVQUFVUyxNQUFNLElBQUliLFVBQVVuQyxRQUFRLENBQUNELFFBQVEsQ0FBQ2dELFlBQVloSixJQUFJLENBQUNnRyxJQUFJLEtBQUssUUFBUWdELFVBQVVFLFNBQVMsSUFDdkgsdUZBQXVGO1lBQ3ZGbEosSUFBSSxDQUFDZ0csSUFBSSxDQUFDbUQsTUFBTSxLQUFLM0ssNkNBQWdCLElBQUl3QixJQUFJLENBQUNnRyxJQUFJLENBQUM5RCxJQUFJLEtBQUsxRCxtREFBc0IsRUFBRTtnQkFDbEYsd0ZBQXdGO2dCQUN4RndCLElBQUksQ0FBQ2dHLElBQUksQ0FBQ3NELFVBQVUsR0FBRzlLLGlEQUFvQjtZQUM3QztRQUNGO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUIsSUFBSXVCLFlBQVksUUFBUUEsU0FBU29HLE1BQU0sSUFBSXFDLGFBQWEsUUFBUUEsVUFBVWdCLFFBQVEsSUFBSSxDQUFDakIsbUJBQW1CeEksU0FBU29GLE1BQU0sS0FBSyxRQUFRb0QsaUJBQWlCa0IsVUFBVSxJQUFJaEIsaUJBQWlCMUksU0FBU3FHLFVBQVUsRUFBRTtRQUN6TSxNQUFNakIsU0FBU3BGLFNBQVNvRixNQUFNO1FBQzlCLGlFQUFpRTtRQUNqRSxNQUFNK0IsUUFBUXNCLFVBQVVnQixRQUFRLENBQUNFLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDeEU7UUFDckQsSUFBSStCLFFBQVEsQ0FBQyxHQUFHc0IsVUFBVWdCLFFBQVEsQ0FBQ0UsV0FBVyxDQUFDRSxNQUFNLENBQUMxQyxPQUFPO1FBQzdELHdFQUF3RTtRQUN4RSxJQUFJbkgsU0FBU3FHLFVBQVUsSUFBSWpCLE9BQU8wRSxPQUFPLEtBQUssTUFBTTtZQUNsRHJCLFVBQVVnQixRQUFRLENBQUNFLFdBQVcsQ0FBQ0ksSUFBSSxDQUFDM0U7UUFDdEM7SUFDRjtJQUVBLHVDQUF1QztJQUN2QyxJQUFJcEYsWUFBWUEsU0FBU2lELEtBQUssQ0FBQytELE1BQU0sS0FBS1EsV0FBVztRQUNuRCxJQUFJeEgsU0FBU29GLE1BQU0sQ0FBQzRFLGdCQUFnQixFQUFFaEssU0FBU2lELEtBQUssQ0FBQytELE1BQU0sR0FBRzthQUFnQixJQUFJaEgsU0FBU29GLE1BQU0sQ0FBQzZFLFVBQVUsRUFBRWpLLFNBQVNpRCxLQUFLLENBQUMrRCxNQUFNLEdBQUc7SUFDeEk7SUFFQSx3Q0FBd0M7SUFDeEMsSUFBSWhILFVBQVVrSyxtQkFBbUJsSztJQUNqQyxPQUFPb0Y7QUFDVDtBQUNBLFNBQVM4RSxtQkFBbUJsSyxRQUFRO0lBQ2xDLElBQUltSztJQUNKLElBQUksQ0FBQ25LLFNBQVNvRyxNQUFNLEVBQUU7SUFDdEJwRyxTQUFTaUQsS0FBSyxDQUFDbUgsUUFBUSxJQUFJLE9BQU8sS0FBSyxJQUFJcEssU0FBU2lELEtBQUssQ0FBQ21ILFFBQVEsQ0FBQ3BLLFNBQVNvRixNQUFNO0lBQ2xGLE1BQU12QyxRQUFRLENBQUNzSCxpQkFBaUJuSyxTQUFTQyxJQUFJLEtBQUssT0FBTyxLQUFLLElBQUlrSyxlQUFlakssUUFBUSxJQUFJLE9BQU8sS0FBSyxJQUFJaUssZUFBZWpLLFFBQVE7SUFDcEksSUFBSTJDLFNBQVNBLE1BQU00RyxRQUFRLENBQUNZLE1BQU0sS0FBSyxHQUFHeEgsTUFBTXlILFVBQVU7QUFDNUQ7QUFDQSxTQUFTQyxhQUFhQyxNQUFNLEVBQUVDLElBQUk7SUFDaEMsd0RBQXdEO0lBQ3hELHdEQUF3RDtJQUN4RCxJQUFJRCxPQUFPRSxNQUFNLEVBQUU7SUFDbkIsSUFBSXJLLHFCQUFxQm1LLFNBQVM7UUFDaENBLE9BQU9HLElBQUksR0FBR0YsS0FBS0csS0FBSyxHQUFHLENBQUM7UUFDNUJKLE9BQU9LLEtBQUssR0FBR0osS0FBS0csS0FBSyxHQUFHO1FBQzVCSixPQUFPTSxHQUFHLEdBQUdMLEtBQUtNLE1BQU0sR0FBRztRQUMzQlAsT0FBT1EsTUFBTSxHQUFHUCxLQUFLTSxNQUFNLEdBQUcsQ0FBQztJQUNqQyxPQUFPO1FBQ0xQLE9BQU9TLE1BQU0sR0FBR1IsS0FBS0csS0FBSyxHQUFHSCxLQUFLTSxNQUFNO0lBQzFDO0lBQ0FQLE9BQU9VLHNCQUFzQjtBQUMvQjtBQUNBLE1BQU14QixhQUFhdEUsQ0FBQUEsU0FBVUEsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT3NFLFVBQVU7QUFFeEUsU0FBU3lCLE9BQU9DLEtBQUs7SUFDbkIsT0FBTyxDQUFDQSxNQUFNQyxXQUFXLElBQUlELE1BQU1oRyxNQUFNLEVBQUVrRyxJQUFJLEdBQUcsTUFBTUYsTUFBTWpFLEtBQUssR0FBR2lFLE1BQU1HLFVBQVU7QUFDeEY7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyw4QkFBOEJDLFdBQVcsRUFBRWpMLEdBQUcsRUFBRWtMLFFBQVEsRUFBRUMsU0FBUztJQUMxRSxNQUFNQyxjQUFjRixTQUFTNUQsR0FBRyxDQUFDdEg7SUFDakMsSUFBSW9MLGFBQWE7UUFDZkYsU0FBU0csTUFBTSxDQUFDckw7UUFDaEIseURBQXlEO1FBQ3pELElBQUlrTCxTQUFTakIsSUFBSSxLQUFLLEdBQUc7WUFDdkJnQixZQUFZSSxNQUFNLENBQUNGO1lBQ25CQyxZQUFZckksTUFBTSxDQUFDdUkscUJBQXFCLENBQUNIO1FBQzNDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNJLG9CQUFvQkMsS0FBSyxFQUFFNUcsTUFBTTtJQUN4QyxNQUFNLEVBQ0pxRSxRQUFRLEVBQ1QsR0FBR3VDLE1BQU05TCxRQUFRO0lBQ2xCLHVEQUF1RDtJQUN2RHVKLFNBQVNFLFdBQVcsR0FBR0YsU0FBU0UsV0FBVyxDQUFDc0MsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxNQUFNOUc7SUFDOURxRSxTQUFTMEMsV0FBVyxHQUFHMUMsU0FBUzBDLFdBQVcsQ0FBQ0YsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxNQUFNOUc7SUFDOURxRSxTQUFTMkMsT0FBTyxDQUFDQyxPQUFPLENBQUMsQ0FBQzFMLE9BQU9zRjtRQUMvQixJQUFJdEYsTUFBTTBLLFdBQVcsS0FBS2pHLFVBQVV6RSxNQUFNeUUsTUFBTSxLQUFLQSxRQUFRO1lBQzNELGlEQUFpRDtZQUNqRHFFLFNBQVMyQyxPQUFPLENBQUNQLE1BQU0sQ0FBQzVGO1FBQzFCO0lBQ0Y7SUFDQXdELFNBQVNnQyxXQUFXLENBQUNZLE9BQU8sQ0FBQyxDQUFDWCxVQUFVQztRQUN0Q0gsOEJBQThCL0IsU0FBU2dDLFdBQVcsRUFBRXJHLFFBQVFzRyxVQUFVQztJQUN4RTtBQUNGO0FBQ0EsU0FBU1csYUFBYU4sS0FBSztJQUN6QixxQkFBcUIsR0FDckIsU0FBU08sa0JBQWtCbkIsS0FBSztRQUM5QixNQUFNLEVBQ0ozQixRQUFRLEVBQ1QsR0FBR3VDLE1BQU05TCxRQUFRO1FBQ2xCLE1BQU1zTSxLQUFLcEIsTUFBTXFCLE9BQU8sR0FBR2hELFNBQVNpRCxZQUFZLENBQUMsRUFBRTtRQUNuRCxNQUFNQyxLQUFLdkIsTUFBTXdCLE9BQU8sR0FBR25ELFNBQVNpRCxZQUFZLENBQUMsRUFBRTtRQUNuRCxPQUFPL0ksS0FBS2tKLEtBQUssQ0FBQ2xKLEtBQUttSixJQUFJLENBQUNOLEtBQUtBLEtBQUtHLEtBQUtBO0lBQzdDO0lBRUEsdUdBQXVHLEdBQ3ZHLFNBQVNJLG9CQUFvQmxJLE9BQU87UUFDbEMsT0FBT0EsUUFBUW9ILE1BQU0sQ0FBQ3pMLENBQUFBLE1BQU87Z0JBQUM7Z0JBQVE7Z0JBQVE7Z0JBQVM7Z0JBQU87YUFBUSxDQUFDd00sSUFBSSxDQUFDdkgsQ0FBQUE7Z0JBQzFFLElBQUkxQjtnQkFDSixPQUFPLENBQUNBLE9BQU92RCxJQUFJd0QsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJRCxLQUFLdUMsUUFBUSxDQUFDLGNBQWNiLEtBQUs7WUFDaEY7SUFDRjtJQUNBLFNBQVN3SCxVQUFVN0IsS0FBSyxFQUFFYSxNQUFNO1FBQzlCLE1BQU1wSixRQUFRbUosTUFBTTlMLFFBQVE7UUFDNUIsTUFBTWdOLGFBQWEsSUFBSUM7UUFDdkIsTUFBTUMsZ0JBQWdCLEVBQUU7UUFDeEIsMkNBQTJDO1FBQzNDLE1BQU1DLGdCQUFnQnBCLFNBQVNBLE9BQU9wSixNQUFNNEcsUUFBUSxDQUFDRSxXQUFXLElBQUk5RyxNQUFNNEcsUUFBUSxDQUFDRSxXQUFXO1FBQzlGLDJDQUEyQztRQUMzQyxJQUFLLElBQUkzRSxJQUFJLEdBQUdBLElBQUlxSSxjQUFjcEksTUFBTSxFQUFFRCxJQUFLO1lBQzdDLE1BQU1uQyxRQUFRaUIsYUFBYXVKLGFBQWEsQ0FBQ3JJLEVBQUU7WUFDM0MsSUFBSW5DLE9BQU87Z0JBQ1RBLE1BQU15SyxTQUFTLENBQUM5QyxNQUFNLEdBQUdoRDtZQUMzQjtRQUNGO1FBQ0EsSUFBSSxDQUFDM0UsTUFBTTFDLFlBQVksRUFBRTtZQUN2QixrREFBa0Q7WUFDbEQwQyxNQUFNMEssTUFBTSxDQUFDQyxPQUFPLElBQUksT0FBTyxLQUFLLElBQUkzSyxNQUFNMEssTUFBTSxDQUFDQyxPQUFPLENBQUNwQyxPQUFPdkk7UUFDdEU7UUFDQSxTQUFTNEssY0FBY2pOLEdBQUc7WUFDeEIsTUFBTXFDLFFBQVFpQixhQUFhdEQ7WUFDM0Isa0ZBQWtGO1lBQ2xGLElBQUksQ0FBQ3FDLFNBQVMsQ0FBQ0EsTUFBTTBLLE1BQU0sQ0FBQ0csT0FBTyxJQUFJN0ssTUFBTXlLLFNBQVMsQ0FBQzlDLE1BQU0sS0FBSyxNQUFNLE9BQU8sRUFBRTtZQUVqRixnRkFBZ0Y7WUFDaEYsSUFBSTNILE1BQU15SyxTQUFTLENBQUM5QyxNQUFNLEtBQUtoRCxXQUFXO2dCQUN4QyxJQUFJbUc7Z0JBQ0o5SyxNQUFNMEssTUFBTSxDQUFDQyxPQUFPLElBQUksT0FBTyxLQUFLLElBQUkzSyxNQUFNMEssTUFBTSxDQUFDQyxPQUFPLENBQUNwQyxPQUFPdkksT0FBTyxDQUFDOEssc0JBQXNCOUssTUFBTTFDLFlBQVksS0FBSyxPQUFPLEtBQUssSUFBSXdOLG9CQUFvQnpOLFFBQVE7Z0JBQ3JLLHVFQUF1RTtnQkFDdkUsSUFBSTJDLE1BQU15SyxTQUFTLENBQUM5QyxNQUFNLEtBQUtoRCxXQUFXM0UsTUFBTXlLLFNBQVMsQ0FBQzlDLE1BQU0sR0FBRztZQUNyRTtZQUVBLDZCQUE2QjtZQUM3QixPQUFPM0gsTUFBTXlLLFNBQVMsQ0FBQzlDLE1BQU0sR0FBRzNILE1BQU15SyxTQUFTLENBQUNNLGVBQWUsQ0FBQ3BOLEtBQUssUUFBUSxFQUFFO1FBQ2pGO1FBRUEsaUJBQWlCO1FBQ2pCLElBQUlxTixPQUFPUixhQUNYLG9CQUFvQjtTQUNuQlMsT0FBTyxDQUFDTCxjQUNULHNDQUFzQztTQUNyQ00sSUFBSSxDQUFDLENBQUM3SixHQUFHUztZQUNSLE1BQU1xSixTQUFTbEssYUFBYUksRUFBRWtCLE1BQU07WUFDcEMsTUFBTTZJLFNBQVNuSyxhQUFhYSxFQUFFUyxNQUFNO1lBQ3BDLElBQUksQ0FBQzRJLFVBQVUsQ0FBQ0MsUUFBUSxPQUFPL0osRUFBRWdLLFFBQVEsR0FBR3ZKLEVBQUV1SixRQUFRO1lBQ3RELE9BQU9ELE9BQU9WLE1BQU0sQ0FBQ1ksUUFBUSxHQUFHSCxPQUFPVCxNQUFNLENBQUNZLFFBQVEsSUFBSWpLLEVBQUVnSyxRQUFRLEdBQUd2SixFQUFFdUosUUFBUTtRQUNuRixFQUNBLHdCQUF3QjtTQUN2QmpDLE1BQU0sQ0FBQ21DLENBQUFBO1lBQ04sTUFBTUMsS0FBS2xELE9BQU9pRDtZQUNsQixJQUFJbEIsV0FBV29CLEdBQUcsQ0FBQ0QsS0FBSyxPQUFPO1lBQy9CbkIsV0FBV3FCLEdBQUcsQ0FBQ0Y7WUFDZixPQUFPO1FBQ1Q7UUFFQSxrREFBa0Q7UUFDbEQsOEZBQThGO1FBQzlGLElBQUl4TCxNQUFNMEssTUFBTSxDQUFDdEIsTUFBTSxFQUFFNEIsT0FBT2hMLE1BQU0wSyxNQUFNLENBQUN0QixNQUFNLENBQUM0QixNQUFNaEw7UUFFMUQsNERBQTREO1FBQzVELEtBQUssTUFBTTJMLE9BQU9YLEtBQU07WUFDdEIsSUFBSXhDLGNBQWNtRCxJQUFJcEosTUFBTTtZQUM1QixrQkFBa0I7WUFDbEIsTUFBT2lHLFlBQWE7Z0JBQ2xCLElBQUlvRDtnQkFDSixJQUFJLENBQUNBLFFBQVFwRCxZQUFZckgsS0FBSyxLQUFLLFFBQVF5SyxNQUFNcEksVUFBVSxFQUFFK0csY0FBY3JELElBQUksQ0FBQztvQkFDOUUsR0FBR3lFLEdBQUc7b0JBQ05uRDtnQkFDRjtnQkFDQUEsY0FBY0EsWUFBWWpGLE1BQU07WUFDbEM7UUFDRjtRQUVBLG9GQUFvRjtRQUNwRixJQUFJLGVBQWVnRixTQUFTdkksTUFBTTRHLFFBQVEsQ0FBQ2dDLFdBQVcsQ0FBQzZDLEdBQUcsQ0FBQ2xELE1BQU1PLFNBQVMsR0FBRztZQUMzRSxLQUFLLElBQUlDLGVBQWUvSSxNQUFNNEcsUUFBUSxDQUFDZ0MsV0FBVyxDQUFDM0QsR0FBRyxDQUFDc0QsTUFBTU8sU0FBUyxFQUFFK0MsTUFBTSxHQUFJO2dCQUNoRixJQUFJLENBQUN4QixXQUFXb0IsR0FBRyxDQUFDbkQsT0FBT1MsWUFBWStDLFlBQVksSUFBSXZCLGNBQWNyRCxJQUFJLENBQUM2QixZQUFZK0MsWUFBWTtZQUNwRztRQUNGO1FBQ0EsT0FBT3ZCO0lBQ1Q7SUFFQSwwREFBMEQsR0FDMUQsU0FBU3dCLGlCQUFpQnhCLGFBQWEsRUFBRWhDLEtBQUssRUFBRXlELEtBQUssRUFBRUMsUUFBUTtRQUM3RCxnRUFBZ0U7UUFDaEUsSUFBSTFCLGNBQWNuSSxNQUFNLEVBQUU7WUFDeEIsTUFBTThKLGFBQWE7Z0JBQ2pCQyxTQUFTO1lBQ1g7WUFDQSxLQUFLLE1BQU1SLE9BQU9wQixjQUFlO2dCQUMvQixJQUFJdkssUUFBUWlCLGFBQWEwSyxJQUFJcEosTUFBTTtnQkFFbkMsb0ZBQW9GO2dCQUNwRiw2RUFBNkU7Z0JBQzdFLElBQUksQ0FBQ3ZDLE9BQU87b0JBQ1YyTCxJQUFJcEosTUFBTSxDQUFDNkosaUJBQWlCLENBQUN6TyxDQUFBQTt3QkFDM0IsTUFBTTBPLGNBQWNwTCxhQUFhdEQ7d0JBQ2pDLElBQUkwTyxhQUFhOzRCQUNmck0sUUFBUXFNOzRCQUNSLE9BQU87d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSXJNLE9BQU87b0JBQ1QsTUFBTSxFQUNKeUssU0FBUyxFQUNUNkIsT0FBTyxFQUNQM0UsTUFBTSxFQUNOZixRQUFRLEVBQ1QsR0FBRzVHO29CQUNKLE1BQU11TSxtQkFBbUIsSUFBSTNRLDBDQUFhLENBQUMwUSxRQUFRRyxDQUFDLEVBQUVILFFBQVFJLENBQUMsRUFBRSxHQUFHQyxTQUFTLENBQUNoRjtvQkFDOUUsTUFBTWlGLG9CQUFvQnBCLENBQUFBO3dCQUN4QixJQUFJcUIsdUJBQXVCQzt3QkFDM0IsT0FBTyxDQUFDRCx3QkFBd0IsQ0FBQ0MseUJBQXlCbEcsU0FBU2dDLFdBQVcsQ0FBQzNELEdBQUcsQ0FBQ3VHLEdBQUUsS0FBTSxPQUFPLEtBQUssSUFBSXNCLHVCQUF1QnJCLEdBQUcsQ0FBQ0UsSUFBSW5ELFdBQVcsTUFBTSxPQUFPcUUsd0JBQXdCO29CQUM1TDtvQkFDQSxNQUFNRSxvQkFBb0J2QixDQUFBQTt3QkFDeEIsTUFBTXpDLGNBQWM7NEJBQ2xCK0MsY0FBY0g7NEJBQ2RqTCxRQUFRNkgsTUFBTTdILE1BQU07d0JBQ3RCO3dCQUNBLElBQUlrRyxTQUFTZ0MsV0FBVyxDQUFDNkMsR0FBRyxDQUFDRCxLQUFLOzRCQUNoQyxrRUFBa0U7NEJBQ2xFLHFCQUFxQjs0QkFDckI1RSxTQUFTZ0MsV0FBVyxDQUFDM0QsR0FBRyxDQUFDdUcsSUFBSTlMLEdBQUcsQ0FBQ2lNLElBQUluRCxXQUFXLEVBQUVPO3dCQUNwRCxPQUFPOzRCQUNMLGdFQUFnRTs0QkFDaEUsK0RBQStEOzRCQUMvRCxpQkFBaUI7NEJBQ2pCbkMsU0FBU2dDLFdBQVcsQ0FBQ2xKLEdBQUcsQ0FBQzhMLElBQUksSUFBSTFHLElBQUk7Z0NBQUM7b0NBQUM2RyxJQUFJbkQsV0FBVztvQ0FBRU87aUNBQVk7NkJBQUM7d0JBQ3ZFO3dCQUNBUixNQUFNN0gsTUFBTSxDQUFDcU0saUJBQWlCLENBQUN2QjtvQkFDakM7b0JBQ0EsTUFBTXZDLHdCQUF3QnVDLENBQUFBO3dCQUM1QixNQUFNM0MsV0FBV2pDLFNBQVNnQyxXQUFXLENBQUMzRCxHQUFHLENBQUN1Rzt3QkFDMUMsSUFBSTNDLFVBQVU7NEJBQ1pGLDhCQUE4Qi9CLFNBQVNnQyxXQUFXLEVBQUUrQyxJQUFJbkQsV0FBVyxFQUFFSyxVQUFVMkM7d0JBQ2pGO29CQUNGO29CQUVBLHlCQUF5QjtvQkFDekIsSUFBSXdCLG9CQUFvQixDQUFDO29CQUN6Qix1YUFBdWE7b0JBQ3ZhLElBQUssSUFBSWhLLFFBQVF1RixNQUFPO3dCQUN0QixJQUFJMEUsV0FBVzFFLEtBQUssQ0FBQ3ZGLEtBQUs7d0JBQzFCLG1FQUFtRTt3QkFDbkUsbUNBQW1DO3dCQUNuQyxJQUFJLE9BQU9pSyxhQUFhLFlBQVlELGlCQUFpQixDQUFDaEssS0FBSyxHQUFHaUs7b0JBQ2hFO29CQUNBLElBQUlDLGVBQWU7d0JBQ2pCLEdBQUd2QixHQUFHO3dCQUNOLEdBQUdxQixpQkFBaUI7d0JBQ3BCVjt3QkFDQS9CO3dCQUNBNEIsU0FBU0QsV0FBV0MsT0FBTzt3QkFDM0JIO3dCQUNBTzt3QkFDQVksS0FBSzFDLFVBQVUwQyxHQUFHO3dCQUNsQnhGLFFBQVFBO3dCQUNSLGlEQUFpRDt3QkFDakR5Rjs0QkFDRSx5REFBeUQ7NEJBQ3pELDhFQUE4RTs0QkFDOUUsTUFBTUMscUJBQXFCLGVBQWU5RSxTQUFTM0IsU0FBU2dDLFdBQVcsQ0FBQzNELEdBQUcsQ0FBQ3NELE1BQU1PLFNBQVM7NEJBRTNGLHVDQUF1Qzs0QkFDdkMsSUFDQSwwQ0FBMEM7NEJBQzFDLENBQUN1RSxzQkFDRCxvREFBb0Q7NEJBQ3BEQSxtQkFBbUI1QixHQUFHLENBQUNFLElBQUluRCxXQUFXLEdBQUc7Z0NBQ3ZDMEUsYUFBYWYsT0FBTyxHQUFHRCxXQUFXQyxPQUFPLEdBQUc7Z0NBQzVDLHlEQUF5RDtnQ0FDekQsbUZBQW1GO2dDQUNuRixJQUFJdkYsU0FBUzJDLE9BQU8sQ0FBQzNCLElBQUksSUFBSWhILE1BQU0wTSxJQUFJLENBQUMxRyxTQUFTMkMsT0FBTyxDQUFDc0MsTUFBTSxJQUFJMEIsSUFBSSxDQUFDcEwsQ0FBQUEsSUFBS0EsRUFBRXFHLFdBQVcsS0FBS21ELElBQUluRCxXQUFXLEdBQUc7b0NBQy9HLGdGQUFnRjtvQ0FDaEYsTUFBTWdGLFNBQVNqRCxjQUFja0QsS0FBSyxDQUFDLEdBQUdsRCxjQUFjeEQsT0FBTyxDQUFDNEU7b0NBQzVEK0IsY0FBYzsyQ0FBSUY7d0NBQVE3QjtxQ0FBSTtnQ0FDaEM7NEJBQ0Y7d0JBQ0Y7d0JBQ0EsaUVBQWlFO3dCQUNqRWpMLFFBQVE7NEJBQ05rTTs0QkFDQUc7NEJBQ0E5RDt3QkFDRjt3QkFDQTBFLGVBQWU7NEJBQ2JmOzRCQUNBRzs0QkFDQTlEO3dCQUNGO3dCQUNBMkUsYUFBYXJGO29CQUNmO29CQUVBLG1CQUFtQjtvQkFDbkIwRCxTQUFTaUI7b0JBQ1QsdURBQXVEO29CQUN2RCxJQUFJaEIsV0FBV0MsT0FBTyxLQUFLLE1BQU07Z0JBQ25DO1lBQ0Y7UUFDRjtRQUNBLE9BQU81QjtJQUNUO0lBQ0EsU0FBU21ELGNBQWNuRCxhQUFhO1FBQ2xDLE1BQU0sRUFDSjNELFFBQVEsRUFDVCxHQUFHdUMsTUFBTTlMLFFBQVE7UUFDbEIsS0FBSyxNQUFNd1EsY0FBY2pILFNBQVMyQyxPQUFPLENBQUNzQyxNQUFNLEdBQUk7WUFDbEQsd0ZBQXdGO1lBQ3hGLDJFQUEyRTtZQUMzRSxJQUFJLENBQUN0QixjQUFjbkksTUFBTSxJQUFJLENBQUNtSSxjQUFjZ0QsSUFBSSxDQUFDNUIsQ0FBQUEsTUFBT0EsSUFBSXBKLE1BQU0sS0FBS3NMLFdBQVd0TCxNQUFNLElBQUlvSixJQUFJckgsS0FBSyxLQUFLdUosV0FBV3ZKLEtBQUssSUFBSXFILElBQUlqRCxVQUFVLEtBQUttRixXQUFXbkYsVUFBVSxHQUFHO2dCQUN2SyxNQUFNRixjQUFjcUYsV0FBV3JGLFdBQVc7Z0JBQzFDLE1BQU1yTCxXQUFXcUwsWUFBWXJILEtBQUs7Z0JBQ2xDeUYsU0FBUzJDLE9BQU8sQ0FBQ1AsTUFBTSxDQUFDVixPQUFPdUY7Z0JBQy9CLElBQUkxUSxZQUFZLFFBQVFBLFNBQVNxRyxVQUFVLEVBQUU7b0JBQzNDLE1BQU1DLFdBQVd0RyxTQUFTc0csUUFBUTtvQkFDbEMsaURBQWlEO29CQUNqRCxNQUFNakIsT0FBTzt3QkFDWCxHQUFHcUwsVUFBVTt3QkFDYnREO29CQUNGO29CQUNBOUcsU0FBU3FLLFlBQVksSUFBSSxPQUFPLEtBQUssSUFBSXJLLFNBQVNxSyxZQUFZLENBQUN0TDtvQkFDL0RpQixTQUFTc0ssY0FBYyxJQUFJLE9BQU8sS0FBSyxJQUFJdEssU0FBU3NLLGNBQWMsQ0FBQ3ZMO2dCQUNyRTtZQUNGO1FBQ0Y7SUFDRjtJQUNBLFNBQVN3TCxjQUFjekYsS0FBSyxFQUFFdkcsT0FBTztRQUNuQyxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUgsUUFBUUksTUFBTSxFQUFFRCxJQUFLO1lBQ3ZDLE1BQU1oRixXQUFXNkUsT0FBTyxDQUFDRyxFQUFFLENBQUNoQixLQUFLO1lBQ2pDaEUsWUFBWSxPQUFPLEtBQUssSUFBSUEsU0FBU3NHLFFBQVEsQ0FBQ3dLLGVBQWUsSUFBSSxPQUFPLEtBQUssSUFBSTlRLFNBQVNzRyxRQUFRLENBQUN3SyxlQUFlLENBQUMxRjtRQUNySDtJQUNGO0lBQ0EsU0FBUzJGLGNBQWN0TCxJQUFJO1FBQ3pCLHdCQUF3QjtRQUN4QixPQUFRQTtZQUNOLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU8sSUFBTThLLGNBQWMsRUFBRTtZQUMvQixLQUFLO2dCQUNILE9BQU9uRixDQUFBQTtvQkFDTCxNQUFNLEVBQ0ozQixRQUFRLEVBQ1QsR0FBR3VDLE1BQU05TCxRQUFRO29CQUNsQixJQUFJLGVBQWVrTCxTQUFTM0IsU0FBU2dDLFdBQVcsQ0FBQzZDLEdBQUcsQ0FBQ2xELE1BQU1PLFNBQVMsR0FBRzt3QkFDckUscUZBQXFGO3dCQUNyRiwyRkFBMkY7d0JBQzNGLDBGQUEwRjt3QkFDMUYscUZBQXFGO3dCQUNyRnFGLHNCQUFzQjs0QkFDcEIsa0RBQWtEOzRCQUNsRCxJQUFJdkgsU0FBU2dDLFdBQVcsQ0FBQzZDLEdBQUcsQ0FBQ2xELE1BQU1PLFNBQVMsR0FBRztnQ0FDN0NsQyxTQUFTZ0MsV0FBVyxDQUFDSSxNQUFNLENBQUNULE1BQU1PLFNBQVM7Z0NBQzNDNEUsY0FBYyxFQUFFOzRCQUNsQjt3QkFDRjtvQkFDRjtnQkFDRjtRQUNKO1FBRUEsa0NBQWtDO1FBQ2xDLE9BQU8sU0FBU1UsWUFBWTdGLEtBQUs7WUFDL0IsTUFBTSxFQUNKMEYsZUFBZSxFQUNmckgsUUFBUSxFQUNULEdBQUd1QyxNQUFNOUwsUUFBUTtZQUVsQixvQkFBb0I7WUFDcEJ1SixTQUFTeUgsU0FBUyxDQUFDdlAsT0FBTyxHQUFHeUo7WUFFN0IsdUJBQXVCO1lBQ3ZCLE1BQU0rRixnQkFBZ0IxTCxTQUFTO1lBQy9CLE1BQU0yTCxlQUFlM0wsU0FBUyxhQUFhQSxTQUFTLG1CQUFtQkEsU0FBUztZQUNoRixNQUFNd0csU0FBU2tGLGdCQUFnQnBFLHNCQUFzQnZGO1lBQ3JELE1BQU1xRyxPQUFPWixVQUFVN0IsT0FBT2E7WUFDOUIsTUFBTTRDLFFBQVF1QyxlQUFlN0Usa0JBQWtCbkIsU0FBUztZQUV4RCwyQ0FBMkM7WUFDM0MsSUFBSTNGLFNBQVMsaUJBQWlCO2dCQUM1QmdFLFNBQVNpRCxZQUFZLEdBQUc7b0JBQUN0QixNQUFNcUIsT0FBTztvQkFBRXJCLE1BQU13QixPQUFPO2lCQUFDO2dCQUN0RG5ELFNBQVMwQyxXQUFXLEdBQUcwQixLQUFLd0QsR0FBRyxDQUFDN0MsQ0FBQUEsTUFBT0EsSUFBSW5ELFdBQVc7WUFDeEQ7WUFFQSxtRUFBbUU7WUFDbkUsd0ZBQXdGO1lBQ3hGLElBQUkrRixnQkFBZ0IsQ0FBQ3ZELEtBQUs1SSxNQUFNLEVBQUU7Z0JBQ2hDLElBQUk0SixTQUFTLEdBQUc7b0JBQ2RnQyxjQUFjekYsT0FBTzNCLFNBQVNFLFdBQVc7b0JBQ3pDLElBQUltSCxpQkFBaUJBLGdCQUFnQjFGO2dCQUN2QztZQUNGO1lBQ0EsdUJBQXVCO1lBQ3ZCLElBQUkrRixlQUFlWixjQUFjMUM7WUFDakMsU0FBU3lELFlBQVlqTSxJQUFJO2dCQUN2QixNQUFNZ0csY0FBY2hHLEtBQUtnRyxXQUFXO2dCQUNwQyxNQUFNckwsV0FBV3FMLFlBQVlySCxLQUFLO2dCQUVsQyw2QkFBNkI7Z0JBQzdCLElBQUksQ0FBRWhFLENBQUFBLFlBQVksUUFBUUEsU0FBU3FHLFVBQVUsR0FBRztnQkFDaEQsTUFBTUMsV0FBV3RHLFNBQVNzRyxRQUFRO2dCQUVsQzs7Ozs7Ozs7Ozs7OztTQWFDLEdBRUQsSUFBSTZLLGVBQWU7b0JBQ2pCLGlCQUFpQjtvQkFDakIsSUFBSTdLLFNBQVNpTCxhQUFhLElBQUlqTCxTQUFTa0wsY0FBYyxJQUFJbEwsU0FBU3FLLFlBQVksSUFBSXJLLFNBQVNzSyxjQUFjLEVBQUU7d0JBQ3pHLHdEQUF3RDt3QkFDeEQsTUFBTXZDLEtBQUtsRCxPQUFPOUY7d0JBQ2xCLE1BQU1vTSxjQUFjaEksU0FBUzJDLE9BQU8sQ0FBQ3RFLEdBQUcsQ0FBQ3VHO3dCQUN6QyxJQUFJLENBQUNvRCxhQUFhOzRCQUNoQix3RUFBd0U7NEJBQ3hFaEksU0FBUzJDLE9BQU8sQ0FBQzdKLEdBQUcsQ0FBQzhMLElBQUloSjs0QkFDekJpQixTQUFTaUwsYUFBYSxJQUFJLE9BQU8sS0FBSyxJQUFJakwsU0FBU2lMLGFBQWEsQ0FBQ2xNOzRCQUNqRWlCLFNBQVNrTCxjQUFjLElBQUksT0FBTyxLQUFLLElBQUlsTCxTQUFTa0wsY0FBYyxDQUFDbk07d0JBQ3JFLE9BQU8sSUFBSW9NLFlBQVl6QyxPQUFPLEVBQUU7NEJBQzlCLDhGQUE4Rjs0QkFDOUYzSixLQUFLNEssZUFBZTt3QkFDdEI7b0JBQ0Y7b0JBQ0Esa0JBQWtCO29CQUNsQjNKLFNBQVNvTCxhQUFhLElBQUksT0FBTyxLQUFLLElBQUlwTCxTQUFTb0wsYUFBYSxDQUFDck07Z0JBQ25FLE9BQU87b0JBQ0wsdUJBQXVCO29CQUN2QixNQUFNc00sVUFBVXJMLFFBQVEsQ0FBQ2IsS0FBSztvQkFDOUIsSUFBSWtNLFNBQVM7d0JBQ1gsMkZBQTJGO3dCQUMzRixvQ0FBb0M7d0JBQ3BDLElBQUksQ0FBQ1AsZ0JBQWdCM0gsU0FBUzBDLFdBQVcsQ0FBQ2pHLFFBQVEsQ0FBQ21GLGNBQWM7NEJBQy9ELG1DQUFtQzs0QkFDbkN3RixjQUFjekYsT0FBTzNCLFNBQVNFLFdBQVcsQ0FBQ3NDLE1BQU0sQ0FBQzdHLENBQUFBLFNBQVUsQ0FBQ3FFLFNBQVMwQyxXQUFXLENBQUNqRyxRQUFRLENBQUNkOzRCQUMxRix1QkFBdUI7NEJBQ3ZCdU0sUUFBUXRNO3dCQUNWO29CQUNGLE9BQU87d0JBQ0wsNkdBQTZHO3dCQUM3RyxJQUFJK0wsZ0JBQWdCM0gsU0FBUzBDLFdBQVcsQ0FBQ2pHLFFBQVEsQ0FBQ21GLGNBQWM7NEJBQzlEd0YsY0FBY3pGLE9BQU8zQixTQUFTRSxXQUFXLENBQUNzQyxNQUFNLENBQUM3RyxDQUFBQSxTQUFVLENBQUNxRSxTQUFTMEMsV0FBVyxDQUFDakcsUUFBUSxDQUFDZDt3QkFDNUY7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBd0osaUJBQWlCZixNQUFNekMsT0FBT3lELE9BQU95QztRQUN2QztJQUNGO0lBQ0EsT0FBTztRQUNMUDtJQUNGO0FBQ0Y7QUFFQSxNQUFNYSxhQUFhdFIsQ0FBQUEsTUFBTyxDQUFDLENBQUVBLENBQUFBLE9BQU8sUUFBUUEsSUFBSTRDLE1BQU07QUFDdEQsTUFBTTJPLFVBQVUsYUFBYSxpQkFBRW5ULGdEQUFtQixDQUFDO0FBQ25ELE1BQU1xVCxjQUFjLENBQUN6SCxZQUFZMEg7SUFDL0IsTUFBTUMsWUFBWWxULHlFQUFvQkEsQ0FBQyxDQUFDd0QsS0FBS3VGO1FBQzNDLE1BQU1vSyxXQUFXLElBQUl6VCwwQ0FBYTtRQUNsQyxNQUFNMFQsZ0JBQWdCLElBQUkxVCwwQ0FBYTtRQUN2QyxNQUFNMlQsYUFBYSxJQUFJM1QsMENBQWE7UUFDcEMsU0FBUzRULG1CQUFtQjdILFNBQVMxQyxNQUFNMEMsTUFBTSxFQUFFakgsU0FBUzRPLGFBQWEsRUFBRTFILE9BQU8zQyxNQUFNMkMsSUFBSTtZQUMxRixNQUFNLEVBQ0pHLEtBQUssRUFDTEcsTUFBTSxFQUNORCxHQUFHLEVBQ0hILElBQUksRUFDTCxHQUFHRjtZQUNKLE1BQU1RLFNBQVNMLFFBQVFHO1lBQ3ZCLElBQUl4SCxPQUFPK08sU0FBUyxFQUFFRixXQUFXdEosSUFBSSxDQUFDdkY7aUJBQWE2TyxXQUFXN1AsR0FBRyxJQUFJZ0I7WUFDckUsTUFBTTJLLFdBQVcxRCxPQUFPK0gsZ0JBQWdCLENBQUNMLFVBQVVNLFVBQVUsQ0FBQ0o7WUFDOUQsSUFBSS9SLHFCQUFxQm1LLFNBQVM7Z0JBQ2hDLE9BQU87b0JBQ0xJLE9BQU9BLFFBQVFKLE9BQU9pSSxJQUFJO29CQUMxQjFILFFBQVFBLFNBQVNQLE9BQU9pSSxJQUFJO29CQUM1QjNIO29CQUNBSDtvQkFDQStILFFBQVE7b0JBQ1J4RTtvQkFDQWpEO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxNQUFNMEgsTUFBTW5JLE9BQU9tSSxHQUFHLEdBQUdoUCxLQUFLaVAsRUFBRSxHQUFHLEtBQUssa0NBQWtDO2dCQUMxRSxNQUFNQyxJQUFJLElBQUlsUCxLQUFLbVAsR0FBRyxDQUFDSCxNQUFNLEtBQUt6RSxVQUFVLGlCQUFpQjtnQkFDN0QsTUFBTTZFLElBQUlGLElBQUtqSSxDQUFBQSxRQUFRRyxNQUFLO2dCQUM1QixPQUFPO29CQUNMSCxPQUFPbUk7b0JBQ1BoSSxRQUFROEg7b0JBQ1IvSDtvQkFDQUg7b0JBQ0ErSCxRQUFROUgsUUFBUW1JO29CQUNoQjdFO29CQUNBakQ7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSStILHFCQUFxQnhMO1FBQ3pCLE1BQU15TCx3QkFBd0J0UixDQUFBQSxVQUFXWSxJQUFJTSxDQUFBQSxRQUFVO29CQUNyRHFRLGFBQWE7d0JBQ1gsR0FBR3JRLE1BQU1xUSxXQUFXO3dCQUNwQnZSO29CQUNGO2dCQUNGO1FBQ0EsTUFBTXdOLFVBQVUsSUFBSTFRLDBDQUFhO1FBQ2pDLE1BQU1nSyxZQUFZO1lBQ2hCbEc7WUFDQXVGO1lBQ0EsMENBQTBDO1lBQzFDc0wsSUFBSTtZQUNKNUksUUFBUTtZQUNSOEMsV0FBVztZQUNYQyxRQUFRO2dCQUNOWSxVQUFVO2dCQUNWVCxTQUFTO2dCQUNUMkYsV0FBVztZQUNiO1lBQ0FDLE9BQU87WUFDUEMsSUFBSTtZQUNKakosWUFBWSxDQUFDRCxTQUFTLENBQUMsR0FBS0MsV0FBV3hDLE9BQU91QztZQUM5QzJILFNBQVMsQ0FBQ3dCLFdBQVdDLG1CQUFxQnpCLFFBQVF3QixXQUFXQyxrQkFBa0IzTDtZQUMvRTRMLFFBQVE7WUFDUnhLLFFBQVE7WUFDUnlLLE1BQU07WUFDTkMsVUFBVTtZQUNWQyxPQUFPLElBQUlwVix3Q0FBVztZQUN0QjBRO1lBQ0E0RSxPQUFPNUU7WUFDUDZFLFdBQVc7WUFDWGxELGlCQUFpQnRKO1lBQ2pCMEwsYUFBYTtnQkFDWHZSLFNBQVM7Z0JBQ1RpQyxLQUFLO2dCQUNMQyxLQUFLO2dCQUNMb1EsVUFBVTtnQkFDVkMsU0FBUztvQkFDUCxNQUFNclIsUUFBUWlGO29CQUNkLGdCQUFnQjtvQkFDaEIsSUFBSWtMLG9CQUFvQm1CLGFBQWFuQjtvQkFDckMsOEJBQThCO29CQUM5QixJQUFJblEsTUFBTXFRLFdBQVcsQ0FBQ3ZSLE9BQU8sS0FBS2tCLE1BQU1xUSxXQUFXLENBQUN0UCxHQUFHLEVBQUVxUCxzQkFBc0JwUSxNQUFNcVEsV0FBVyxDQUFDdFAsR0FBRztvQkFDcEcsd0ZBQXdGO29CQUN4Rm9QLHFCQUFxQm9CLFdBQVcsSUFBTW5CLHNCQUFzQm5MLE1BQU1vTCxXQUFXLENBQUNyUCxHQUFHLEdBQUdoQixNQUFNcVEsV0FBVyxDQUFDZSxRQUFRO2dCQUNoSDtZQUNGO1lBQ0F4SixNQUFNO2dCQUNKRyxPQUFPO2dCQUNQRyxRQUFRO2dCQUNSRCxLQUFLO2dCQUNMSCxNQUFNO1lBQ1I7WUFDQTBKLFVBQVU7Z0JBQ1JDLFlBQVk7Z0JBQ1pqUixLQUFLO2dCQUNMdUgsT0FBTztnQkFDUEcsUUFBUTtnQkFDUkQsS0FBSztnQkFDTEgsTUFBTTtnQkFDTk0sUUFBUTtnQkFDUmlELFVBQVU7Z0JBQ1Z3RSxRQUFRO2dCQUNSTDtZQUNGO1lBQ0FrQyxXQUFXaEgsQ0FBQUEsU0FBVWhMLElBQUlNLENBQUFBLFFBQVU7d0JBQ2pDLEdBQUdBLEtBQUs7d0JBQ1IwSyxRQUFROzRCQUNOLEdBQUcxSyxNQUFNMEssTUFBTTs0QkFDZixHQUFHQSxNQUFNO3dCQUNYO29CQUNGO1lBQ0FpSCxTQUFTLENBQUM1SixPQUFPRyxRQUFRRCxNQUFNLENBQUMsRUFBRUgsT0FBTyxDQUFDO2dCQUN4QyxNQUFNSCxTQUFTMUMsTUFBTTBDLE1BQU07Z0JBQzNCLE1BQU1DLE9BQU87b0JBQ1hHO29CQUNBRztvQkFDQUQ7b0JBQ0FIO2dCQUNGO2dCQUNBcEksSUFBSU0sQ0FBQUEsUUFBVTt3QkFDWjRIO3dCQUNBNEosVUFBVTs0QkFDUixHQUFHeFIsTUFBTXdSLFFBQVE7NEJBQ2pCLEdBQUdoQyxtQkFBbUI3SCxRQUFRMkgsZUFBZTFILEtBQUs7d0JBQ3BEO29CQUNGO1lBQ0Y7WUFDQWdLLFFBQVFwUixDQUFBQSxNQUFPZCxJQUFJTSxDQUFBQTtvQkFDakIsTUFBTTZSLFdBQVd0UixhQUFhQztvQkFDOUIsT0FBTzt3QkFDTGdSLFVBQVU7NEJBQ1IsR0FBR3hSLE1BQU13UixRQUFROzRCQUNqQmhSLEtBQUtxUjs0QkFDTEosWUFBWXpSLE1BQU13UixRQUFRLENBQUNDLFVBQVUsSUFBSUk7d0JBQzNDO29CQUNGO2dCQUNGO1lBQ0FDLGNBQWMsQ0FBQ1gsWUFBWSxRQUFRO2dCQUNqQyxNQUFNSCxRQUFRL0wsTUFBTStMLEtBQUs7Z0JBRXpCLGlGQUFpRjtnQkFDakZBLE1BQU1lLElBQUk7Z0JBQ1ZmLE1BQU1nQixXQUFXLEdBQUc7Z0JBQ3BCLElBQUliLGNBQWMsU0FBUztvQkFDekJILE1BQU1pQixLQUFLO29CQUNYakIsTUFBTWdCLFdBQVcsR0FBRztnQkFDdEI7Z0JBQ0F0UyxJQUFJLElBQU87d0JBQ1R5UjtvQkFDRjtZQUNGO1lBQ0E3VCxjQUFjcUg7WUFDZGlDLFVBQVU7Z0JBQ1IsU0FBUztnQkFDVEUsYUFBYSxFQUFFO2dCQUNmeUMsU0FBUyxJQUFJekU7Z0JBQ2JvTixhQUFhLEVBQUU7Z0JBQ2ZySSxjQUFjO29CQUFDO29CQUFHO2lCQUFFO2dCQUNwQlAsYUFBYSxFQUFFO2dCQUNmVixhQUFhLElBQUk5RDtnQkFDakJ1SixXQUFXLFdBQVcsR0FBRXhTLDRDQUFlO2dCQUN2QyxVQUFVO2dCQUNWdVcsUUFBUTtnQkFDUjVLLFFBQVE7Z0JBQ1I4RCxVQUFVO2dCQUNWK0csV0FBVyxDQUFDelQsS0FBSzBNLFVBQVVuQztvQkFDekIsTUFBTXZDLFdBQVczQixNQUFNMkIsUUFBUTtvQkFDL0IsbUZBQW1GO29CQUNuRixpRkFBaUY7b0JBQ2pGLDZFQUE2RTtvQkFDN0UsdURBQXVEO29CQUN2REEsU0FBUzBFLFFBQVEsR0FBRzFFLFNBQVMwRSxRQUFRLEdBQUlBLENBQUFBLFdBQVcsSUFBSSxJQUFJO29CQUM1RDFFLFNBQVNzTCxXQUFXLENBQUNoTCxJQUFJLENBQUM7d0JBQ3hCdEk7d0JBQ0EwTTt3QkFDQW5DO29CQUNGO29CQUNBLHVFQUF1RTtvQkFDdkUsNkRBQTZEO29CQUM3RHZDLFNBQVNzTCxXQUFXLEdBQUd0TCxTQUFTc0wsV0FBVyxDQUFDaEgsSUFBSSxDQUFDLENBQUM3SixHQUFHUyxJQUFNVCxFQUFFaUssUUFBUSxHQUFHeEosRUFBRXdKLFFBQVE7b0JBQ2xGLE9BQU87d0JBQ0wsTUFBTTFFLFdBQVczQixNQUFNMkIsUUFBUTt3QkFDL0IsSUFBSUEsWUFBWSxRQUFRQSxTQUFTc0wsV0FBVyxFQUFFOzRCQUM1QywyREFBMkQ7NEJBQzNEdEwsU0FBUzBFLFFBQVEsR0FBRzFFLFNBQVMwRSxRQUFRLEdBQUlBLENBQUFBLFdBQVcsSUFBSSxJQUFJOzRCQUM1RCw4QkFBOEI7NEJBQzlCMUUsU0FBU3NMLFdBQVcsR0FBR3RMLFNBQVNzTCxXQUFXLENBQUM5SSxNQUFNLENBQUNrSixDQUFBQSxJQUFLQSxFQUFFMVQsR0FBRyxLQUFLQTt3QkFDcEU7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsT0FBT2dIO0lBQ1Q7SUFDQSxNQUFNNUYsUUFBUW9QLFVBQVUvUixRQUFRO0lBQ2hDLElBQUlrVixVQUFVdlMsTUFBTTRILElBQUk7SUFDeEIsSUFBSTRLLFNBQVN4UyxNQUFNd1IsUUFBUSxDQUFDaFIsR0FBRztJQUMvQixJQUFJaVMsWUFBWXpTLE1BQU0ySCxNQUFNO0lBQzVCeUgsVUFBVWlELFNBQVMsQ0FBQztRQUNsQixNQUFNLEVBQ0oxSyxNQUFNLEVBQ05DLElBQUksRUFDSjRKLFFBQVEsRUFDUmpCLEVBQUUsRUFDRjdRLEdBQUcsRUFDSixHQUFHMFAsVUFBVS9SLFFBQVE7UUFFdEIsK0RBQStEO1FBQy9ELElBQUl1SyxLQUFLRyxLQUFLLEtBQUt3SyxRQUFReEssS0FBSyxJQUFJSCxLQUFLTSxNQUFNLEtBQUtxSyxRQUFRckssTUFBTSxJQUFJc0osU0FBU2hSLEdBQUcsS0FBS2dTLFFBQVE7WUFDN0ZELFVBQVUzSztZQUNWNEssU0FBU2hCLFNBQVNoUixHQUFHO1lBQ3JCLDJCQUEyQjtZQUMzQmtILGFBQWFDLFFBQVFDO1lBQ3JCLElBQUk0SixTQUFTaFIsR0FBRyxHQUFHLEdBQUcrUCxHQUFHbUMsYUFBYSxDQUFDbEIsU0FBU2hSLEdBQUc7WUFDbkQsTUFBTW1TLGNBQWMsT0FBT0Msc0JBQXNCLGVBQWVyQyxHQUFHc0MsVUFBVSxZQUFZRDtZQUN6RnJDLEdBQUdvQixPQUFPLENBQUMvSixLQUFLRyxLQUFLLEVBQUVILEtBQUtNLE1BQU0sRUFBRXlLO1FBQ3RDO1FBRUEsMENBQTBDO1FBQzFDLElBQUloTCxXQUFXOEssV0FBVztZQUN4QkEsWUFBWTlLO1lBQ1osa0JBQWtCO1lBQ2xCakksSUFBSU0sQ0FBQUEsUUFBVTtvQkFDWndSLFVBQVU7d0JBQ1IsR0FBR3hSLE1BQU13UixRQUFRO3dCQUNqQixHQUFHeFIsTUFBTXdSLFFBQVEsQ0FBQ2hDLGtCQUFrQixDQUFDN0gsT0FBTztvQkFDOUM7Z0JBQ0Y7UUFDRjtJQUNGO0lBRUEsMkJBQTJCO0lBQzNCeUgsVUFBVWlELFNBQVMsQ0FBQ3JTLENBQUFBLFFBQVN5SCxXQUFXekg7SUFFeEMsb0JBQW9CO0lBQ3BCLE9BQU9vUDtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTMEQsa0JBQWtCbFUsR0FBRztJQUM1QixNQUFNekIsV0FBV3RCLHlDQUFZLENBQUM7SUFDOUJBLHNEQUF5QixDQUFDc0I7aURBQVUsSUFBTXlCLElBQUlFLE9BQU8sQ0FBQ3FDLEtBQUs7Z0RBQUU7UUFBQ3ZDO0tBQUk7SUFDbEUsT0FBT3pCO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTNlY7SUFDUCxNQUFNN0osUUFBUXROLDZDQUFnQixDQUFDbVQ7SUFDL0IsSUFBSSxDQUFDN0YsT0FBTyxNQUFNLElBQUkrSixNQUFNO0lBQzVCLE9BQU8vSjtBQUNUO0FBRUE7OztDQUdDLEdBQ0QsU0FBU2dLLFNBQVNDLFdBQVdwVCxDQUFBQSxRQUFTQSxLQUFLLEVBQUVxVCxVQUFVO0lBQ3JELE9BQU9MLFdBQVdJLFVBQVVDO0FBQzlCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDLFNBQVNySCxRQUFRLEVBQUVzSCxpQkFBaUIsQ0FBQztJQUM1QyxNQUFNcEssUUFBUTZKO0lBQ2QsTUFBTVgsWUFBWWxKLE1BQU05TCxRQUFRLEdBQUd1SixRQUFRLENBQUN5TCxTQUFTO0lBQ3JELGNBQWM7SUFDZCxNQUFNelQsTUFBTUYsbUJBQW1CdU47SUFDL0IsNkNBQTZDO0lBQzdDak87OENBQTBCLElBQU1xVSxVQUFVelQsS0FBSzJVLGdCQUFnQnBLOzZDQUFRO1FBQUNvSztRQUFnQmxCO1FBQVdsSjtLQUFNO0lBQ3pHLE9BQU87QUFDVDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNxSyxTQUFTalIsTUFBTTtJQUN0QixPQUFPMUcsMENBQWE7NEJBQUMsSUFBTXlHLFdBQVdDOzJCQUFTO1FBQUNBO0tBQU87QUFDekQ7QUFDQSxNQUFNa1Isa0JBQWtCLElBQUlDO0FBQzVCLE1BQU1DLGtCQUFrQjdWLENBQUFBO0lBQ3RCLElBQUk4VjtJQUNKLE9BQU8sT0FBTzlWLFVBQVUsY0FBYyxDQUFDQSxTQUFTLE9BQU8sS0FBSyxJQUFJLENBQUM4VixtQkFBbUI5VixNQUFNK1YsU0FBUyxLQUFLLE9BQU8sS0FBSyxJQUFJRCxpQkFBaUIsV0FBVyxNQUFNOVY7QUFDNUo7QUFDQSxTQUFTZ1csVUFBVUMsVUFBVSxFQUFFQyxVQUFVO0lBQ3ZDLE9BQU8sU0FBVUMsS0FBSyxFQUFFLEdBQUdDLEtBQUs7UUFDOUIsSUFBSUM7UUFFSix1REFBdUQ7UUFDdkQsSUFBSVIsZ0JBQWdCTSxRQUFRO1lBQzFCRSxTQUFTVixnQkFBZ0J4TyxHQUFHLENBQUNnUDtZQUM3QixJQUFJLENBQUNFLFFBQVE7Z0JBQ1hBLFNBQVMsSUFBSUY7Z0JBQ2JSLGdCQUFnQi9ULEdBQUcsQ0FBQ3VVLE9BQU9FO1lBQzdCO1FBQ0YsT0FBTztZQUNMQSxTQUFTRjtRQUNYO1FBRUEsMEJBQTBCO1FBQzFCLElBQUlGLFlBQVlBLFdBQVdJO1FBRTNCLG9DQUFvQztRQUNwQyxPQUFPeFUsUUFBUXlVLEdBQUcsQ0FBQ0YsTUFBTTFGLEdBQUcsQ0FBQzBGLENBQUFBLFFBQVMsSUFBSXZVLFFBQVEsQ0FBQzBVLEtBQUtDLFNBQVdILE9BQU9JLElBQUksQ0FBQ0wsT0FBTzFSLENBQUFBO29CQUNwRixJQUFJcUUsV0FBV3JFLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtpTyxLQUFLLEdBQUcxVCxPQUFPeVgsTUFBTSxDQUFDaFMsTUFBTUYsV0FBV0UsS0FBS2lPLEtBQUs7b0JBQzdGNEQsSUFBSTdSO2dCQUNOLEdBQUd3UixZQUFZL1QsQ0FBQUEsUUFBU3FVLE9BQU8sSUFBSXBCLE1BQU0sQ0FBQyxlQUFlLEVBQUVnQixNQUFNLEVBQUUsRUFBRWpVLFNBQVMsT0FBTyxLQUFLLElBQUlBLE1BQU13VSxPQUFPLEVBQUU7SUFDL0c7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0MsVUFBVVAsTUFBTSxFQUFFRCxLQUFLLEVBQUVILFVBQVUsRUFBRUMsVUFBVTtJQUN0RCxvQ0FBb0M7SUFDcEMsTUFBTTNSLE9BQU96QixNQUFNQyxPQUFPLENBQUNxVCxTQUFTQSxRQUFRO1FBQUNBO0tBQU07SUFDbkQsTUFBTVMsVUFBVXJZLHNEQUFPQSxDQUFDd1gsVUFBVUMsWUFBWUMsYUFBYTtRQUFDRztXQUFXOVI7S0FBSyxFQUFFO1FBQzVFdVMsT0FBT3hULEdBQUdTLEdBQUc7SUFDZjtJQUNBLHVCQUF1QjtJQUN2QixPQUFPakIsTUFBTUMsT0FBTyxDQUFDcVQsU0FBU1MsVUFBVUEsT0FBTyxDQUFDLEVBQUU7QUFDcEQ7QUFFQTs7Q0FFQyxHQUNERCxVQUFVblksT0FBTyxHQUFHLFNBQVU0WCxNQUFNLEVBQUVELEtBQUssRUFBRUgsVUFBVTtJQUNyRCxNQUFNMVIsT0FBT3pCLE1BQU1DLE9BQU8sQ0FBQ3FULFNBQVNBLFFBQVE7UUFBQ0E7S0FBTTtJQUNuRCxPQUFPM1gsc0RBQU9BLENBQUN1WCxVQUFVQyxhQUFhO1FBQUNJO1dBQVc5UjtLQUFLO0FBQ3pEO0FBRUE7O0NBRUMsR0FDRHFTLFVBQVVsWSxLQUFLLEdBQUcsU0FBVTJYLE1BQU0sRUFBRUQsS0FBSztJQUN2QyxNQUFNN1IsT0FBT3pCLE1BQU1DLE9BQU8sQ0FBQ3FULFNBQVNBLFFBQVE7UUFBQ0E7S0FBTTtJQUNuRCxPQUFPMVgsb0RBQUtBLENBQUM7UUFBQzJYO1dBQVc5UjtLQUFLO0FBQ2hDO0FBRUEsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUVqRCxTQUFTd1MsaUJBQWlCQyxNQUFNO0lBQzlCLE1BQU1DLGFBQWE1WSx1REFBVUEsQ0FBQzJZO0lBQzlCQyxXQUFXQyxrQkFBa0IsQ0FBQztRQUM1QkMsWUFBWSxPQUFPQyxZQUFZLGVBQWVBLGtCQUF5QixlQUFlLElBQUk7UUFDMUZDLHFCQUFxQjtRQUNyQkMsU0FBU3ZaLDBDQUFhO0lBQ3hCO0lBQ0EsT0FBT2taO0FBQ1Q7QUFDQSxNQUFNTSxrQkFBa0I7QUFFeEIscUNBQXFDO0FBQ3JDLHdEQUF3RDtBQUN4RCx1REFBdUQ7QUFFdkQsTUFBTUMsWUFBWSxDQUFDO0FBQ25CLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsZUFBZWxXLENBQUFBLE9BQVEsR0FBR0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ21XLFdBQVcsS0FBS25XLEtBQUttTyxLQUFLLENBQUMsSUFBSTtBQUN2RSxJQUFJdEwsSUFBSTtBQUNSLE1BQU11VCxnQkFBZ0JuVCxDQUFBQSxTQUFVLE9BQU9BLFdBQVc7QUFDbEQsU0FBU29ULE9BQU8zVCxPQUFPO0lBQ3JCLElBQUkwVCxjQUFjMVQsVUFBVTtRQUMxQixNQUFNbEMsWUFBWSxHQUFHcUMsS0FBSztRQUMxQm1ULFNBQVMsQ0FBQ3hWLFVBQVUsR0FBR2tDO1FBQ3ZCLE9BQU9sQztJQUNULE9BQU87UUFDTC9DLE9BQU95WCxNQUFNLENBQUNjLFdBQVd0VDtJQUMzQjtBQUNGO0FBQ0EsU0FBUzRULGlCQUFpQnRXLElBQUksRUFBRWMsS0FBSztJQUNuQyw0QkFBNEI7SUFDNUIsTUFBTXdDLE9BQU8sR0FBR3RELElBQUksQ0FBQyxFQUFFLENBQUNtVyxXQUFXLEtBQUtuVyxLQUFLbU8sS0FBSyxDQUFDLElBQUk7SUFDdkQsTUFBTS9NLFNBQVM0VSxTQUFTLENBQUMxUyxLQUFLO0lBRTlCLDBCQUEwQjtJQUMxQixJQUFJdEQsU0FBUyxlQUFlLENBQUNvQixRQUFRLE1BQU0sSUFBSXdTLE1BQU0sQ0FBQyxLQUFLLEVBQUV0USxLQUFLLDRKQUE0SixDQUFDO0lBRS9OLHNCQUFzQjtJQUN0QixJQUFJdEQsU0FBUyxlQUFlLENBQUNjLE1BQU1tQyxNQUFNLEVBQUUsTUFBTSxJQUFJMlEsTUFBTSxDQUFDLDZDQUE2QyxDQUFDO0lBRTFHLG9EQUFvRDtJQUNwRCxJQUFJOVMsTUFBTUwsSUFBSSxLQUFLNEUsYUFBYSxDQUFDL0QsTUFBTUMsT0FBTyxDQUFDVCxNQUFNTCxJQUFJLEdBQUcsTUFBTSxJQUFJbVQsTUFBTTtBQUM5RTtBQUNBLFNBQVMyQyxlQUFldlcsSUFBSSxFQUFFYyxLQUFLLEVBQUVoRCxJQUFJO0lBQ3ZDLElBQUkwWTtJQUNKLHFDQUFxQztJQUNyQ3hXLE9BQU9BLEtBQUtpRixPQUFPLENBQUNnUixjQUFjO0lBQ2xDSyxpQkFBaUJ0VyxNQUFNYztJQUV2QixzRUFBc0U7SUFDdEUsSUFBSWQsU0FBUyxlQUFlLENBQUN3VyxnQkFBZ0IxVixNQUFNbUMsTUFBTSxLQUFLLFFBQVF1VCxjQUFjM1UsS0FBSyxFQUFFLE9BQU9mLE1BQU1tQyxNQUFNLENBQUNwQixLQUFLO0lBQ3BILE9BQU9tQyxRQUFRbEQsTUFBTW1DLE1BQU0sRUFBRW5GLE1BQU1rQyxNQUFNYztBQUMzQztBQUNBLFNBQVMyVixhQUFhNVksUUFBUTtJQUM1QixJQUFJLENBQUNBLFNBQVN1RyxRQUFRLEVBQUU7UUFDdEIsSUFBSXNTO1FBQ0osSUFBSTdZLFNBQVNpRCxLQUFLLENBQUMrRCxNQUFNLElBQUksQ0FBQzZSLG1CQUFtQjdZLFNBQVNvRyxNQUFNLEtBQUssUUFBUXlTLGlCQUFpQnpULE1BQU0sRUFBRTtZQUNwR2tDLE9BQU90SCxTQUFTb0csTUFBTSxFQUFFcEc7UUFDMUIsT0FBTyxJQUFJMEosV0FBVzFKLFNBQVNvRixNQUFNLEdBQUc7WUFDdENwRixTQUFTb0YsTUFBTSxDQUFDMFQsT0FBTyxHQUFHO1FBQzVCO1FBQ0E5WSxTQUFTdUcsUUFBUSxHQUFHO1FBQ3BCMkQsbUJBQW1CbEs7SUFDckI7QUFDRjtBQUNBLFNBQVMrWSxlQUFlL1ksUUFBUTtJQUM5QixJQUFJQSxTQUFTdUcsUUFBUSxFQUFFO1FBQ3JCLElBQUl5UztRQUNKLElBQUloWixTQUFTaUQsS0FBSyxDQUFDK0QsTUFBTSxJQUFJLENBQUNnUyxvQkFBb0JoWixTQUFTb0csTUFBTSxLQUFLLFFBQVE0UyxrQkFBa0I1VCxNQUFNLEVBQUU7WUFDdEc0QixPQUFPaEgsU0FBU29HLE1BQU0sRUFBRXBHO1FBQzFCLE9BQU8sSUFBSTBKLFdBQVcxSixTQUFTb0YsTUFBTSxLQUFLcEYsU0FBU2lELEtBQUssQ0FBQzZWLE9BQU8sS0FBSyxPQUFPO1lBQzFFOVksU0FBU29GLE1BQU0sQ0FBQzBULE9BQU8sR0FBRztRQUM1QjtRQUNBOVksU0FBU3VHLFFBQVEsR0FBRztRQUNwQjJELG1CQUFtQmxLO0lBQ3JCO0FBQ0Y7QUFFQSxpREFBaUQ7QUFDakQsc0ZBQXNGO0FBQ3RGLFNBQVNpWix1QkFBdUI3UyxNQUFNLEVBQUVhLEtBQUssRUFBRWlTLFdBQVc7SUFDeEQsMkRBQTJEO0lBQzNELHNGQUFzRjtJQUN0RixNQUFNclcsUUFBUW9FLE1BQU1oSCxJQUFJLENBQUNDLFFBQVE7SUFDakMsSUFBSSxDQUFDa0csT0FBT0EsTUFBTSxJQUFJQSxPQUFPaEIsTUFBTSxLQUFLdkMsTUFBTXlRLEtBQUssRUFBRTtJQUVyRCxvQ0FBb0M7SUFDcEMsSUFBSSxDQUFDck0sTUFBTTdCLE1BQU0sRUFBRTtRQUNqQixJQUFJK1QscUJBQXFCQztRQUN6Qiw0QkFBNEI7UUFDNUIsTUFBTTdWLFNBQVM0VSxTQUFTLENBQUNFLGFBQWFwUixNQUFNOUUsSUFBSSxFQUFFO1FBRWxELGdCQUFnQjtRQUNoQjhFLE1BQU03QixNQUFNLEdBQUcsQ0FBQytULHNCQUFzQmxTLE1BQU1oRSxLQUFLLENBQUNtQyxNQUFNLEtBQUssT0FBTytULHNCQUFzQixJQUFJNVYsVUFBVyxDQUFDNlYsb0JBQW9CblMsTUFBTWhFLEtBQUssQ0FBQ0wsSUFBSSxLQUFLLE9BQU93VyxvQkFBb0IsRUFBRTtRQUNoTG5TLE1BQU03QixNQUFNLENBQUNwQixLQUFLLEdBQUdpRDtJQUN2QjtJQUVBLG9CQUFvQjtJQUNwQnNCLFdBQVd0QixNQUFNN0IsTUFBTSxFQUFFNkIsTUFBTWhFLEtBQUs7SUFFcEMsa0JBQWtCO0lBQ2xCLElBQUlnRSxNQUFNaEUsS0FBSyxDQUFDK0QsTUFBTSxFQUFFO1FBQ3RCQSxPQUFPWixRQUFRYTtJQUNqQixPQUFPLElBQUl5QyxXQUFXekMsTUFBTTdCLE1BQU0sS0FBS3NFLFdBQVd0RCxPQUFPaEIsTUFBTSxHQUFHO1FBQ2hFLE1BQU1pVSxhQUFhalQsT0FBT2hCLE1BQU0sQ0FBQ3BELFFBQVEsQ0FBQzRILE9BQU8sQ0FBQ3NQLGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVk5VCxNQUFNO1FBQ25HLElBQUk4VCxlQUFlRyxlQUFlLENBQUMsR0FBRztZQUNwQ3BTLE1BQU03QixNQUFNLENBQUNnQixNQUFNLEdBQUdBLE9BQU9oQixNQUFNO1lBQ25DZ0IsT0FBT2hCLE1BQU0sQ0FBQ3BELFFBQVEsQ0FBQzZILE1BQU0sQ0FBQ3dQLFlBQVksR0FBR3BTLE1BQU03QixNQUFNO1lBQ3pENkIsTUFBTTdCLE1BQU0sQ0FBQ2tVLGFBQWEsQ0FBQztnQkFDekJuWCxNQUFNO1lBQ1I7WUFDQWlFLE9BQU9oQixNQUFNLENBQUNrVSxhQUFhLENBQUM7Z0JBQzFCblgsTUFBTTtnQkFDTjhFLE9BQU9BLE1BQU03QixNQUFNO1lBQ3JCO1FBQ0YsT0FBTztZQUNMZ0IsT0FBT2hCLE1BQU0sQ0FBQ21KLEdBQUcsQ0FBQ3RILE1BQU03QixNQUFNO1FBQ2hDO0lBQ0Y7SUFFQSxlQUFlO0lBQ2YsS0FBSyxNQUFNbVUsaUJBQWlCdFMsTUFBTWpGLFFBQVEsQ0FBRWlYLHVCQUF1QmhTLE9BQU9zUztJQUUxRSxvQ0FBb0M7SUFDcENyUCxtQkFBbUJqRDtBQUNyQjtBQUNBLFNBQVN1UyxZQUFZcFQsTUFBTSxFQUFFYSxLQUFLO0lBQ2hDLElBQUksQ0FBQ0EsT0FBTztJQUVaLGlCQUFpQjtJQUNqQkEsTUFBTWIsTUFBTSxHQUFHQTtJQUNmQSxPQUFPcEUsUUFBUSxDQUFDK0gsSUFBSSxDQUFDOUM7SUFFckIsNEJBQTRCO0lBQzVCZ1MsdUJBQXVCN1MsUUFBUWE7QUFDakM7QUFDQSxTQUFTd1MsYUFBYXJULE1BQU0sRUFBRWEsS0FBSyxFQUFFaVMsV0FBVztJQUM5QyxJQUFJLENBQUNqUyxTQUFTLENBQUNpUyxhQUFhO0lBRTVCLGlCQUFpQjtJQUNqQmpTLE1BQU1iLE1BQU0sR0FBR0E7SUFDZixNQUFNaVQsYUFBYWpULE9BQU9wRSxRQUFRLENBQUM0SCxPQUFPLENBQUNzUDtJQUMzQyxJQUFJRyxlQUFlLENBQUMsR0FBR2pULE9BQU9wRSxRQUFRLENBQUM2SCxNQUFNLENBQUN3UCxZQUFZLEdBQUdwUztTQUFZYixPQUFPcEUsUUFBUSxDQUFDK0gsSUFBSSxDQUFDOUM7SUFFOUYsNEJBQTRCO0lBQzVCZ1MsdUJBQXVCN1MsUUFBUWEsT0FBT2lTO0FBQ3hDO0FBQ0EsU0FBU1EsY0FBY3RVLE1BQU07SUFDM0IsSUFBSSxPQUFPQSxPQUFPTyxPQUFPLEtBQUssWUFBWTtRQUN4QyxNQUFNZ1UsZ0JBQWdCO1lBQ3BCLElBQUk7Z0JBQ0Z2VSxPQUFPTyxPQUFPO1lBQ2hCLEVBQUUsT0FBTTtZQUNOLFFBQVE7WUFDVjtRQUNGO1FBRUEsZ0RBQWdEO1FBQ2hELElBQUksT0FBT2lVLDZCQUE2QixhQUFhRDthQUVoRDFhLG9FQUF5QkEsQ0FBQ0MsNERBQXFCQSxFQUFFeWE7SUFDeEQ7QUFDRjtBQUNBLFNBQVNFLFlBQVl6VCxNQUFNLEVBQUVhLEtBQUssRUFBRXRCLE9BQU87SUFDekMsSUFBSSxDQUFDc0IsT0FBTztJQUVaLG1CQUFtQjtJQUNuQkEsTUFBTWIsTUFBTSxHQUFHO0lBQ2YsTUFBTWlULGFBQWFqVCxPQUFPcEUsUUFBUSxDQUFDNEgsT0FBTyxDQUFDM0M7SUFDM0MsSUFBSW9TLGVBQWUsQ0FBQyxHQUFHalQsT0FBT3BFLFFBQVEsQ0FBQzZILE1BQU0sQ0FBQ3dQLFlBQVk7SUFFMUQseUJBQXlCO0lBQ3pCLElBQUlwUyxNQUFNaEUsS0FBSyxDQUFDK0QsTUFBTSxFQUFFO1FBQ3RCTSxPQUFPbEIsUUFBUWE7SUFDakIsT0FBTyxJQUFJeUMsV0FBV3pDLE1BQU03QixNQUFNLEtBQUtzRSxXQUFXdEQsT0FBT2hCLE1BQU0sR0FBRztRQUNoRWdCLE9BQU9oQixNQUFNLENBQUMwVSxNQUFNLENBQUM3UyxNQUFNN0IsTUFBTTtRQUNqQzJHLG9CQUFvQmhNLGdCQUFnQmtILFFBQVFBLE1BQU03QixNQUFNO0lBQzFEO0lBRUEsb0VBQW9FO0lBQ3BFLE1BQU0yVSxnQkFBZ0I5UyxNQUFNaEUsS0FBSyxDQUFDMEMsT0FBTyxLQUFLLFFBQVFBLFlBQVk7SUFFbEUsdUNBQXVDO0lBQ3ZDLElBQUssSUFBSVgsSUFBSWlDLE1BQU1qRixRQUFRLENBQUNpRCxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxJQUFLO1FBQ25ELE1BQU05QyxPQUFPK0UsTUFBTWpGLFFBQVEsQ0FBQ2dELEVBQUU7UUFDOUI2VSxZQUFZNVMsT0FBTy9FLE1BQU02WDtJQUMzQjtJQUNBOVMsTUFBTWpGLFFBQVEsQ0FBQ2lELE1BQU0sR0FBRztJQUV4Qix5QkFBeUI7SUFDekIsT0FBT2dDLE1BQU03QixNQUFNLENBQUNwQixLQUFLO0lBRXpCLHdEQUF3RDtJQUN4RCxnRkFBZ0Y7SUFDaEYsa0RBQWtEO0lBQ2xELDJCQUEyQjtJQUMzQiw2Q0FBNkM7SUFDN0Msb0VBQW9FO0lBQ3BFLElBQUkrVixpQkFBaUI5UyxNQUFNOUUsSUFBSSxLQUFLLGVBQWU4RSxNQUFNN0IsTUFBTSxDQUFDakQsSUFBSSxLQUFLLFNBQVM7UUFDaEZ1WCxjQUFjelMsTUFBTTdCLE1BQU07SUFDNUI7SUFFQSwyREFBMkQ7SUFDM0QsSUFBSU8sWUFBWTZCLFdBQVcwQyxtQkFBbUJqRDtBQUNoRDtBQUNBLFNBQVMrUyxZQUFZblksS0FBSyxFQUFFb1ksY0FBYztJQUN4QyxLQUFLLE1BQU1DLFVBQVU7UUFBQ3JZO1FBQU9BLE1BQU1zWSxTQUFTO0tBQUMsQ0FBRTtRQUM3QyxJQUFJRCxXQUFXLE1BQU07WUFDbkIsSUFBSSxPQUFPQSxPQUFPelksR0FBRyxLQUFLLFlBQVk7Z0JBQ3BDeVksT0FBT0UsVUFBVSxJQUFJLE9BQU8sS0FBSyxJQUFJRixPQUFPRSxVQUFVO2dCQUN0RCxNQUFNQyxVQUFVSCxPQUFPelksR0FBRyxDQUFDd1k7Z0JBQzNCLElBQUksT0FBT0ksWUFBWSxZQUFZSCxPQUFPRSxVQUFVLEdBQUdDO1lBQ3pELE9BQU8sSUFBSUgsT0FBT3pZLEdBQUcsRUFBRTtnQkFDckJ5WSxPQUFPelksR0FBRyxDQUFDRSxPQUFPLEdBQUdzWTtZQUN2QjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLE1BQU1LLGdCQUFnQixFQUFFO0FBQ3hCLFNBQVNDO0lBQ1Asa0JBQWtCO0lBQ2xCLEtBQUssTUFBTSxDQUFDdmEsU0FBUyxJQUFJc2EsY0FBZTtRQUN0QyxNQUFNbFUsU0FBU3BHLFNBQVNvRyxNQUFNO1FBQzlCLElBQUlBLFFBQVE7WUFDVixJQUFJcEcsU0FBU2lELEtBQUssQ0FBQytELE1BQU0sRUFBRTtnQkFDekJNLE9BQU9sQixRQUFRcEc7WUFDakIsT0FBTyxJQUFJMEosV0FBVzFKLFNBQVNvRixNQUFNLEtBQUtzRSxXQUFXdEQsT0FBT2hCLE1BQU0sR0FBRztnQkFDbkVnQixPQUFPaEIsTUFBTSxDQUFDMFUsTUFBTSxDQUFDOVosU0FBU29GLE1BQU07WUFDdEM7WUFDQSxLQUFLLE1BQU02QixTQUFTakgsU0FBU2dDLFFBQVEsQ0FBRTtnQkFDckMsSUFBSWlGLE1BQU1oRSxLQUFLLENBQUMrRCxNQUFNLEVBQUU7b0JBQ3RCTSxPQUFPdEgsVUFBVWlIO2dCQUNuQixPQUFPLElBQUl5QyxXQUFXekMsTUFBTTdCLE1BQU0sS0FBS3NFLFdBQVcxSixTQUFTb0YsTUFBTSxHQUFHO29CQUNsRXBGLFNBQVNvRixNQUFNLENBQUMwVSxNQUFNLENBQUM3UyxNQUFNN0IsTUFBTTtnQkFDckM7WUFDRjtRQUNGO1FBRUEsdURBQXVEO1FBQ3ZELHFFQUFxRTtRQUNyRSx3RUFBd0U7UUFDeEUsaUVBQWlFO1FBQ2pFLElBQUlwRixTQUFTdUcsUUFBUSxFQUFFd1MsZUFBZS9ZO1FBRXRDLGdDQUFnQztRQUNoQyxJQUFJQSxTQUFTb0YsTUFBTSxDQUFDcEIsS0FBSyxFQUFFLE9BQU9oRSxTQUFTb0YsTUFBTSxDQUFDcEIsS0FBSztRQUN2RCxJQUFJaEUsU0FBU21DLElBQUksS0FBSyxhQUFhdVgsY0FBYzFaLFNBQVNvRixNQUFNO0lBQ2xFO0lBRUEsa0JBQWtCO0lBQ2xCLEtBQUssTUFBTSxDQUFDcEYsVUFBVWlELE9BQU9wQixNQUFNLElBQUl5WSxjQUFlO1FBQ3BEdGEsU0FBU2lELEtBQUssR0FBR0E7UUFDakIsTUFBTW1ELFNBQVNwRyxTQUFTb0csTUFBTTtRQUM5QixJQUFJQSxRQUFRO1lBQ1YsSUFBSW9VLHVCQUF1QkM7WUFDM0IsNEJBQTRCO1lBQzVCLE1BQU1sWCxTQUFTNFUsU0FBUyxDQUFDRSxhQUFhclksU0FBU21DLElBQUksRUFBRTtZQUVyRCxnQkFBZ0I7WUFDaEJuQyxTQUFTb0YsTUFBTSxHQUFHLENBQUNvVix3QkFBd0J4YSxTQUFTaUQsS0FBSyxDQUFDbUMsTUFBTSxLQUFLLE9BQU9vVix3QkFBd0IsSUFBSWpYLFVBQVcsQ0FBQ2tYLHVCQUF1QnphLFNBQVNpRCxLQUFLLENBQUNMLElBQUksS0FBSyxPQUFPNlgsdUJBQXVCLEVBQUU7WUFDbk16YSxTQUFTb0YsTUFBTSxDQUFDcEIsS0FBSyxHQUFHaEU7WUFDeEJnYSxZQUFZblksT0FBTzdCLFNBQVNvRixNQUFNO1lBRWxDLG9CQUFvQjtZQUNwQm1ELFdBQVd2SSxTQUFTb0YsTUFBTSxFQUFFcEYsU0FBU2lELEtBQUs7WUFDMUMsSUFBSWpELFNBQVNpRCxLQUFLLENBQUMrRCxNQUFNLEVBQUU7Z0JBQ3pCQSxPQUFPWixRQUFRcEc7WUFDakIsT0FBTyxJQUFJMEosV0FBVzFKLFNBQVNvRixNQUFNLEtBQUtzRSxXQUFXdEQsT0FBT2hCLE1BQU0sR0FBRztnQkFDbkVnQixPQUFPaEIsTUFBTSxDQUFDbUosR0FBRyxDQUFDdk8sU0FBU29GLE1BQU07WUFDbkM7WUFDQSxLQUFLLE1BQU02QixTQUFTakgsU0FBU2dDLFFBQVEsQ0FBRTtnQkFDckMsSUFBSWlGLE1BQU1oRSxLQUFLLENBQUMrRCxNQUFNLEVBQUU7b0JBQ3RCQSxPQUFPaEgsVUFBVWlIO2dCQUNuQixPQUFPLElBQUl5QyxXQUFXekMsTUFBTTdCLE1BQU0sS0FBS3NFLFdBQVcxSixTQUFTb0YsTUFBTSxHQUFHO29CQUNsRXBGLFNBQVNvRixNQUFNLENBQUNtSixHQUFHLENBQUN0SCxNQUFNN0IsTUFBTTtnQkFDbEM7WUFDRjtZQUVBLG9DQUFvQztZQUNwQzhFLG1CQUFtQmxLO1FBQ3JCO0lBQ0Y7SUFDQXNhLGNBQWNyVixNQUFNLEdBQUc7QUFDekI7QUFFQSw2Q0FBNkM7QUFDN0MsTUFBTXlWLHFCQUFxQixLQUFPO0FBQ2xDLE1BQU1DLGFBQWEsQ0FBQztBQUNwQixJQUFJQyx3QkFBd0IxQztBQUU1QiwrRkFBK0Y7QUFDL0YsTUFBTTJDLFVBQVU7QUFDaEIsTUFBTUMsU0FBUztBQUNmLE1BQU1sRCxhQUFhLGFBQWEsR0FBRUYsaUJBQWlCO0lBQ2pEcUQsbUJBQW1CO0lBQ25CQyxrQkFBa0I7SUFDbEJDLGtCQUFrQjtJQUNsQkMscUJBQXFCO0lBQ3JCQyxtQkFBbUI7SUFDbkJ6QztJQUNBbUI7SUFDQUw7SUFDQTRCLG9CQUFvQjVCO0lBQ3BCQztJQUNBNEIsd0JBQXVCQyxTQUFTLEVBQUVyVSxLQUFLO1FBQ3JDLE1BQU1xTSxRQUFRZ0ksVUFBVXBiLFFBQVEsR0FBR29ULEtBQUssQ0FBQ3RQLEtBQUs7UUFDOUMsSUFBSSxDQUFDaUQsU0FBUyxDQUFDcU0sT0FBTztRQUN0QmtHLFlBQVlsRyxPQUFPck07SUFDckI7SUFDQXNVLDBCQUF5QkQsU0FBUyxFQUFFclUsS0FBSztRQUN2QyxNQUFNcU0sUUFBUWdJLFVBQVVwYixRQUFRLEdBQUdvVCxLQUFLLENBQUN0UCxLQUFLO1FBQzlDLElBQUksQ0FBQ2lELFNBQVMsQ0FBQ3FNLE9BQU87UUFDdEJ1RyxZQUFZdkcsT0FBT3JNO0lBQ3JCO0lBQ0F1VSx5QkFBd0JGLFNBQVMsRUFBRXJVLEtBQUssRUFBRWlTLFdBQVc7UUFDbkQsTUFBTTVGLFFBQVFnSSxVQUFVcGIsUUFBUSxHQUFHb1QsS0FBSyxDQUFDdFAsS0FBSztRQUM5QyxJQUFJLENBQUNpRCxTQUFTLENBQUNpUyxlQUFlLENBQUM1RixPQUFPO1FBQ3RDbUcsYUFBYW5HLE9BQU9yTSxPQUFPaVM7SUFDN0I7SUFDQXVDLG9CQUFvQixJQUFNZDtJQUMxQmUscUJBQXFCLElBQU1mO0lBQzNCZ0IsY0FBYTNiLFFBQVEsRUFBRW1DLElBQUksRUFBRXlaLFFBQVEsRUFBRTNULFFBQVEsRUFBRXBHLEtBQUs7UUFDcEQsSUFBSWdhLGdCQUFnQkMsZ0JBQWdCQztRQUNwQ3RELGlCQUFpQnRXLE1BQU04RjtRQUN2QixJQUFJK1QsY0FBYztRQUVsQixnREFBZ0Q7UUFDaEQsSUFBSWhjLFNBQVNtQyxJQUFJLEtBQUssZUFBZXlaLFNBQVN4VyxNQUFNLEtBQUs2QyxTQUFTN0MsTUFBTSxFQUFFNFcsY0FBYzthQUVuRixJQUFJLENBQUMsQ0FBQ0gsaUJBQWlCNVQsU0FBU3JGLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSWlaLGVBQWU1VyxNQUFNLE1BQU8sRUFBQzZXLGlCQUFpQkYsU0FBU2haLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSWtaLGVBQWU3VyxNQUFNLEdBQUcrVyxjQUFjO2FBRS9LLElBQUksQ0FBQ0Qsa0JBQWtCOVQsU0FBU3JGLElBQUksS0FBSyxRQUFRbVosZ0JBQWdCL08sSUFBSSxDQUFDLENBQUNyTSxPQUFPd0c7WUFDakYsSUFBSThVO1lBQ0osT0FBT3RiLFVBQVcsRUFBQ3NiLGtCQUFrQkwsU0FBU2haLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSXFaLGVBQWUsQ0FBQzlVLE1BQU07UUFDL0YsSUFBSTZVLGNBQWM7UUFFbEIsZ0VBQWdFO1FBQ2hFLElBQUlBLGFBQWE7WUFDZjFCLGNBQWN2USxJQUFJLENBQUM7Z0JBQUMvSjtnQkFBVTtvQkFDNUIsR0FBR2lJLFFBQVE7Z0JBQ2I7Z0JBQUdwRzthQUFNO1FBQ1gsT0FBTztZQUNMLG1EQUFtRDtZQUNuRCxNQUFNcUcsZUFBZUYsVUFBVWhJLFVBQVVpSTtZQUN6QyxJQUFJckksT0FBT3NGLElBQUksQ0FBQ2dELGNBQWNqRCxNQUFNLEVBQUU7Z0JBQ3BDckYsT0FBT3lYLE1BQU0sQ0FBQ3JYLFNBQVNpRCxLQUFLLEVBQUVpRjtnQkFDOUJLLFdBQVd2SSxTQUFTb0YsTUFBTSxFQUFFOEM7WUFDOUI7UUFDRjtRQUVBLGdGQUFnRjtRQUNoRixNQUFNZ1UsZ0JBQWdCcmEsTUFBTXNhLE9BQU8sS0FBSyxRQUFRLENBQUN0YSxNQUFNdWEsS0FBSyxHQUFHdEIsTUFBSyxNQUFPRDtRQUMzRSxJQUFJcUIsZUFBZTNCO0lBQ3JCO0lBQ0E4Qix5QkFBeUIsSUFBTTtJQUMvQkMsZ0JBQWU7SUFDZkMsbUJBQW1CdmMsQ0FBQUEsV0FBWUEsWUFBWSxPQUFPLEtBQUssSUFBSUEsU0FBU29GLE1BQU07SUFDMUVvWCxrQkFBa0IsSUFBTTtJQUN4QkMsb0JBQW9CbkIsQ0FBQUEsWUFBYW5WLFFBQVFtVixVQUFVcGIsUUFBUSxHQUFHb1QsS0FBSyxFQUFFZ0ksV0FBVyxJQUFJLENBQUM7SUFDckZvQixrQkFBa0IsS0FBTztJQUN6QkMsc0JBQXNCLElBQU07SUFDNUJDLGdCQUFnQixJQUFNO0lBQ3RCaEU7SUFDQUc7SUFDQThELG9CQUFvQm5DO0lBQ3BCb0Msa0JBQWtCcEM7SUFDbEJxQyxvQkFBb0JyQztJQUNwQnNDLGlCQUFpQixPQUFPNUksZUFBZSxhQUFhQSxhQUFhNU07SUFDakV5VixlQUFlLE9BQU85SSxpQkFBaUIsYUFBYUEsZUFBZTNNO0lBQ25FMFYsV0FBVyxDQUFDO0lBQ1pDLHFCQUFxQixJQUFNO0lBQzNCQyw2QkFBNEI7SUFDNUJDLDRCQUEyQjtJQUMzQkMsMEJBQXlCO0lBQ3pCQyx1QkFBc0I7SUFDdEJDLHNCQUFzQixJQUFNO0lBQzVCQyw4QkFBOEIsSUFBTTtJQUNwQ0MscUJBQXFCLEtBQU87SUFDNUJDLGtCQUFrQixJQUFNO0lBQ3hCQyx1QkFBdUIsSUFBTSxDQUFDO0lBQzlCQyw2QkFBNEI7SUFDNUJDLGtCQUFrQixJQUFNO0lBQ3hCQyxpQkFBaUIsSUFBTTtJQUN2QixnQ0FBZ0M7SUFDaENDLDBCQUF5QjtJQUN6QkMsb0JBQW1CO0lBQ25CQyx3QkFBd0IsSUFBTTtJQUM5QkMsc0JBQXNCO0lBQ3RCQyx1QkFBdUIsYUFBYSxpQkFBRTFmLGdEQUFtQixDQUFDO0lBQzFEMmYsMEJBQXlCQyxXQUFXO1FBQ2xDMUQsd0JBQXdCMEQ7SUFDMUI7SUFDQUM7UUFDRSxPQUFPM0Q7SUFDVDtJQUNBNEQ7UUFDRSxJQUFJQztRQUNKLElBQUk3RCwwQkFBMEIxQyxpQkFBaUIsT0FBTzBDO1FBQ3RELE9BQVEsTUFBNkIsSUFBSyxFQUFvRTtZQUM1RyxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTy9iLDZFQUFxQkE7WUFDOUIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU9ELCtFQUF1QkE7WUFDaEM7Z0JBQ0UsT0FBT0QsNEVBQW9CQTtRQUMvQjtJQUNGO0lBQ0ErZixzQkFBcUI7QUFDdkI7QUFFQSxNQUFNQyxTQUFTLElBQUloWDtBQUNuQixNQUFNaVgsZUFBZTtJQUNuQi9aLFNBQVM7SUFDVDVDLFFBQVE7QUFDVjtBQUNBLFNBQVM0YyxtQkFBbUJDLE1BQU0sRUFBRXJVLElBQUk7SUFDdEMsSUFBSSxDQUFDQSxRQUFRLE9BQU9nTCxzQkFBc0IsZUFBZXFKLGtCQUFrQnJKLHFCQUFxQnFKLE9BQU9DLGFBQWEsRUFBRTtRQUNwSCxNQUFNLEVBQ0puVSxLQUFLLEVBQ0xHLE1BQU0sRUFDTkQsR0FBRyxFQUNISCxJQUFJLEVBQ0wsR0FBR21VLE9BQU9DLGFBQWEsQ0FBQ0MscUJBQXFCO1FBQzlDLE9BQU87WUFDTHBVO1lBQ0FHO1lBQ0FEO1lBQ0FIO1FBQ0Y7SUFDRixPQUFPLElBQUksQ0FBQ0YsUUFBUSxPQUFPd1Usb0JBQW9CLGVBQWVILGtCQUFrQkcsaUJBQWlCO1FBQy9GLE9BQU87WUFDTHJVLE9BQU9rVSxPQUFPbFUsS0FBSztZQUNuQkcsUUFBUStULE9BQU8vVCxNQUFNO1lBQ3JCRCxLQUFLO1lBQ0xILE1BQU07UUFDUjtJQUNGO0lBQ0EsT0FBTztRQUNMQyxPQUFPO1FBQ1BHLFFBQVE7UUFDUkQsS0FBSztRQUNMSCxNQUFNO1FBQ04sR0FBR0YsSUFBSTtJQUNUO0FBQ0Y7QUFDQSxTQUFTeVUsV0FBV0osTUFBTTtJQUN4QiwyQ0FBMkM7SUFDM0MsTUFBTUssV0FBV1IsT0FBTzdXLEdBQUcsQ0FBQ2dYO0lBQzVCLE1BQU1NLFlBQVlELFlBQVksT0FBTyxLQUFLLElBQUlBLFNBQVN0ZCxLQUFLO0lBQzVELE1BQU13ZCxZQUFZRixZQUFZLE9BQU8sS0FBSyxJQUFJQSxTQUFTblQsS0FBSztJQUM1RCxJQUFJbVQsVUFBVUcsUUFBUUMsSUFBSSxDQUFDO0lBRTNCLHlEQUF5RDtJQUN6RCx3REFBd0Q7SUFDeEQsTUFBTUMsc0JBQXNCLE9BQU9DLGdCQUFnQixhQUNuRCxnRUFBZ0U7SUFDaEUsMENBQTBDO0lBQzFDQSxjQUNBLHNFQUFzRTtJQUN0RUgsUUFBUXhjLEtBQUs7SUFFYixlQUFlO0lBQ2YsTUFBTWtKLFFBQVFxVCxhQUFhdE4sWUFBWXpILFlBQVkwSDtJQUNuRCxrQkFBa0I7SUFDbEIsTUFBTW5RLFFBQVF1ZCxhQUFheEgsV0FBVzhILGVBQWUsQ0FBQzFULE9BQ3RELFlBQVk7SUFDWmxOLHNFQUFjQSxFQUNkLE1BQU07SUFDTixNQUNBLHNCQUFzQjtJQUN0QixPQUNBLGVBQWU7SUFDZixNQUNBLHFDQUFxQztJQUNyQyxJQUNBLG1CQUFtQjtJQUNuQjBnQixxQkFDQSxrQkFBa0I7SUFDbEJBLHFCQUNBLGdCQUFnQjtJQUNoQkEscUJBQ0EscUJBQXFCO0lBQ3JCLEtBQUssc0JBQXNCOztJQUUzQixTQUFTO0lBQ1QsSUFBSSxDQUFDTCxVQUFVUixPQUFPcGMsR0FBRyxDQUFDdWMsUUFBUTtRQUNoQ2pkO1FBQ0FtSztJQUNGO0lBRUEsU0FBUztJQUNULElBQUkyVDtJQUNKLElBQUlDO0lBQ0osSUFBSUMsYUFBYTtJQUNqQixJQUFJQyxVQUFVO0lBQ2QsT0FBTztRQUNMLE1BQU1DLFdBQVU5YyxRQUFRLENBQUMsQ0FBQztZQUN4QixJQUFJdUQ7WUFDSnNaLFVBQVUsSUFBSXRkLFFBQVF3ZCxDQUFBQSxXQUFZeFosVUFBVXdaO1lBQzVDLElBQUksRUFDRjVNLElBQUk2TSxRQUFRLEVBQ1p4VixNQUFNeVYsU0FBUyxFQUNmNU0sT0FBTzZNLFlBQVksRUFDbkI1UyxNQUFNLEVBQ05vUyxXQUFXUyxpQkFBaUIsRUFDNUJDLFVBQVUsS0FBSyxFQUNmblgsU0FBUyxLQUFLLEVBQ2R5SyxPQUFPLEtBQUssRUFDWkQsU0FBUyxLQUFLLEVBQ2Q0TSxlQUFlLEtBQUssRUFDcEJ0TSxZQUFZLFFBQVEsRUFDcEIzUSxNQUFNO2dCQUFDO2dCQUFHO2FBQUUsRUFDWjZQLFdBQVcsRUFDWDVGLFdBQVdpVCxjQUFjLEVBQ3pCL1YsUUFBUWdXLGFBQWEsRUFDckIxUCxlQUFlLEVBQ2hCLEdBQUc3TjtZQUNKLElBQUlKLFFBQVFtSixNQUFNOUwsUUFBUTtZQUUxQixtQ0FBbUM7WUFDbkMsSUFBSWtULEtBQUt2USxNQUFNdVEsRUFBRTtZQUNqQixJQUFJLENBQUN2USxNQUFNdVEsRUFBRSxFQUFFO2dCQUNiLE1BQU1xTixlQUFlO29CQUNuQjNCLFFBQVFBO29CQUNSNEIsaUJBQWlCO29CQUNqQkMsV0FBVztvQkFDWEMsT0FBTztnQkFDVDtnQkFDQSxNQUFNQyxpQkFBaUIsT0FBT1osYUFBYSxhQUFhLE1BQU1BLFNBQVNRLGdCQUFnQlI7Z0JBQ3ZGLElBQUlyTyxXQUFXaVAsaUJBQWlCO29CQUM5QnpOLEtBQUt5TjtnQkFDUCxPQUFPO29CQUNMek4sS0FBSyxJQUFJM1UsZ0RBQW1CLENBQUM7d0JBQzNCLEdBQUdnaUIsWUFBWTt3QkFDZixHQUFHUixRQUFRO29CQUNiO2dCQUNGO2dCQUNBcGQsTUFBTU4sR0FBRyxDQUFDO29CQUNSNlE7Z0JBQ0Y7WUFDRjtZQUVBLG9DQUFvQztZQUNwQyxJQUFJOUYsWUFBWXpLLE1BQU15SyxTQUFTO1lBQy9CLElBQUksQ0FBQ0EsV0FBV3pLLE1BQU1OLEdBQUcsQ0FBQztnQkFDeEIrSyxXQUFXQSxZQUFZLElBQUk3Tyw0Q0FBZTtZQUM1QztZQUVBLHdCQUF3QjtZQUN4QixNQUFNLEVBQ0p1aUIsTUFBTSxFQUNOLEdBQUdDLFNBQ0osR0FBR1Ysa0JBQWtCLENBQUM7WUFDdkIsSUFBSSxDQUFDdGMsR0FBR1MsR0FBRyxDQUFDdWMsU0FBUzNULFdBQVdzUixlQUFlclcsV0FBVytFLFdBQVc7Z0JBQ25FLEdBQUcyVCxPQUFPO1lBQ1o7WUFDQSxJQUFJLENBQUNoZCxHQUFHUyxHQUFHLENBQUNzYyxRQUFRMVQsVUFBVTBULE1BQU0sRUFBRXBDLGVBQWVyVyxXQUFXK0UsV0FBVztnQkFDekUwVCxRQUFRO29CQUNOLEdBQUcxVCxVQUFVMFQsTUFBTTtvQkFDbkIsR0FBR0EsTUFBTTtnQkFDWDtZQUNGO1lBRUEsNERBQTREO1lBQzVELElBQUksQ0FBQ25lLE1BQU0ySCxNQUFNLElBQUkzSCxNQUFNMkgsTUFBTSxLQUFLb1YsY0FBYyxDQUFDM2IsR0FBR1MsR0FBRyxDQUFDa2IsWUFBWVksZUFBZTVCLGVBQWU7Z0JBQ3BHZ0IsYUFBYVk7Z0JBQ2IsTUFBTVUsV0FBV1YsaUJBQWlCLE9BQU8sS0FBSyxJQUFJQSxjQUFjVSxRQUFRO2dCQUN4RSxNQUFNMVcsU0FBUzBXLFdBQVdWLGdCQUFnQkYsZUFBZSxJQUFJN2hCLHFEQUF3QixDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSyxRQUFRLElBQUlBLG9EQUF1QixDQUFDLElBQUksR0FBRyxLQUFLO2dCQUN2SixJQUFJLENBQUN5aUIsVUFBVTtvQkFDYjFXLE9BQU8wSCxRQUFRLENBQUNtUCxDQUFDLEdBQUc7b0JBQ3BCLElBQUliLGVBQWU7d0JBQ2pCalksV0FBV2lDLFFBQVFnVzt3QkFDbkIsNENBQTRDO3dCQUM1QywwREFBMEQ7d0JBQzFELElBQUksQ0FBQ2hXLE9BQU9FLE1BQU0sRUFBRTs0QkFDbEIsSUFBSSxZQUFZOFYsaUJBQWlCLFVBQVVBLGlCQUFpQixXQUFXQSxpQkFBaUIsWUFBWUEsaUJBQWlCLFNBQVNBLGVBQWU7Z0NBQzNJaFcsT0FBT0UsTUFBTSxHQUFHO2dDQUNoQkYsT0FBT1Usc0JBQXNCOzRCQUMvQjt3QkFDRjtvQkFDRjtvQkFDQSxtQ0FBbUM7b0JBQ25DLElBQUksQ0FBQ3JJLE1BQU0ySCxNQUFNLElBQUksQ0FBRWdXLENBQUFBLGlCQUFpQixRQUFRQSxjQUFjYyxRQUFRLEdBQUc5VyxPQUFPK1csTUFBTSxDQUFDLEdBQUcsR0FBRztnQkFDL0Y7Z0JBQ0ExZSxNQUFNTixHQUFHLENBQUM7b0JBQ1JpSTtnQkFDRjtnQkFFQSxzQkFBc0I7Z0JBQ3RCLGdEQUFnRDtnQkFDaEQ4QyxVQUFVOUMsTUFBTSxHQUFHQTtZQUNyQjtZQUVBLGdDQUFnQztZQUNoQyxJQUFJLENBQUMzSCxNQUFNeVEsS0FBSyxFQUFFO2dCQUNoQixJQUFJQTtnQkFDSixJQUFJNk0sZ0JBQWdCLFFBQVFBLGFBQWFxQixPQUFPLEVBQUU7b0JBQ2hEbE8sUUFBUTZNO29CQUNSaGEsUUFBUW1OLE9BQU90SCxPQUFPLElBQUksQ0FBQztnQkFDN0IsT0FBTztvQkFDTHNILFFBQVEsSUFBSTdVLHdDQUFXO29CQUN2QjBILFFBQVFtTixPQUFPdEgsT0FBTyxJQUFJLENBQUM7b0JBQzNCLElBQUltVSxjQUFjNVgsV0FBVytLLE9BQU82TTtnQkFDdEM7Z0JBQ0F0ZCxNQUFNTixHQUFHLENBQUM7b0JBQ1IrUTtnQkFDRjtZQUNGO1lBRUEsMEJBQTBCO1lBQzFCLElBQUkvRixVQUFVLENBQUMxSyxNQUFNMEssTUFBTSxDQUFDakgsUUFBUSxFQUFFekQsTUFBTU4sR0FBRyxDQUFDO2dCQUM5Q2dMLFFBQVFBLE9BQU92QjtZQUNqQjtZQUNBLDZEQUE2RDtZQUM3RCxNQUFNdkIsT0FBT29VLG1CQUFtQkMsUUFBUW9CO1lBQ3hDLElBQUksQ0FBQ2pjLEdBQUdTLEdBQUcsQ0FBQytGLE1BQU01SCxNQUFNNEgsSUFBSSxFQUFFbVUsZUFBZTtnQkFDM0MvYixNQUFNMlIsT0FBTyxDQUFDL0osS0FBS0csS0FBSyxFQUFFSCxLQUFLTSxNQUFNLEVBQUVOLEtBQUtLLEdBQUcsRUFBRUwsS0FBS0UsSUFBSTtZQUM1RDtZQUNBLG1CQUFtQjtZQUNuQixJQUFJdEgsT0FBT1IsTUFBTXdSLFFBQVEsQ0FBQ2hSLEdBQUcsS0FBS0QsYUFBYUMsTUFBTVIsTUFBTTRSLE1BQU0sQ0FBQ3BSO1lBQ2xFLGtCQUFrQjtZQUNsQixJQUFJUixNQUFNbVIsU0FBUyxLQUFLQSxXQUFXblIsTUFBTThSLFlBQVksQ0FBQ1g7WUFDdEQsdUJBQXVCO1lBQ3ZCLElBQUksQ0FBQ25SLE1BQU1pTyxlQUFlLEVBQUVqTyxNQUFNTixHQUFHLENBQUM7Z0JBQ3BDdU87WUFDRjtZQUNBLG9CQUFvQjtZQUNwQixJQUFJb0MsZUFBZSxDQUFDalAsR0FBR1MsR0FBRyxDQUFDd08sYUFBYXJRLE1BQU1xUSxXQUFXLEVBQUUwTCxlQUFlL2IsTUFBTU4sR0FBRyxDQUFDTSxDQUFBQSxRQUFVO29CQUM1RnFRLGFBQWE7d0JBQ1gsR0FBR3JRLE1BQU1xUSxXQUFXO3dCQUNwQixHQUFHQSxXQUFXO29CQUNoQjtnQkFDRjtZQUVBLDZCQUE2QjtZQUM3QixJQUFJLENBQUNyUSxNQUFNMFEsRUFBRSxFQUFFO2dCQUNiLElBQUltTztnQkFDSixpQ0FBaUM7Z0JBQ2pDLE1BQU1DLGdCQUFnQixDQUFDbk8sV0FBV29PO29CQUNoQyxNQUFNL2UsUUFBUW1KLE1BQU05TCxRQUFRO29CQUM1QixJQUFJMkMsTUFBTW1SLFNBQVMsS0FBSyxTQUFTO29CQUNqQ2hDLFFBQVF3QixXQUFXLE1BQU0zUSxPQUFPK2U7Z0JBQ2xDO2dCQUVBLHFDQUFxQztnQkFDckMsTUFBTUMsc0JBQXNCO29CQUMxQixNQUFNaGYsUUFBUW1KLE1BQU05TCxRQUFRO29CQUM1QjJDLE1BQU11USxFQUFFLENBQUNHLEVBQUUsQ0FBQzdGLE9BQU8sR0FBRzdLLE1BQU11USxFQUFFLENBQUNHLEVBQUUsQ0FBQ3VPLFlBQVk7b0JBQzlDamYsTUFBTXVRLEVBQUUsQ0FBQ0csRUFBRSxDQUFDd08sZ0JBQWdCLENBQUNsZixNQUFNdVEsRUFBRSxDQUFDRyxFQUFFLENBQUN1TyxZQUFZLEdBQUdILGdCQUFnQjtvQkFDeEUsSUFBSSxDQUFDOWUsTUFBTXVRLEVBQUUsQ0FBQ0csRUFBRSxDQUFDdU8sWUFBWSxFQUFFeFgsV0FBV3pIO2dCQUM1QztnQkFFQSx3QkFBd0I7Z0JBQ3hCLE1BQU0wUSxLQUFLO29CQUNUeU87d0JBQ0UsTUFBTTVPLEtBQUtwSCxNQUFNOUwsUUFBUSxHQUFHa1QsRUFBRTt3QkFDOUJBLEdBQUdHLEVBQUUsQ0FBQzBPLGdCQUFnQixDQUFDLGdCQUFnQko7d0JBQ3ZDek8sR0FBR0csRUFBRSxDQUFDME8sZ0JBQWdCLENBQUMsY0FBY0o7b0JBQ3ZDO29CQUNBSzt3QkFDRSxNQUFNOU8sS0FBS3BILE1BQU05TCxRQUFRLEdBQUdrVCxFQUFFO3dCQUM5QkEsR0FBR0csRUFBRSxDQUFDNE8sbUJBQW1CLENBQUMsZ0JBQWdCTjt3QkFDMUN6TyxHQUFHRyxFQUFFLENBQUM0TyxtQkFBbUIsQ0FBQyxjQUFjTjtvQkFDMUM7Z0JBQ0Y7Z0JBRUEsb0NBQW9DO2dCQUNwQyxJQUFJLE9BQVEsRUFBQ0gsU0FBU3RPLEdBQUdHLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSW1PLE9BQU9PLGdCQUFnQixNQUFNLFlBQVkxTyxHQUFHeU8sT0FBTztnQkFDbkduZixNQUFNTixHQUFHLENBQUM7b0JBQ1JnUjtnQkFDRjtZQUNGO1lBRUEsZ0JBQWdCO1lBQ2hCLElBQUlILEdBQUdnUCxTQUFTLEVBQUU7Z0JBQ2hCLE1BQU1DLGFBQWFqUCxHQUFHZ1AsU0FBUyxDQUFDMVUsT0FBTztnQkFDdkMsTUFBTTRVLFVBQVVsUCxHQUFHZ1AsU0FBUyxDQUFDamdCLElBQUk7Z0JBQ2pDaVIsR0FBR2dQLFNBQVMsQ0FBQzFVLE9BQU8sR0FBRyxDQUFDLENBQUMyUztnQkFDekIsSUFBSXBjLEdBQUdNLEdBQUcsQ0FBQzhiLFVBQVU7b0JBQ25Cak4sR0FBR2dQLFNBQVMsQ0FBQ2pnQixJQUFJLEdBQUcxRCxtREFBc0I7Z0JBQzVDLE9BQU8sSUFBSXdGLEdBQUdJLEdBQUcsQ0FBQ2djLFVBQVU7b0JBQzFCLElBQUltQztvQkFDSixNQUFNQyxRQUFRO3dCQUNaQyxPQUFPamtCLGlEQUFvQjt3QkFDM0Jta0IsWUFBWW5rQiwrQ0FBa0I7d0JBQzlCcWtCLE1BQU1ya0IsbURBQXNCO3dCQUM1QnNrQixVQUFVdGtCLCtDQUFrQjtvQkFDOUI7b0JBQ0EyVSxHQUFHZ1AsU0FBUyxDQUFDamdCLElBQUksR0FBRyxDQUFDcWdCLGlCQUFpQkMsS0FBSyxDQUFDcEMsUUFBUSxLQUFLLE9BQU9tQyxpQkFBaUIvakIsbURBQXNCO2dCQUN6RyxPQUFPLElBQUl3RixHQUFHekQsR0FBRyxDQUFDNmYsVUFBVTtvQkFDMUJ6Z0IsT0FBT3lYLE1BQU0sQ0FBQ2pFLEdBQUdnUCxTQUFTLEVBQUUvQjtnQkFDOUI7Z0JBQ0EsSUFBSWdDLGVBQWVqUCxHQUFHZ1AsU0FBUyxDQUFDMVUsT0FBTyxJQUFJNFUsWUFBWWxQLEdBQUdnUCxTQUFTLENBQUNqZ0IsSUFBSSxFQUFFaVIsR0FBR2dQLFNBQVMsQ0FBQ2EsV0FBVyxHQUFHO1lBQ3ZHO1lBQ0F4a0Isa0RBQXFCLENBQUNpUCxPQUFPLEdBQUcsQ0FBQ2dHO1lBRWpDLDhDQUE4QztZQUM5QyxJQUFJLENBQUNtTSxZQUFZO2dCQUNmek0sR0FBRytQLGdCQUFnQixHQUFHamEsU0FBU3pLLHVEQUEwQixHQUFHQSxpREFBb0I7Z0JBQ2hGMlUsR0FBR2lRLFdBQVcsR0FBRzFQLE9BQU9sVixnREFBbUIsR0FBR0Esd0RBQTJCO1lBQzNFO1lBRUEsZ0NBQWdDO1lBQ2hDLElBQUlvRSxNQUFNNlEsTUFBTSxLQUFLQSxRQUFRN1EsTUFBTU4sR0FBRyxDQUFDLElBQU87b0JBQzVDbVI7Z0JBQ0Y7WUFDQSxJQUFJN1EsTUFBTXFHLE1BQU0sS0FBS0EsUUFBUXJHLE1BQU1OLEdBQUcsQ0FBQyxJQUFPO29CQUM1QzJHO2dCQUNGO1lBQ0EsSUFBSXJHLE1BQU04USxJQUFJLEtBQUtBLE1BQU05USxNQUFNTixHQUFHLENBQUMsSUFBTztvQkFDeENvUjtnQkFDRjtZQUVBLGVBQWU7WUFDZixJQUFJc00sWUFBWSxDQUFDaGMsR0FBR0csR0FBRyxDQUFDNmIsYUFBYSxDQUFDck8sV0FBV3FPLGFBQWEsQ0FBQ2hjLEdBQUdTLEdBQUcsQ0FBQ3ViLFVBQVU3TSxJQUFJd0wsZUFBZXJXLFdBQVc2SyxJQUFJNk07WUFFbEgsYUFBYTtZQUNiTixZQUFZUztZQUNaUCxhQUFhO1lBQ2JyWjtZQUNBLE9BQU8sSUFBSTtRQUNiO1FBQ0F0RCxRQUFPbEIsUUFBUTtZQUNiLDBEQUEwRDtZQUMxRCxJQUFJLENBQUM2ZCxjQUFjLENBQUNDLFNBQVMsSUFBSSxDQUFDQyxTQUFTO1lBQzNDRCxRQUFRMEQsSUFBSSxDQUFDO2dCQUNYNUwsV0FBVzZMLGVBQWUsQ0FBRSxXQUFXLEdBQUVua0Isc0RBQUdBLENBQUNva0IsVUFBVTtvQkFDckQxWCxPQUFPQTtvQkFDUGhLLFVBQVVBO29CQUNWMmQsV0FBV0E7b0JBQ1hnRSxhQUFhN0U7Z0JBQ2YsSUFBSWpkLE9BQU8sTUFBTSxJQUFNMkY7WUFDekI7WUFDQSxPQUFPd0U7UUFDVDtRQUNBNFg7WUFDRUMsdUJBQXVCL0U7UUFDekI7SUFDRjtBQUNGO0FBQ0EsU0FBUzRFLFNBQVMsRUFDaEIxWCxLQUFLLEVBQ0xoSyxRQUFRLEVBQ1IyZCxTQUFTLEVBQ1RnRSxXQUFXLEVBQ1o7SUFDQzlpQjs4Q0FBMEI7WUFDeEIsTUFBTWdDLFFBQVFtSixNQUFNOUwsUUFBUTtZQUM1QixtREFBbUQ7WUFDbkQyQyxNQUFNTixHQUFHO3NEQUFDTSxDQUFBQSxRQUFVO3dCQUNsQjRHLFVBQVU7NEJBQ1IsR0FBRzVHLE1BQU00RyxRQUFROzRCQUNqQndMLFFBQVE7d0JBQ1Y7b0JBQ0Y7O1lBQ0EsdUZBQXVGO1lBQ3ZGLElBQUkwSyxXQUFXQSxVQUFVOWM7WUFDekIsd0ZBQXdGO1lBQ3hGLGdEQUFnRDtZQUNoRCxJQUFJLENBQUNtSixNQUFNOUwsUUFBUSxHQUFHcU4sTUFBTSxDQUFDOEYsU0FBUyxFQUFFeFEsTUFBTTBLLE1BQU0sQ0FBQ3lVLE9BQU8sSUFBSSxPQUFPLEtBQUssSUFBSW5mLE1BQU0wSyxNQUFNLENBQUN5VSxPQUFPLENBQUMyQjtRQUNyRyx1REFBdUQ7UUFDekQ7NkNBQUcsRUFBRTtJQUNMLE9BQU8sV0FBVyxHQUFFcmtCLHNEQUFHQSxDQUFDdVMsUUFBUTZSLFFBQVEsRUFBRTtRQUN4Qy9pQixPQUFPcUw7UUFDUGhLLFVBQVVBO0lBQ1o7QUFDRjtBQUNBLFNBQVM2aEIsdUJBQXVCL0UsTUFBTSxFQUFFaFEsUUFBUTtJQUM5QyxNQUFNN08sT0FBTzBlLE9BQU83VyxHQUFHLENBQUNnWDtJQUN4QixNQUFNamQsUUFBUTVCLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUs0QixLQUFLO0lBQ2hELElBQUlBLE9BQU87UUFDVCxNQUFNZ0IsUUFBUTVDLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUsrTCxLQUFLLENBQUM5TCxRQUFRO1FBQ3pELElBQUkyQyxPQUFPQSxNQUFNNEcsUUFBUSxDQUFDd0wsTUFBTSxHQUFHO1FBQ25DMkMsV0FBVzZMLGVBQWUsQ0FBQyxNQUFNNWhCLE9BQU8sTUFBTTtZQUM1QyxJQUFJZ0IsT0FBTztnQkFDVHVSLFdBQVc7b0JBQ1QsSUFBSTt3QkFDRixJQUFJMFAsV0FBV0MsdUJBQXVCQyxZQUFZQzt3QkFDbERwaEIsTUFBTTBLLE1BQU0sQ0FBQzJVLFVBQVUsSUFBSSxPQUFPLEtBQUssSUFBSXJmLE1BQU0wSyxNQUFNLENBQUMyVSxVQUFVO3dCQUNqRTRCLENBQUFBLFlBQVlqaEIsTUFBTXVRLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSSxDQUFDMlEsd0JBQXdCRCxVQUFVSSxXQUFXLEtBQUssT0FBTyxLQUFLLElBQUlILHNCQUFzQnBlLE9BQU8sSUFBSSxPQUFPLEtBQUssSUFBSW9lLHNCQUFzQnBlLE9BQU87d0JBQzFMcWUsQ0FBQUEsYUFBYW5oQixNQUFNdVEsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJNFEsV0FBV0csZ0JBQWdCLElBQUksT0FBTyxLQUFLLElBQUlILFdBQVdHLGdCQUFnQjt3QkFDckgsSUFBSSxDQUFDRixhQUFhcGhCLE1BQU11USxFQUFFLEtBQUssUUFBUTZRLFdBQVcxUSxFQUFFLEVBQUUxUSxNQUFNMFEsRUFBRSxDQUFDMk8sVUFBVTt3QkFDekV2YyxRQUFROUMsTUFBTXlRLEtBQUs7d0JBQ25CcUwsT0FBTzlTLE1BQU0sQ0FBQ2lUO3dCQUNkLElBQUloUSxVQUFVQSxTQUFTZ1E7b0JBQ3pCLEVBQUUsT0FBTy9XLEdBQUc7b0JBQ1YsT0FBTyxHQUNUO2dCQUNGLEdBQUc7WUFDTDtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNxYyxhQUFhcGlCLFFBQVEsRUFBRXNaLFNBQVMsRUFBRXpZLEtBQUs7SUFDOUMsT0FBTyxXQUFXLEdBQUV2RCxzREFBR0EsQ0FBQytrQixRQUFRO1FBQzlCcmlCLFVBQVVBO1FBQ1ZzWixXQUFXQTtRQUNYelksT0FBT0E7SUFDVDtBQUNGO0FBQ0EsU0FBU3doQixPQUFPLEVBQ2R4aEIsUUFBUSxDQUFDLENBQUMsRUFDVmIsUUFBUSxFQUNSc1osU0FBUyxFQUNWO0lBQ0M7Ozs7NEJBSTBCLEdBQzFCLE1BQU0sRUFDSi9OLE1BQU0sRUFDTjlDLElBQUksRUFDSixHQUFHNlosTUFDSixHQUFHemhCO0lBQ0osTUFBTTFDLGVBQWUwVjtJQUNyQixNQUFNLENBQUN2SSxVQUFVLEdBQUc1TywyQ0FBYzsyQkFBQyxJQUFNLElBQUlELDRDQUFlOztJQUM1RCxNQUFNLENBQUMwUSxRQUFRLEdBQUd6USwyQ0FBYzsyQkFBQyxJQUFNLElBQUlELDBDQUFhOztJQUN4RCxNQUFNK2xCLFNBQVNqakI7NkNBQW1CLENBQUNrSCxXQUFXZ2M7WUFDNUMsSUFBSXBRLFdBQVc3TTtZQUNmLElBQUlpZCxZQUFZamEsTUFBTSxJQUFJQyxNQUFNO2dCQUM5QixNQUFNRCxTQUFTaWEsWUFBWWphLE1BQU07Z0JBQ2pDLDhDQUE4QztnQkFDOUM2SixXQUFXNUwsVUFBVTRMLFFBQVEsQ0FBQ2hDLGtCQUFrQixDQUFDN0gsUUFBUSxJQUFJL0wsMENBQWEsSUFBSWdNO2dCQUM5RSxrRUFBa0U7Z0JBQ2xFLElBQUlELFdBQVcvQixVQUFVK0IsTUFBTSxFQUFFRCxhQUFhQyxRQUFRQztZQUN4RDtZQUNBLE9BQU87Z0JBQ0wsb0RBQW9EO2dCQUNwRCxHQUFHaEMsU0FBUztnQkFDWixHQUFHZ2MsV0FBVztnQkFDZCxnRkFBZ0Y7Z0JBQ2hGblIsT0FBT2dJO2dCQUNQaE87Z0JBQ0E2QjtnQkFDQTRFLE9BQU81RTtnQkFDUCw2Q0FBNkM7Z0JBQzdDaFA7Z0JBQ0Esa0VBQWtFO2dCQUNsRW9OLFFBQVE7b0JBQ04sR0FBRzlFLFVBQVU4RSxNQUFNO29CQUNuQixHQUFHa1gsWUFBWWxYLE1BQU07b0JBQ3JCLEdBQUdBLE1BQU07Z0JBQ1g7Z0JBQ0E5QyxNQUFNO29CQUNKLEdBQUdoQyxVQUFVZ0MsSUFBSTtvQkFDakIsR0FBR0EsSUFBSTtnQkFDVDtnQkFDQTRKLFVBQVU7b0JBQ1IsR0FBRzVMLFVBQVU0TCxRQUFRO29CQUNyQixHQUFHQSxRQUFRO2dCQUNiO2dCQUNBLHdDQUF3QztnQkFDeENFLFNBQVM7eURBQUVoSCxDQUFBQSxTQUFVa1gsWUFBWWxpQixHQUFHO2lFQUFDTSxDQUFBQSxRQUFVO29DQUM3QyxHQUFHQSxLQUFLO29DQUNSMEssUUFBUTt3Q0FDTixHQUFHMUssTUFBTTBLLE1BQU07d0NBQ2YsR0FBR0EsTUFBTTtvQ0FDWDtnQ0FDRjs7O1lBQ0Y7UUFDRjs7SUFDQSxNQUFNbVgsaUJBQWlCaG1CLDBDQUFhOzBDQUFDO1lBQ25DLCtFQUErRTtZQUMvRSxNQUFNc04sUUFBUWpOLHlFQUFvQkE7d0RBQUMsQ0FBQ3dELEtBQUt1RixNQUFTO3dCQUNoRCxHQUFHd2MsSUFBSTt3QkFDUC9oQjt3QkFDQXVGO29CQUNGOztZQUVBLHNGQUFzRjtZQUN0RixNQUFNNmM7MkRBQVdDLENBQUFBLE9BQVE1WSxNQUFNNlksUUFBUTttRUFBQ2hpQixDQUFBQSxRQUFTMmhCLE9BQU83aUIsT0FBTyxDQUFDaWpCLE1BQU0vaEI7OztZQUN0RThoQixTQUFTeGtCLGFBQWFELFFBQVE7WUFDOUJDLGFBQWErVSxTQUFTLENBQUN5UDtZQUN2QixPQUFPM1k7UUFDUCx1REFBdUQ7UUFDekQ7eUNBQUc7UUFBQzdMO1FBQWNtYjtLQUFVO0lBQzVCLE9BQ0UsV0FBVyxHQUNYLGtEQUFrRDtJQUNsRGhjLHNEQUFHQSxDQUFDQyx1REFBUUEsRUFBRTtRQUNaeUMsVUFBVTRWLFdBQVd3TSxZQUFZLENBQUUsV0FBVyxHQUFFOWtCLHNEQUFHQSxDQUFDdVMsUUFBUTZSLFFBQVEsRUFBRTtZQUNwRS9pQixPQUFPK2pCO1lBQ1AxaUIsVUFBVUE7UUFDWixJQUFJMGlCLGdCQUFnQjtJQUN0QjtBQUVKO0FBRUEsU0FBU0ksV0FBV2hXLFFBQVEsRUFBRWlXLElBQUk7SUFDaEMsTUFBTUMsTUFBTTtRQUNWbFc7SUFDRjtJQUNBaVcsS0FBS3hXLEdBQUcsQ0FBQ3lXO0lBQ1QsT0FBTyxJQUFNLEtBQUtELEtBQUtsWixNQUFNLENBQUNtWjtBQUNoQztBQUNBLE1BQU1DLGdCQUFnQixJQUFJOVg7QUFDMUIsTUFBTStYLHFCQUFxQixJQUFJL1g7QUFDL0IsTUFBTWdZLG9CQUFvQixJQUFJaFk7QUFFOUI7OztDQUdDLEdBQ0QsTUFBTWlZLFlBQVl0VyxDQUFBQSxXQUFZZ1csV0FBV2hXLFVBQVVtVztBQUVuRDs7O0NBR0MsR0FDRCxNQUFNSSxpQkFBaUJ2VyxDQUFBQSxXQUFZZ1csV0FBV2hXLFVBQVVvVztBQUV4RDs7O0NBR0MsR0FDRCxNQUFNSSxVQUFVeFcsQ0FBQUEsV0FBWWdXLFdBQVdoVyxVQUFVcVc7QUFDakQsU0FBU0ksSUFBSUMsT0FBTyxFQUFFaFMsU0FBUztJQUM3QixJQUFJLENBQUNnUyxRQUFRL2EsSUFBSSxFQUFFO0lBQ25CLEtBQUssTUFBTSxFQUNUcUUsUUFBUSxFQUNULElBQUkwVyxRQUFROVcsTUFBTSxHQUFJO1FBQ3JCSSxTQUFTMEU7SUFDWDtBQUNGO0FBQ0EsU0FBU2lTLG1CQUFtQnRqQixJQUFJLEVBQUVxUixTQUFTO0lBQ3pDLE9BQVFyUjtRQUNOLEtBQUs7WUFDSCxPQUFPb2pCLElBQUlOLGVBQWV6UjtRQUM1QixLQUFLO1lBQ0gsT0FBTytSLElBQUlMLG9CQUFvQjFSO1FBQ2pDLEtBQUs7WUFDSCxPQUFPK1IsSUFBSUosbUJBQW1CM1I7SUFDbEM7QUFDRjtBQUNBLElBQUl1QjtBQUNKLElBQUkyUTtBQUNKLFNBQVNDLE9BQU9uUyxTQUFTLEVBQUUzUSxLQUFLLEVBQUUrZSxLQUFLO0lBQ3JDLG9CQUFvQjtJQUNwQixJQUFJL1MsUUFBUWhNLE1BQU1nUixLQUFLLENBQUMrUixRQUFRO0lBRWhDLGtGQUFrRjtJQUNsRixJQUFJL2lCLE1BQU1tUixTQUFTLEtBQUssV0FBVyxPQUFPUixjQUFjLFVBQVU7UUFDaEUzRSxRQUFRMkUsWUFBWTNRLE1BQU1nUixLQUFLLENBQUNnQixXQUFXO1FBQzNDaFMsTUFBTWdSLEtBQUssQ0FBQ2dTLE9BQU8sR0FBR2hqQixNQUFNZ1IsS0FBSyxDQUFDZ0IsV0FBVztRQUM3Q2hTLE1BQU1nUixLQUFLLENBQUNnQixXQUFXLEdBQUdyQjtJQUM1QjtJQUVBLDhCQUE4QjtJQUM5QnVCLGNBQWNsUyxNQUFNNEcsUUFBUSxDQUFDc0wsV0FBVztJQUN4QyxJQUFLLElBQUkvUCxJQUFJLEdBQUdBLElBQUkrUCxZQUFZOVAsTUFBTSxFQUFFRCxJQUFLO1FBQzNDMGdCLGVBQWUzUSxXQUFXLENBQUMvUCxFQUFFO1FBQzdCMGdCLGFBQWFqa0IsR0FBRyxDQUFDRSxPQUFPLENBQUMrakIsYUFBYTFaLEtBQUssQ0FBQzlMLFFBQVEsSUFBSTJPLE9BQU8rUztJQUNqRTtJQUVBLGlCQUFpQjtJQUNqQixJQUFJLENBQUMvZSxNQUFNNEcsUUFBUSxDQUFDMEUsUUFBUSxJQUFJdEwsTUFBTXVRLEVBQUUsQ0FBQ2xRLE1BQU0sRUFBRUwsTUFBTXVRLEVBQUUsQ0FBQ2xRLE1BQU0sQ0FBQ0wsTUFBTXlRLEtBQUssRUFBRXpRLE1BQU0ySCxNQUFNO0lBRTFGLHVCQUF1QjtJQUN2QjNILE1BQU00RyxRQUFRLENBQUNZLE1BQU0sR0FBRzFHLEtBQUtFLEdBQUcsQ0FBQyxHQUFHaEIsTUFBTTRHLFFBQVEsQ0FBQ1ksTUFBTSxHQUFHO0lBQzVELE9BQU94SCxNQUFNbVIsU0FBUyxLQUFLLFdBQVcsSUFBSW5SLE1BQU00RyxRQUFRLENBQUNZLE1BQU07QUFDakU7QUFDQSxJQUFJeWIsVUFBVTtBQUNkLElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQztBQUNKLElBQUlwRTtBQUNKLElBQUkvZTtBQUNKLFNBQVNvakIsS0FBS3pTLFNBQVM7SUFDckJvTyxRQUFRNVEsc0JBQXNCaVY7SUFDOUJILFVBQVU7SUFDVkUsU0FBUztJQUVULGNBQWM7SUFDZFAsbUJBQW1CLFVBQVVqUztJQUU3QixtQkFBbUI7SUFDbkJ1UyxxQkFBcUI7SUFDckIsS0FBSyxNQUFNOWxCLFFBQVEwZSxPQUFPalEsTUFBTSxHQUFJO1FBQ2xDLElBQUl3WDtRQUNKcmpCLFFBQVE1QyxLQUFLK0wsS0FBSyxDQUFDOUwsUUFBUTtRQUUzQiw0REFBNEQ7UUFDNUQsSUFBSTJDLE1BQU00RyxRQUFRLENBQUN3TCxNQUFNLElBQUtwUyxDQUFBQSxNQUFNbVIsU0FBUyxLQUFLLFlBQVluUixNQUFNNEcsUUFBUSxDQUFDWSxNQUFNLEdBQUcsTUFBTSxDQUFFLEVBQUM2YixlQUFlcmpCLE1BQU11USxFQUFFLENBQUNHLEVBQUUsS0FBSyxRQUFRMlMsYUFBYXBFLFlBQVksR0FBRztZQUNoS2tFLFVBQVVMLE9BQU9uUyxXQUFXM1E7UUFDOUI7SUFDRjtJQUNBa2pCLHFCQUFxQjtJQUVyQixvQkFBb0I7SUFDcEJOLG1CQUFtQixTQUFTalM7SUFFNUIsMENBQTBDO0lBQzFDLElBQUl3UyxXQUFXLEdBQUc7UUFDaEIsMERBQTBEO1FBQzFEUCxtQkFBbUIsUUFBUWpTO1FBRTNCLHdCQUF3QjtRQUN4QnNTLFVBQVU7UUFDVixPQUFPSyxxQkFBcUJ2RTtJQUM5QjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU3RYLFdBQVd6SCxLQUFLLEVBQUV3SCxTQUFTLENBQUM7SUFDbkMsSUFBSStiO0lBQ0osSUFBSSxDQUFDdmpCLE9BQU8sT0FBTzhiLE9BQU90UyxPQUFPLENBQUNwTSxDQUFBQSxPQUFRcUssV0FBV3JLLEtBQUsrTCxLQUFLLENBQUM5TCxRQUFRLElBQUltSztJQUM1RSxJQUFJLENBQUMrYixnQkFBZ0J2akIsTUFBTXVRLEVBQUUsQ0FBQ0csRUFBRSxLQUFLLFFBQVE2UyxjQUFjdEUsWUFBWSxJQUFJLENBQUNqZixNQUFNNEcsUUFBUSxDQUFDd0wsTUFBTSxJQUFJcFMsTUFBTW1SLFNBQVMsS0FBSyxTQUFTO0lBQ2xJLElBQUkzSixTQUFTLEdBQUc7UUFDZCxvREFBb0Q7UUFDcEQsNENBQTRDO1FBQzVDeEgsTUFBTTRHLFFBQVEsQ0FBQ1ksTUFBTSxHQUFHMUcsS0FBS0MsR0FBRyxDQUFDLElBQUlmLE1BQU00RyxRQUFRLENBQUNZLE1BQU0sR0FBR0E7SUFDL0QsT0FBTztRQUNMLElBQUkwYixvQkFBb0I7WUFDdEIsNEVBQTRFO1lBQzVFbGpCLE1BQU00RyxRQUFRLENBQUNZLE1BQU0sR0FBRztRQUMxQixPQUFPO1lBQ0wsZ0VBQWdFO1lBQ2hFeEgsTUFBTTRHLFFBQVEsQ0FBQ1ksTUFBTSxHQUFHO1FBQzFCO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsSUFBSSxDQUFDeWIsU0FBUztRQUNaQSxVQUFVO1FBQ1Y5VSxzQkFBc0JpVjtJQUN4QjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU2pVLFFBQVF3QixTQUFTLEVBQUVDLG1CQUFtQixJQUFJLEVBQUU1USxLQUFLLEVBQUUrZSxLQUFLO0lBQy9ELElBQUluTyxrQkFBa0JnUyxtQkFBbUIsVUFBVWpTO0lBQ25ELElBQUksQ0FBQzNRLE9BQU8sS0FBSyxNQUFNNUMsUUFBUTBlLE9BQU9qUSxNQUFNLEdBQUlpWCxPQUFPblMsV0FBV3ZULEtBQUsrTCxLQUFLLENBQUM5TCxRQUFRO1NBQVN5bEIsT0FBT25TLFdBQVczUSxPQUFPK2U7SUFDdkgsSUFBSW5PLGtCQUFrQmdTLG1CQUFtQixTQUFTalM7QUFDcEQ7QUFFQSxNQUFNNlMsYUFBYTtJQUNqQkMsU0FBUztRQUFDO1FBQVM7S0FBTTtJQUN6QkMsZUFBZTtRQUFDO1FBQWU7S0FBTTtJQUNyQ0MsZUFBZTtRQUFDO1FBQVk7S0FBTTtJQUNsQ0MsU0FBUztRQUFDO1FBQVM7S0FBSztJQUN4QkMsZUFBZTtRQUFDO1FBQWU7S0FBSztJQUNwQ0MsYUFBYTtRQUFDO1FBQWE7S0FBSztJQUNoQy9WLGdCQUFnQjtRQUFDO1FBQWdCO0tBQUs7SUFDdENjLGVBQWU7UUFBQztRQUFlO0tBQUs7SUFDcENrVixpQkFBaUI7UUFBQztRQUFpQjtLQUFLO0lBQ3hDQyxzQkFBc0I7UUFBQztRQUFzQjtLQUFLO0FBQ3BEO0FBRUEsc0NBQXNDLEdBQ3RDLFNBQVNDLG9CQUFvQjlhLEtBQUs7SUFDaEMsTUFBTSxFQUNKK0UsYUFBYSxFQUNkLEdBQUd6RSxhQUFhTjtJQUNqQixPQUFPO1FBQ0xtQyxVQUFVO1FBQ1ZULFNBQVM7UUFDVEYsU0FBUXBDLEtBQUssRUFBRXZJLEtBQUssRUFBRTBFLFFBQVE7WUFDNUIsdURBQXVEO1lBQ3ZELDRGQUE0RjtZQUM1RjFFLE1BQU1zTSxPQUFPLENBQUM1TSxHQUFHLENBQUM2SSxNQUFNcUIsT0FBTyxHQUFHNUosTUFBTTRILElBQUksQ0FBQ0csS0FBSyxHQUFHLElBQUksR0FBRyxDQUFFUSxDQUFBQSxNQUFNd0IsT0FBTyxHQUFHL0osTUFBTTRILElBQUksQ0FBQ00sTUFBTSxJQUFJLElBQUk7WUFDdkdsSSxNQUFNeUssU0FBUyxDQUFDeVosYUFBYSxDQUFDbGtCLE1BQU1zTSxPQUFPLEVBQUV0TSxNQUFNMkgsTUFBTTtRQUMzRDtRQUNBNkksV0FBVzdMO1FBQ1hsQixVQUFVMUcsT0FBT3NGLElBQUksQ0FBQ21oQixZQUFZemYsTUFBTSxDQUFDLENBQUNDLEtBQUtaLE1BQVM7Z0JBQ3RELEdBQUdZLEdBQUc7Z0JBQ04sQ0FBQ1osSUFBSSxFQUFFOEssY0FBYzlLO1lBQ3ZCLElBQUksQ0FBQztRQUNMMGYsUUFBUTtZQUNOLElBQUlxQjtZQUNKLE1BQU0sRUFDSnpaLE1BQU0sRUFDTjlELFFBQVEsRUFDVCxHQUFHdUMsTUFBTTlMLFFBQVE7WUFDbEIsSUFBSSxDQUFDOG1CLHNCQUFzQnZkLFNBQVN5SCxTQUFTLEtBQUssUUFBUThWLG9CQUFvQnJsQixPQUFPLElBQUk0TCxPQUFPakgsUUFBUSxFQUFFaUgsT0FBT2pILFFBQVEsQ0FBQ29MLGFBQWEsQ0FBQ2pJLFNBQVN5SCxTQUFTLENBQUN2UCxPQUFPO1FBQ3BLO1FBQ0FxZ0IsU0FBU3plLENBQUFBO1lBQ1AsTUFBTSxFQUNKaEIsR0FBRyxFQUNIZ0wsTUFBTSxFQUNQLEdBQUd2QixNQUFNOUwsUUFBUTtZQUNsQnFOLE9BQU8yVSxVQUFVLElBQUksT0FBTyxLQUFLLElBQUkzVSxPQUFPMlUsVUFBVTtZQUN0RDNmLElBQUlNLENBQUFBLFFBQVU7b0JBQ1owSyxRQUFRO3dCQUNOLEdBQUcxSyxNQUFNMEssTUFBTTt3QkFDZjhGLFdBQVc5UDtvQkFDYjtnQkFDRjtZQUNBLElBQUlnSyxPQUFPakgsUUFBUSxFQUFFO2dCQUNuQixJQUFLLE1BQU1iLFFBQVE4SCxPQUFPakgsUUFBUSxDQUFFO29CQUNsQyxNQUFNOEUsUUFBUW1DLE9BQU9qSCxRQUFRLENBQUNiLEtBQUs7b0JBQ25DLE1BQU0sQ0FBQ3doQixXQUFXQyxRQUFRLEdBQUdiLFVBQVUsQ0FBQzVnQixLQUFLO29CQUM3Q2xDLE9BQU8wZSxnQkFBZ0IsQ0FBQ2dGLFdBQVc3YixPQUFPO3dCQUN4QzhiO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBaEYsWUFBWTtZQUNWLE1BQU0sRUFDSjNmLEdBQUcsRUFDSGdMLE1BQU0sRUFDUCxHQUFHdkIsTUFBTTlMLFFBQVE7WUFDbEIsSUFBSXFOLE9BQU84RixTQUFTLEVBQUU7Z0JBQ3BCLElBQUk5RixPQUFPakgsUUFBUSxFQUFFO29CQUNuQixJQUFLLE1BQU1iLFFBQVE4SCxPQUFPakgsUUFBUSxDQUFFO3dCQUNsQyxNQUFNOEUsUUFBUW1DLE9BQU9qSCxRQUFRLENBQUNiLEtBQUs7d0JBQ25DLE1BQU0sQ0FBQ3doQixVQUFVLEdBQUdaLFVBQVUsQ0FBQzVnQixLQUFLO3dCQUNwQzhILE9BQU84RixTQUFTLENBQUM4TyxtQkFBbUIsQ0FBQzhFLFdBQVc3YjtvQkFDbEQ7Z0JBQ0Y7Z0JBQ0E3SSxJQUFJTSxDQUFBQSxRQUFVO3dCQUNaMEssUUFBUTs0QkFDTixHQUFHMUssTUFBTTBLLE1BQU07NEJBQ2Y4RixXQUFXN0w7d0JBQ2I7b0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVtbEIiLCJzb3VyY2VzIjpbIi9ob21lL2NvZGVyL0Rlc2t0b3Avc21hcnRfbGVhcm5pbmcvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L2V2ZW50cy0wZGM4NGI4MS5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IHsgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlRmliZXIsIHVzZUNvbnRleHRCcmlkZ2UsIHRyYXZlcnNlRmliZXIgfSBmcm9tICdpdHMtZmluZSc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5zdGFuY2UncyBpbml0aWFsIChvdXRtb3N0KSByb290LlxyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkge1xuICBsZXQgcm9vdCA9IGluc3RhbmNlLnJvb3Q7XG4gIHdoaWxlIChyb290LmdldFN0YXRlKCkucHJldmlvdXNSb290KSByb290ID0gcm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdDtcbiAgcmV0dXJuIHJvb3Q7XG59XG4vKipcclxuICogU2FmZWx5IGZsdXNoIGFzeW5jIGVmZmVjdHMgd2hlbiB0ZXN0aW5nLCBzaW11bGF0aW5nIGEgbGVnYWN5IHJvb3QuXHJcbiAqL1xuY29uc3QgYWN0ID0gUmVhY3QuYWN0O1xuY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcbmNvbnN0IGlzQ29sb3JSZXByZXNlbnRhdGlvbiA9IHZhbHVlID0+IHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZS5pc0NvbG9yKTtcblxuLyoqXHJcbiAqIEFuIFNTUi1mcmllbmRseSB1c2VMYXlvdXRFZmZlY3QuXHJcbiAqXHJcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAqIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXHJcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDkyN1xyXG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8oKF93aW5kb3ckZG9jdW1lbnQsIF93aW5kb3ckbmF2aWdhdG9yKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKChfd2luZG93JGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB8fCAoKF93aW5kb3ckbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnKSkoKSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZU11dGFibGVDYWxsYmFjayhmbikge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoZm4pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKHJlZi5jdXJyZW50ID0gZm4pLCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn1cbi8qKlxyXG4gKiBCcmlkZ2VzIHJlbmRlcmVyIENvbnRleHQgYW5kIFN0cmljdE1vZGUgZnJvbSBhIHByaW1hcnkgcmVuZGVyZXIuXHJcbiAqL1xuZnVuY3Rpb24gdXNlQnJpZGdlKCkge1xuICBjb25zdCBmaWJlciA9IHVzZUZpYmVyKCk7XG4gIGNvbnN0IENvbnRleHRCcmlkZ2UgPSB1c2VDb250ZXh0QnJpZGdlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHN0cmljdCA9ICEhdHJhdmVyc2VGaWJlcihmaWJlciwgdHJ1ZSwgbm9kZSA9PiBub2RlLnR5cGUgPT09IFJlYWN0LlN0cmljdE1vZGUpO1xuICAgIGNvbnN0IFJvb3QgPSBzdHJpY3QgPyBSZWFjdC5TdHJpY3RNb2RlIDogUmVhY3QuRnJhZ21lbnQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUm9vdCwge1xuICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ29udGV4dEJyaWRnZSwge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sIFtmaWJlciwgQ29udGV4dEJyaWRnZV0pO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTk9URTogc3RhdGljIG1lbWJlcnMgZ2V0IGRvd24tbGV2ZWwgdHJhbnNwaWxlZCB0byBtdXRhdGlvbnMgd2hpY2ggYnJlYWsgdHJlZS1zaGFraW5nXG5jb25zdCBFcnJvckJvdW5kYXJ5ID0gLyogQF9fUFVSRV9fICovKF9FcnJvckJvdW5kYXJ5ID0+IChfRXJyb3JCb3VuZGFyeSA9IGNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufSwgX0Vycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pLCBfRXJyb3JCb3VuZGFyeSkpKCk7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcclxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXHJcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdFN0YXRlKG9iaikge1xuICB2YXIgX3IzZjtcbiAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5yb290LmdldFN0YXRlKCk7XG59XG4vLyBBIGNvbGxlY3Rpb24gb2YgY29tcGFyZSBmdW5jdGlvbnNcbmNvbnN0IGlzID0ge1xuICBvYmo6IGEgPT4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSkgJiYgdHlwZW9mIGEgIT09ICdmdW5jdGlvbicsXG4gIGZ1bjogYSA9PiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyxcbiAgc3RyOiBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJyxcbiAgbnVtOiBhID0+IHR5cGVvZiBhID09PSAnbnVtYmVyJyxcbiAgYm9vOiBhID0+IHR5cGVvZiBhID09PSAnYm9vbGVhbicsXG4gIHVuZDogYSA9PiBhID09PSB2b2lkIDAsXG4gIG51bDogYSA9PiBhID09PSBudWxsLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSB8fCBpcy5ib28oYSkpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzT2JqID0gaXMub2JqKGEpO1xuICAgIGlmIChpc09iaiAmJiBvYmplY3RzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNBcnIgPSBpcy5hcnIoYSk7XG4gICAgaWYgKGlzQXJyICYmIGFycmF5cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIC8vIEFycmF5IG9yIE9iamVjdCwgc2hhbGxvdyBjb21wYXJlIGZpcnN0IHRvIHNlZSBpZiBpdCdzIGEgbWF0Y2hcbiAgICBpZiAoKGlzQXJyIHx8IGlzT2JqKSAmJiBhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBMYXN0IHJlc29ydCwgZ28gdGhyb3VnaCBrZXlzXG4gICAgbGV0IGk7XG4gICAgLy8gQ2hlY2sgaWYgYSBoYXMgYWxsIHRoZSBrZXlzIG9mIGJcbiAgICBmb3IgKGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIHZhbHVlcyBiZXR3ZWVuIGtleXMgbWF0Y2hcbiAgICBpZiAoaXNPYmogJiYgYXJyYXlzID09PSAnc2hhbGxvdycgJiYgb2JqZWN0cyA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmICghaXMuZXF1KGFbaV0sIGJbaV0sIHtcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBvYmplY3RzOiAncmVmZXJlbmNlJ1xuICAgICAgfSkpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBpIGlzIHVuZGVmaW5lZFxuICAgIGlmIChpcy51bmQoaSkpIHtcbiAgICAgIC8vIElmIGJvdGggYXJyYXlzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNBcnIgJiYgYS5sZW5ndGggPT09IDAgJiYgYi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gSWYgYm90aCBvYmplY3RzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNPYmogJiYgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKGIpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBPdGhlcndpc2UgbWF0Y2ggdGhlbSBieSB2YWx1ZVxuICAgICAgaWYgKGEgIT09IGIpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIENvbGxlY3RzIG5vZGVzIGFuZCBtYXRlcmlhbHMgZnJvbSBhIFRIUkVFLk9iamVjdDNEXG5mdW5jdGlvbiBidWlsZEdyYXBoKG9iamVjdCkge1xuICBjb25zdCBkYXRhID0ge1xuICAgIG5vZGVzOiB7fSxcbiAgICBtYXRlcmlhbHM6IHt9XG4gIH07XG4gIGlmIChvYmplY3QpIHtcbiAgICBvYmplY3QudHJhdmVyc2Uob2JqID0+IHtcbiAgICAgIGlmIChvYmoubmFtZSkgZGF0YS5ub2Rlc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgICBpZiAob2JqLm1hdGVyaWFsICYmICFkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0pIGRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSA9IG9iai5tYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbi8vIERpc3Bvc2VzIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBkaXNwb3NlKG9iaikge1xuICBpZiAob2JqLnR5cGUgIT09ICdTY2VuZScpIG9iai5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBvYmouZGlzcG9zZSgpO1xuICBmb3IgKGNvbnN0IHAgaW4gb2JqKSB7XG4gICAgY29uc3QgcHJvcCA9IG9ialtwXTtcbiAgICBpZiAoKHByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3AudHlwZSkgIT09ICdTY2VuZScpIHByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3AuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogcHJvcC5kaXNwb3NlKCk7XG4gIH1cbn1cbmNvbnN0IFJFQUNUX0lOVEVSTkFMX1BST1BTID0gWydjaGlsZHJlbicsICdrZXknLCAncmVmJ107XG5cbi8vIEdldHMgb25seSBpbnN0YW5jZSBwcm9wcyBmcm9tIHJlY29uY2lsZXIgZmliZXJzXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVByb3BzKHF1ZXVlKSB7XG4gIGNvbnN0IHByb3BzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHF1ZXVlKSB7XG4gICAgaWYgKCFSRUFDVF9JTlRFUk5BTF9QUk9QUy5pbmNsdWRlcyhrZXkpKSBwcm9wc1trZXldID0gcXVldWVba2V5XTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBzY2VuZSBjYXJyaWVzIGEgc21hbGwgTG9jYWxTdGF0ZSBkZXNjcmlwdG9yXG5mdW5jdGlvbiBwcmVwYXJlKHRhcmdldCwgcm9vdCwgdHlwZSwgcHJvcHMpIHtcbiAgY29uc3Qgb2JqZWN0ID0gdGFyZ2V0O1xuXG4gIC8vIENyZWF0ZSBpbnN0YW5jZSBkZXNjcmlwdG9yXG4gIGxldCBpbnN0YW5jZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0Ll9fcjNmO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UgPSB7XG4gICAgICByb290LFxuICAgICAgdHlwZSxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIHByb3BzOiBnZXRJbnN0YW5jZVByb3BzKHByb3BzKSxcbiAgICAgIG9iamVjdCxcbiAgICAgIGV2ZW50Q291bnQ6IDAsXG4gICAgICBoYW5kbGVyczoge30sXG4gICAgICBpc0hpZGRlbjogZmFsc2VcbiAgICB9O1xuICAgIGlmIChvYmplY3QpIG9iamVjdC5fX3IzZiA9IGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUocm9vdCwga2V5KSB7XG4gIHZhciBfdGFyZ2V0O1xuICBsZXQgdGFyZ2V0ID0gcm9vdFtrZXldO1xuICBpZiAoIWtleS5pbmNsdWRlcygnLScpKSByZXR1cm4ge1xuICAgIHJvb3QsXG4gICAga2V5LFxuICAgIHRhcmdldFxuICB9O1xuXG4gIC8vIFJlc29sdmUgcGllcmNlZCB0YXJnZXRcbiAgY29uc3QgY2hhaW4gPSBrZXkuc3BsaXQoJy0nKTtcbiAgdGFyZ2V0ID0gY2hhaW4ucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIHJvb3QpO1xuICBrZXkgPSBjaGFpbi5wb3AoKTtcblxuICAvLyBTd2l0Y2ggcm9vdCBpZiBhdG9taWNcbiAgaWYgKCEoKF90YXJnZXQgPSB0YXJnZXQpICE9IG51bGwgJiYgX3RhcmdldC5zZXQpKSByb290ID0gY2hhaW4ucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIHJvb3QpO1xuICByZXR1cm4ge1xuICAgIHJvb3QsXG4gICAga2V5LFxuICAgIHRhcmdldFxuICB9O1xufVxuXG4vLyBDaGVja3MgaWYgYSBkYXNoLWNhc2VkIHN0cmluZyBlbmRzIHdpdGggYW4gaW50ZWdlclxuY29uc3QgSU5ERVhfUkVHRVggPSAvLVxcZCskLztcbmZ1bmN0aW9uIGF0dGFjaChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChpcy5zdHIoY2hpbGQucHJvcHMuYXR0YWNoKSkge1xuICAgIC8vIElmIGF0dGFjaGluZyBpbnRvIGFuIGFycmF5IChmb28tMCksIGNyZWF0ZSBvbmVcbiAgICBpZiAoSU5ERVhfUkVHRVgudGVzdChjaGlsZC5wcm9wcy5hdHRhY2gpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGNoaWxkLnByb3BzLmF0dGFjaC5yZXBsYWNlKElOREVYX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvb3QsXG4gICAgICAgIGtleVxuICAgICAgfSA9IHJlc29sdmUocGFyZW50Lm9iamVjdCwgaW5kZXgpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJvb3Rba2V5XSkpIHJvb3Rba2V5XSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50Lm9iamVjdCwgY2hpbGQucHJvcHMuYXR0YWNoKTtcbiAgICBjaGlsZC5wcmV2aW91c0F0dGFjaCA9IHJvb3Rba2V5XTtcbiAgICByb290W2tleV0gPSBjaGlsZC5vYmplY3Q7XG4gIH0gZWxzZSBpZiAoaXMuZnVuKGNoaWxkLnByb3BzLmF0dGFjaCkpIHtcbiAgICBjaGlsZC5wcmV2aW91c0F0dGFjaCA9IGNoaWxkLnByb3BzLmF0dGFjaChwYXJlbnQub2JqZWN0LCBjaGlsZC5vYmplY3QpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRhY2gocGFyZW50LCBjaGlsZCkge1xuICBpZiAoaXMuc3RyKGNoaWxkLnByb3BzLmF0dGFjaCkpIHtcbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50Lm9iamVjdCwgY2hpbGQucHJvcHMuYXR0YWNoKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGNoaWxkLnByZXZpb3VzQXR0YWNoO1xuICAgIC8vIFdoZW4gdGhlIHByZXZpb3VzIHZhbHVlIHdhcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoZSB2YWx1ZSB3YXMgbmV2ZXIgc2V0IHRvIGJlZ2luIHdpdGhcbiAgICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJvb3Rba2V5XTtcbiAgICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgIGVsc2Ugcm9vdFtrZXldID0gcHJldmlvdXM7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGQucHJldmlvdXNBdHRhY2ggPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLnByZXZpb3VzQXR0YWNoKHBhcmVudC5vYmplY3QsIGNoaWxkLm9iamVjdCk7XG4gIH1cbiAgZGVsZXRlIGNoaWxkLnByZXZpb3VzQXR0YWNoO1xufVxuY29uc3QgUkVTRVJWRURfUFJPUFMgPSBbLi4uUkVBQ1RfSU5URVJOQUxfUFJPUFMsXG4vLyBJbnN0YW5jZSBwcm9wc1xuJ2FyZ3MnLCAnZGlzcG9zZScsICdhdHRhY2gnLCAnb2JqZWN0JywgJ29uVXBkYXRlJyxcbi8vIEJlaGF2aW9yIGZsYWdzXG4nZGlzcG9zZSddO1xuY29uc3QgTUVNT0laRURfUFJPVE9UWVBFUyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1lbW9pemVkUHJvdG90eXBlKHJvb3QpIHtcbiAgbGV0IGN0b3IgPSBNRU1PSVpFRF9QUk9UT1RZUEVTLmdldChyb290LmNvbnN0cnVjdG9yKTtcbiAgdHJ5IHtcbiAgICBpZiAoIWN0b3IpIHtcbiAgICAgIGN0b3IgPSBuZXcgcm9vdC5jb25zdHJ1Y3RvcigpO1xuICAgICAgTUVNT0laRURfUFJPVE9UWVBFUy5zZXQocm9vdC5jb25zdHJ1Y3RvciwgY3Rvcik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gLi4uXG4gIH1cbiAgcmV0dXJuIGN0b3I7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgYSBzZXQgb2YgY2hhbmdlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gZGlmZlByb3BzKGluc3RhbmNlLCBuZXdQcm9wcykge1xuICBjb25zdCBjaGFuZ2VkUHJvcHMgPSB7fTtcblxuICAvLyBTb3J0IHRocm91Z2ggcHJvcHNcbiAgZm9yIChjb25zdCBwcm9wIGluIG5ld1Byb3BzKSB7XG4gICAgLy8gU2tpcCByZXNlcnZlZCBrZXlzXG4gICAgaWYgKFJFU0VSVkVEX1BST1BTLmluY2x1ZGVzKHByb3ApKSBjb250aW51ZTtcbiAgICAvLyBTa2lwIGlmIHByb3BzIG1hdGNoXG4gICAgaWYgKGlzLmVxdShuZXdQcm9wc1twcm9wXSwgaW5zdGFuY2UucHJvcHNbcHJvcF0pKSBjb250aW51ZTtcblxuICAgIC8vIFByb3BzIGNoYW5nZWQsIGFkZCB0aGVtXG4gICAgY2hhbmdlZFByb3BzW3Byb3BdID0gbmV3UHJvcHNbcHJvcF07XG5cbiAgICAvLyBSZXNldCBwaWVyY2VkIHByb3BzXG4gICAgZm9yIChjb25zdCBvdGhlciBpbiBuZXdQcm9wcykge1xuICAgICAgaWYgKG90aGVyLnN0YXJ0c1dpdGgoYCR7cHJvcH0tYCkpIGNoYW5nZWRQcm9wc1tvdGhlcl0gPSBuZXdQcm9wc1tvdGhlcl07XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgcmVtb3ZlZCBwcm9wcyBmb3IgSE1SXG4gIGZvciAoY29uc3QgcHJvcCBpbiBpbnN0YW5jZS5wcm9wcykge1xuICAgIGlmIChSRVNFUlZFRF9QUk9QUy5pbmNsdWRlcyhwcm9wKSB8fCBuZXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKGluc3RhbmNlLm9iamVjdCwgcHJvcCk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMTIwOVxuICAgIC8vIEhNUi9mYXN0LXJlZnJlc2ggcmVsaWVzIG9uIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCBvdXQgcHJvcHMsIGJ1dCB0aHJlZWpzXG4gICAgLy8gaGFzIG5vIG1lYW5zIHRvIGRvIHRoaXMuIEhlbmNlIHdlIGN1cmF0ZSBhIHNtYWxsIGNvbGxlY3Rpb24gb2YgdmFsdWUtY2xhc3Nlc1xuICAgIC8vIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25zdHJ1Y3Rvci9zZXQgYXJndW1lbnRzXG4gICAgLy8gRm9yIHJlbW92ZWQgcHJvcHMsIHRyeSB0byBzZXQgZGVmYXVsdCB2YWx1ZXMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHJvb3QuY29uc3RydWN0b3IgJiYgcm9vdC5jb25zdHJ1Y3Rvci5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGNyZWF0ZSBhIGJsYW5rIHNsYXRlIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29weSB0aGUgcGFydGljdWxhciBwYXJhbWV0ZXIuXG4gICAgICBjb25zdCBjdG9yID0gZ2V0TWVtb2l6ZWRQcm90b3R5cGUocm9vdCk7XG4gICAgICBpZiAoIWlzLnVuZChjdG9yKSkgY2hhbmdlZFByb3BzW2tleV0gPSBjdG9yW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgY29uc3RydWN0b3IsIGp1c3Qgc2V0IGl0IHRvIDBcbiAgICAgIGNoYW5nZWRQcm9wc1trZXldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZWRQcm9wcztcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI3MDQyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjI3NDhcbmNvbnN0IGNvbG9yTWFwcyA9IFsnbWFwJywgJ2VtaXNzaXZlTWFwJywgJ3NoZWVuQ29sb3JNYXAnLCAnc3BlY3VsYXJDb2xvck1hcCcsICdlbnZNYXAnXTtcbmNvbnN0IEVWRU5UX1JFR0VYID0gL15vbihQb2ludGVyfENsaWNrfERvdWJsZUNsaWNrfENvbnRleHRNZW51fFdoZWVsKS87XG4vLyBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgYSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGFwcGx5UHJvcHMob2JqZWN0LCBwcm9wcykge1xuICB2YXIgX2luc3RhbmNlJG9iamVjdDtcbiAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3QuX19yM2Y7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGluc3RhbmNlICYmIGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkuZ2V0U3RhdGUoKTtcbiAgY29uc3QgcHJldkhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmV2ZW50Q291bnQ7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGxldCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuXG4gICAgLy8gRG9uJ3QgbXV0YXRlIHJlc2VydmVkIGtleXNcbiAgICBpZiAoUkVTRVJWRURfUFJPUFMuaW5jbHVkZXMocHJvcCkpIGNvbnRpbnVlO1xuXG4gICAgLy8gRGVhbCB3aXRoIHBvaW50ZXIgZXZlbnRzLCBpbmNsdWRpbmcgcmVtb3ZpbmcgdGhlbSBpZiB1bmRlZmluZWRcbiAgICBpZiAoaW5zdGFuY2UgJiYgRVZFTlRfUkVHRVgudGVzdChwcm9wKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgaW5zdGFuY2UuaGFuZGxlcnNbcHJvcF0gPSB2YWx1ZTtlbHNlIGRlbGV0ZSBpbnN0YW5jZS5oYW5kbGVyc1twcm9wXTtcbiAgICAgIGluc3RhbmNlLmV2ZW50Q291bnQgPSBPYmplY3Qua2V5cyhpbnN0YW5jZS5oYW5kbGVycykubGVuZ3RoO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHNldHRpbmcgdW5kZWZpbmVkIHByb3BzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjc0XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgIGxldCB7XG4gICAgICByb290LFxuICAgICAga2V5LFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IHJlc29sdmUob2JqZWN0LCBwcm9wKTtcblxuICAgIC8vIExheWVycyBtdXN0IGJlIHdyaXR0ZW4gdG8gdGhlIG1hc2sgcHJvcGVydHlcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzICYmIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSB7XG4gICAgICB0YXJnZXQubWFzayA9IHZhbHVlLm1hc2s7XG4gICAgfVxuICAgIC8vIFNldCBjb2xvcnMgaWYgdmFsaWQgY29sb3IgcmVwcmVzZW50YXRpb24gZm9yIGF1dG9tYXRpYyBjb252ZXJzaW9uIChjb3B5KVxuICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICYmIGlzQ29sb3JSZXByZXNlbnRhdGlvbih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5zZXQodmFsdWUpO1xuICAgIH1cbiAgICAvLyBDb3B5IGlmIHByb3BlcnRpZXMgbWF0Y2ggc2lnbmF0dXJlcyBhbmQgaW1wbGVtZW50IG1hdGggaW50ZXJmYWNlIChsaWtlbHkgcmVhZC1vbmx5KVxuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdGFyZ2V0LmNvcHkgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB0YXJnZXQuY29uc3RydWN0b3IgPT09IHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICB0YXJnZXQuY29weSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNldCBhcnJheSB0eXBlc1xuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQuZnJvbUFycmF5ID09PSAnZnVuY3Rpb24nKSB0YXJnZXQuZnJvbUFycmF5KHZhbHVlKTtlbHNlIHRhcmdldC5zZXQoLi4udmFsdWUpO1xuICAgIH1cbiAgICAvLyBTZXQgbGl0ZXJhbCB0eXBlc1xuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBBbGxvdyBzZXR0aW5nIGFycmF5IHNjYWxhcnNcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LnNldFNjYWxhciA9PT0gJ2Z1bmN0aW9uJykgdGFyZ2V0LnNldFNjYWxhcih2YWx1ZSk7XG4gICAgICAvLyBPdGhlcndpc2UganVzdCBzZXQgc2luZ2xlIHZhbHVlXG4gICAgICBlbHNlIHRhcmdldC5zZXQodmFsdWUpO1xuICAgIH1cbiAgICAvLyBFbHNlLCBqdXN0IG92ZXJ3cml0ZSB0aGUgdmFsdWVcbiAgICBlbHNlIHtcbiAgICAgIHZhciBfcm9vdCRrZXk7XG4gICAgICByb290W2tleV0gPSB2YWx1ZTtcblxuICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgdGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBidWlsdC1pbiBtYXRlcmlhbHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1ODU3XG4gICAgICBpZiAocm9vdFN0YXRlICYmICFyb290U3RhdGUubGluZWFyICYmIGNvbG9yTWFwcy5pbmNsdWRlcyhrZXkpICYmIChfcm9vdCRrZXkgPSByb290W2tleV0pICE9IG51bGwgJiYgX3Jvb3Qka2V5LmlzVGV4dHVyZSAmJlxuICAgICAgLy8gc1JHQiB0ZXh0dXJlcyBtdXN0IGJlIFJHQkE4IHNpbmNlIHIxMzcgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzMTI5XG4gICAgICByb290W2tleV0uZm9ybWF0ID09PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHJvb3Rba2V5XS50eXBlID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlKSB7XG4gICAgICAgIC8vIE5PVEU6IHRoaXMgY2Fubm90IGJlIHNldCBmcm9tIHRoZSByZW5kZXJlciAoZS5nLiBzUkdCIHNvdXJjZSB0ZXh0dXJlcyByZW5kZXJlZCB0byBQMylcbiAgICAgICAgcm9vdFtrZXldLmNvbG9yU3BhY2UgPSBUSFJFRS5TUkdCQ29sb3JTcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5wYXJlbnQgJiYgcm9vdFN0YXRlICE9IG51bGwgJiYgcm9vdFN0YXRlLmludGVybmFsICYmIChfaW5zdGFuY2Ukb2JqZWN0ID0gaW5zdGFuY2Uub2JqZWN0KSAhPSBudWxsICYmIF9pbnN0YW5jZSRvYmplY3QuaXNPYmplY3QzRCAmJiBwcmV2SGFuZGxlcnMgIT09IGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICBjb25zdCBvYmplY3QgPSBpbnN0YW5jZS5vYmplY3Q7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5pbmRleE9mKG9iamVjdCk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChpbnN0YW5jZS5ldmVudENvdW50ICYmIG9iamVjdC5yYXljYXN0ICE9PSBudWxsKSB7XG4gICAgICByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8tYXR0YWNoIGdlb21ldHJpZXMgYW5kIG1hdGVyaWFsc1xuICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJvcHMuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaW5zdGFuY2Uub2JqZWN0LmlzQnVmZmVyR2VvbWV0cnkpIGluc3RhbmNlLnByb3BzLmF0dGFjaCA9ICdnZW9tZXRyeSc7ZWxzZSBpZiAoaW5zdGFuY2Uub2JqZWN0LmlzTWF0ZXJpYWwpIGluc3RhbmNlLnByb3BzLmF0dGFjaCA9ICdtYXRlcmlhbCc7XG4gIH1cblxuICAvLyBJbnN0YW5jZSB3YXMgdXBkYXRlZCwgcmVxdWVzdCBhIGZyYW1lXG4gIGlmIChpbnN0YW5jZSkgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJHJvb3Q7XG4gIGlmICghaW5zdGFuY2UucGFyZW50KSByZXR1cm47XG4gIGluc3RhbmNlLnByb3BzLm9uVXBkYXRlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5wcm9wcy5vblVwZGF0ZShpbnN0YW5jZS5vYmplY3QpO1xuICBjb25zdCBzdGF0ZSA9IChfaW5zdGFuY2Ukcm9vdCA9IGluc3RhbmNlLnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2Ukcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmludGVybmFsLmZyYW1lcyA9PT0gMCkgc3RhdGUuaW52YWxpZGF0ZSgpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICBpZiAoY2FtZXJhLm1hbnVhbCkgcmV0dXJuO1xuICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgIGNhbWVyYS5sZWZ0ID0gc2l6ZS53aWR0aCAvIC0yO1xuICAgIGNhbWVyYS5yaWdodCA9IHNpemUud2lkdGggLyAyO1xuICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgY2FtZXJhLmJvdHRvbSA9IHNpemUuaGVpZ2h0IC8gLTI7XG4gIH0gZWxzZSB7XG4gICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgfVxuICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xufVxuY29uc3QgaXNPYmplY3QzRCA9IG9iamVjdCA9PiBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdC5pc09iamVjdDNEO1xuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8qKlxyXG4gKiBSZWxlYXNlIHBvaW50ZXIgY2FwdHVyZXMuXHJcbiAqIFRoaXMgaXMgY2FsbGVkIGJ5IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSBpbiB0aGUgQVBJLCBhbmQgd2hlbiBhbiBvYmplY3QgaXMgcmVtb3ZlZC5cclxuICovXG5mdW5jdGlvbiByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShjYXB0dXJlZE1hcCwgb2JqLCBjYXB0dXJlcywgcG9pbnRlcklkKSB7XG4gIGNvbnN0IGNhcHR1cmVEYXRhID0gY2FwdHVyZXMuZ2V0KG9iaik7XG4gIGlmIChjYXB0dXJlRGF0YSkge1xuICAgIGNhcHR1cmVzLmRlbGV0ZShvYmopO1xuICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IGNhcHR1cmluZyBvYmplY3QgZm9yIHRoaXMgcG9pbnRlclxuICAgIGlmIChjYXB0dXJlcy5zaXplID09PSAwKSB7XG4gICAgICBjYXB0dXJlZE1hcC5kZWxldGUocG9pbnRlcklkKTtcbiAgICAgIGNhcHR1cmVEYXRhLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUocG9pbnRlcklkKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUludGVyYWN0aXZpdHkoc3RvcmUsIG9iamVjdCkge1xuICBjb25zdCB7XG4gICAgaW50ZXJuYWxcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIC8vIFJlbW92ZXMgZXZlcnkgdHJhY2Ugb2YgYW4gb2JqZWN0IGZyb20gdGhlIGRhdGEgc3RvcmVcbiAgaW50ZXJuYWwuaW50ZXJhY3Rpb24gPSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGludGVybmFsLmluaXRpYWxIaXRzLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmhvdmVyZWQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh2YWx1ZS5ldmVudE9iamVjdCA9PT0gb2JqZWN0IHx8IHZhbHVlLm9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfSk7XG4gIGludGVybmFsLmNhcHR1cmVkTWFwLmZvckVhY2goKGNhcHR1cmVzLCBwb2ludGVySWQpID0+IHtcbiAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShpbnRlcm5hbC5jYXB0dXJlZE1hcCwgb2JqZWN0LCBjYXB0dXJlcywgcG9pbnRlcklkKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudHMoc3RvcmUpIHtcbiAgLyoqIENhbGN1bGF0ZXMgZGVsdGEgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGR4ID0gZXZlbnQub2Zmc2V0WCAtIGludGVybmFsLmluaXRpYWxDbGlja1swXTtcbiAgICBjb25zdCBkeSA9IGV2ZW50Lm9mZnNldFkgLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMV07XG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSk7XG4gIH1cblxuICAvKiogUmV0dXJucyB0cnVlIGlmIGFuIGluc3RhbmNlIGhhcyBhIHZhbGlkIHBvaW50ZXItZXZlbnQgcmVnaXN0ZXJlZCwgdGhpcyBleGNsdWRlcyBzY3JvbGwsIGNsaWNrcyBldGMgKi9cbiAgZnVuY3Rpb24gZmlsdGVyUG9pbnRlckV2ZW50cyhvYmplY3RzKSB7XG4gICAgcmV0dXJuIG9iamVjdHMuZmlsdGVyKG9iaiA9PiBbJ01vdmUnLCAnT3ZlcicsICdFbnRlcicsICdPdXQnLCAnTGVhdmUnXS5zb21lKG5hbWUgPT4ge1xuICAgICAgdmFyIF9yM2Y7XG4gICAgICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLmhhbmRsZXJzWydvblBvaW50ZXInICsgbmFtZV07XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGludGVyc2VjdChldmVudCwgZmlsdGVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIC8vIEFsbG93IGNhbGxlcnMgdG8gZWxpbWluYXRlIGV2ZW50IG9iamVjdHNcbiAgICBjb25zdCBldmVudHNPYmplY3RzID0gZmlsdGVyID8gZmlsdGVyKHN0YXRlLmludGVybmFsLmludGVyYWN0aW9uKSA6IHN0YXRlLmludGVybmFsLmludGVyYWN0aW9uO1xuICAgIC8vIFJlc2V0IGFsbCByYXljYXN0ZXIgY2FtZXJhcyB0byB1bmRlZmluZWRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50c09iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKGV2ZW50c09iamVjdHNbaV0pO1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhdGUucHJldmlvdXNSb290KSB7XG4gICAgICAvLyBNYWtlIHN1cmUgcm9vdC1sZXZlbCBwb2ludGVyIGFuZCByYXkgYXJlIHNldCB1cFxuICAgICAgc3RhdGUuZXZlbnRzLmNvbXB1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb21wdXRlKGV2ZW50LCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJheWNhc3Qob2JqKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShvYmopO1xuICAgICAgLy8gU2tpcCBldmVudCBoYW5kbGluZyB3aGVuIG5vRXZlbnRzIGlzIHNldCwgb3Igd2hlbiB0aGUgcmF5Y2FzdGVycyBjYW1lcmEgaXMgbnVsbFxuICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuZXZlbnRzLmVuYWJsZWQgfHwgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gICAgICAvLyBXaGVuIHRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkIHdlIGhhdmUgdG8gY2FsbCB0aGUgZXZlbnQgbGF5ZXJzIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3N0YXRlJHByZXZpb3VzUm9vdDtcbiAgICAgICAgc3RhdGUuZXZlbnRzLmNvbXB1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb21wdXRlKGV2ZW50LCBzdGF0ZSwgKF9zdGF0ZSRwcmV2aW91c1Jvb3QgPSBzdGF0ZS5wcmV2aW91c1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkcHJldmlvdXNSb290LmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBJZiB0aGUgY2FtZXJhIGlzIHN0aWxsIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIHNraXAgdGhpcyBsYXllciBlbnRpcmVseVxuICAgICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJzZWN0IG9iamVjdCBieSBvYmplY3RcbiAgICAgIHJldHVybiBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID8gc3RhdGUucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdChvYmosIHRydWUpIDogW107XG4gICAgfVxuXG4gICAgLy8gQ29sbGVjdCBldmVudHNcbiAgICBsZXQgaGl0cyA9IGV2ZW50c09iamVjdHNcbiAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0c1xuICAgIC5mbGF0TWFwKGhhbmRsZVJheWNhc3QpXG4gICAgLy8gU29ydCBieSBldmVudCBwcmlvcml0eSBhbmQgZGlzdGFuY2VcbiAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYVN0YXRlID0gZ2V0Um9vdFN0YXRlKGEub2JqZWN0KTtcbiAgICAgIGNvbnN0IGJTdGF0ZSA9IGdldFJvb3RTdGF0ZShiLm9iamVjdCk7XG4gICAgICBpZiAoIWFTdGF0ZSB8fCAhYlN0YXRlKSByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG4gICAgICByZXR1cm4gYlN0YXRlLmV2ZW50cy5wcmlvcml0eSAtIGFTdGF0ZS5ldmVudHMucHJpb3JpdHkgfHwgYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG4gICAgfSlcbiAgICAvLyBGaWx0ZXIgb3V0IGR1cGxpY2F0ZXNcbiAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgaWQgPSBtYWtlSWQoaXRlbSk7XG4gICAgICBpZiAoZHVwbGljYXRlcy5oYXMoaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgICBkdXBsaWNhdGVzLmFkZChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE2MDMxXG4gICAgLy8gQWxsb3cgY3VzdG9tIHVzZXJsYW5kIGludGVyc2VjdCBzb3J0IG9yZGVyLCB0aGlzIGxpa2VseSBvbmx5IG1ha2VzIHNlbnNlIG9uIHRoZSByb290IGZpbHRlclxuICAgIGlmIChzdGF0ZS5ldmVudHMuZmlsdGVyKSBoaXRzID0gc3RhdGUuZXZlbnRzLmZpbHRlcihoaXRzLCBzdGF0ZSk7XG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGV2ZW50cywgZmluZCB0aGUgZXZlbnQgc291cmNlIChldmVudE9iamVjdClcbiAgICBmb3IgKGNvbnN0IGhpdCBvZiBoaXRzKSB7XG4gICAgICBsZXQgZXZlbnRPYmplY3QgPSBoaXQub2JqZWN0O1xuICAgICAgLy8gQnViYmxlIGV2ZW50IHVwXG4gICAgICB3aGlsZSAoZXZlbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIF9yM2YyO1xuICAgICAgICBpZiAoKF9yM2YyID0gZXZlbnRPYmplY3QuX19yM2YpICE9IG51bGwgJiYgX3IzZjIuZXZlbnRDb3VudCkgaW50ZXJzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgZXZlbnRPYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50T2JqZWN0ID0gZXZlbnRPYmplY3QucGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBpbnRlcmFjdGlvbiBpcyBjYXB0dXJlZCwgbWFrZSBhbGwgY2FwdHVyaW5nIHRhcmdldHMgcGFydCBvZiB0aGUgaW50ZXJzZWN0LlxuICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgZm9yIChsZXQgY2FwdHVyZURhdGEgb2Ygc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCkudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKCFkdXBsaWNhdGVzLmhhcyhtYWtlSWQoY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKSkpIGludGVyc2VjdGlvbnMucHVzaChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuXG4gIC8qKiAgSGFuZGxlcyBpbnRlcnNlY3Rpb25zIGJ5IGZvcndhcmRpbmcgdGhlbSB0byBoYW5kbGVycyAqL1xuICBmdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3RzKGludGVyc2VjdGlvbnMsIGV2ZW50LCBkZWx0YSwgY2FsbGJhY2spIHtcbiAgICAvLyBJZiBhbnl0aGluZyBoYXMgYmVlbiBmb3VuZCwgZm9yd2FyZCBpdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKGhpdC5vYmplY3QpO1xuXG4gICAgICAgIC8vIElmIHRoZSBvYmplY3QgaXMgbm90IG1hbmFnZWQgYnkgUjNGLCBpdCBtaWdodCBiZSBwYXJlbnRlZCB0byBhbiBlbGVtZW50IHdoaWNoIGlzLlxuICAgICAgICAvLyBUcmF2ZXJzZSB1cHdhcmRzIHVudGlsIHdlIGZpbmQgYSBtYW5hZ2VkIHBhcmVudCBhbmQgdXNlIGl0cyBzdGF0ZSBpbnN0ZWFkLlxuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgaGl0Lm9iamVjdC50cmF2ZXJzZUFuY2VzdG9ycyhvYmogPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50U3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IHBhcmVudFN0YXRlO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgIGNhbWVyYSxcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICAgIGNvbnN0IHVucHJvamVjdGVkUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb2ludGVyLngsIHBvaW50ZXIueSwgMCkudW5wcm9qZWN0KGNhbWVyYSk7XG4gICAgICAgICAgY29uc3QgaGFzUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgICAgcmV0dXJuIChfaW50ZXJuYWwkY2FwdHVyZWRNYXAgPSAoX2ludGVybmFsJGNhcHR1cmVkTWFwMiA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSAhPSBudWxsID8gX2ludGVybmFsJGNhcHR1cmVkTWFwIDogZmFsc2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVEYXRhID0ge1xuICAgICAgICAgICAgICBpbnRlcnNlY3Rpb246IGhpdCxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgICAgLy8gZXZlbnQgY2FwdHVyZWRNYXAuXG4gICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkuc2V0KGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgbm90IHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGNyZWF0ZSBhIG1hcFxuICAgICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBoaXRPYmplY3QsIGFuZCB0aGUgaGl0LiBoaXRPYmplY3QgaXMgdXNlZCBmb3JcbiAgICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuc2V0KGlkLCBuZXcgTWFwKFtbaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgcmVsZWFzZVBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVzLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEFkZCBuYXRpdmUgZXZlbnQgcHJvcHNcbiAgICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgICAvLyBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGV2ZW50J3MgcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIGluaGVyaXRlZCBvbmVzLiBOYXRpdmUgUG9pbnRlckV2ZW50cyBoYXZlIG1vc3Qgb2YgdGhlaXIgcHJvcHMgYXMgZ2V0dGVycyB3aGljaCBhcmUgaW5oZXJpdGVkLCBidXQgcG9seWZpbGxlZCBQb2ludGVyRXZlbnRzIGhhdmUgdGhlbSBhbGwgYXMgdGhlaXIgb3duIHByb3BlcnRpZXMgKGkuZS4gbm90IGluaGVyaXRlZCkuIFdlIGNhbid0IHVzZSBPYmplY3Qua2V5cygpIG9yIE9iamVjdC5lbnRyaWVzKCkgYXMgdGhleSBvbmx5IHJldHVybiBcIm93blwiIHByb3BlcnRpZXM7IG5vciBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpIGFzIHRoYXQgKmRvZXNuJ3QqIHJldHVybiBcIm93blwiIHByb3BlcnRpZXMsIG9ubHkgaW5oZXJpdGVkIG9uZXMuXG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgICAvLyBPbmx5IGNvcHkgb3ZlciBhdG9taWNzLCBsZWF2ZSBmdW5jdGlvbnMgYWxvbmUgYXMgdGhlc2Ugc2hvdWxkIGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgYXMgZXZlbnQubmF0aXZlRXZlbnQuZm4oKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJheWNhc3RFdmVudCA9IHtcbiAgICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAgIC4uLmV4dHJhY3RFdmVudFByb3BzLFxuICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgICBzdG9wcGVkOiBsb2NhbFN0YXRlLnN0b3BwZWQsXG4gICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgICByYXk6IHJheWNhc3Rlci5yYXksXG4gICAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvNTk2XG4gICAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlc0ZvclBvaW50ZXIgPSAncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKTtcblxuICAgICAgICAgICAgICAvLyBXZSBvbmx5IGF1dGhvcml6ZSBzdG9wUHJvcGFnYXRpb24uLi5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyAuLi5pZiB0aGlzIHBvaW50ZXIgaGFzbid0IGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgICAgIWNhcHR1cmVzRm9yUG9pbnRlciB8fFxuICAgICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICAgIGNhcHR1cmVzRm9yUG9pbnRlci5oYXMoaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJheWNhc3RFdmVudC5zdG9wcGVkID0gbG9jYWxTdGF0ZS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCBoYW5kbGVyIGlzIG9ubHkgYWxsb3dlZCB0byBmbHVzaCBvdGhlciBoYW5kbGVycyBpZiBpdCBpcyBob3ZlcmVkIGl0c2VsZlxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5ob3ZlcmVkLnNpemUgJiYgQXJyYXkuZnJvbShpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKS5maW5kKGkgPT4gaS5ldmVudE9iamVjdCA9PT0gaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hlciA9IGludGVyc2VjdGlvbnMuc2xpY2UoMCwgaW50ZXJzZWN0aW9ucy5pbmRleE9mKGhpdCkpO1xuICAgICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbLi4uaGlnaGVyLCBoaXRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBDYWxsIHN1YnNjcmliZXJzXG4gICAgICAgICAgY2FsbGJhY2socmF5Y2FzdEV2ZW50KTtcbiAgICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgICAgaWYgKGxvY2FsU3RhdGUuc3RvcHBlZCA9PT0gdHJ1ZSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsUG9pbnRlcihpbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBmb3IgKGNvbnN0IGhvdmVyZWRPYmogb2YgaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkge1xuICAgICAgLy8gV2hlbiBubyBvYmplY3RzIHdlcmUgaGl0IG9yIHRoZSB0aGUgaG92ZXJlZCBvYmplY3Qgd2Fzbid0IGZvdW5kIHVuZGVybmVhdGggdGhlIGN1cnNvclxuICAgICAgLy8gd2UgY2FsbCBvblBvaW50ZXJPdXQgYW5kIGRlbGV0ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGhvdmVyZWQtZWxlbWVudHMgbWFwXG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMubGVuZ3RoIHx8ICFpbnRlcnNlY3Rpb25zLmZpbmQoaGl0ID0+IGhpdC5vYmplY3QgPT09IGhvdmVyZWRPYmoub2JqZWN0ICYmIGhpdC5pbmRleCA9PT0gaG92ZXJlZE9iai5pbmRleCAmJiBoaXQuaW5zdGFuY2VJZCA9PT0gaG92ZXJlZE9iai5pbnN0YW5jZUlkKSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGhvdmVyZWRPYmouZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlLmhhbmRsZXJzO1xuICAgICAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgLi4uaG92ZXJlZE9iaixcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck91dCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyT3V0KGRhdGEpO1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyTWlzc2VkKGV2ZW50LCBvYmplY3RzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdHNbaV0uX19yM2Y7XG4gICAgICBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyKG5hbWUpIHtcbiAgICAvLyBEZWFsIHdpdGggY2FuY2VsYXRpb25cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ29uUG9pbnRlckxlYXZlJzpcbiAgICAgIGNhc2UgJ29uUG9pbnRlckNhbmNlbCc6XG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgIGNhc2UgJ29uTG9zdFBvaW50ZXJDYXB0dXJlJzpcbiAgICAgICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBldmVudCBpbnRlcmZhY2UgaGFkIG9uTG9zdFBvaW50ZXJDYXB0dXJlLCB3ZSdkIGNhbGwgaXQgaGVyZSBvbiBldmVyeVxuICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQncyBnZXR0aW5nIHJlbW92ZWQuIFdlIGNhbGwgaXQgb24gdGhlIG5leHQgZnJhbWUgYmVjYXVzZSBvbkxvc3RQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgLy8gZmlyZXMgYmVmb3JlIG9uUG9pbnRlclVwLiBPdGhlcndpc2UgcG9pbnRlclVwIHdvdWxkIG5ldmVyIGJlIGNhbGxlZCBpZiB0aGUgZXZlbnQgZGlkbid0XG4gICAgICAgICAgICAvLyBoYXBwZW4gaW4gdGhlIG9iamVjdCBpdCBvcmlnaW5hdGVkIGZyb20sIGxlYXZpbmcgY29tcG9uZW50cyBpbiBhIGluLWJldHdlZW4gc3RhdGUuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBPbmx5IHJlbGVhc2UgaWYgcG9pbnRlci11cCBkaWRuJ3QgZG8gaXQgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5kZWxldGUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFueSBvdGhlciBwb2ludGVyIGdvZXMgaGVyZSAuLi5cbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIHByZXBhcmVSYXkoZXZlbnQpXG4gICAgICBpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCA9IGV2ZW50O1xuXG4gICAgICAvLyBHZXQgZnJlc2ggaW50ZXJzZWN0c1xuICAgICAgY29uc3QgaXNQb2ludGVyTW92ZSA9IG5hbWUgPT09ICdvblBvaW50ZXJNb3ZlJztcbiAgICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IG5hbWUgPT09ICdvbkNsaWNrJyB8fCBuYW1lID09PSAnb25Db250ZXh0TWVudScgfHwgbmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snO1xuICAgICAgY29uc3QgZmlsdGVyID0gaXNQb2ludGVyTW92ZSA/IGZpbHRlclBvaW50ZXJFdmVudHMgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBoaXRzID0gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpO1xuICAgICAgY29uc3QgZGVsdGEgPSBpc0NsaWNrRXZlbnQgPyBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkgOiAwO1xuXG4gICAgICAvLyBTYXZlIGluaXRpYWwgY29vcmRpbmF0ZXMgb24gcG9pbnRlci1kb3duXG4gICAgICBpZiAobmFtZSA9PT0gJ29uUG9pbnRlckRvd24nKSB7XG4gICAgICAgIGludGVybmFsLmluaXRpYWxDbGljayA9IFtldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBoaXRzLm1hcChoaXQgPT4gaGl0LmV2ZW50T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSBjbGljayB5aWVsZHMgbm8gcmVzdWx0cywgcGFzcyBpdCBiYWNrIHRvIHRoZSB1c2VyIGFzIGEgbWlzc1xuICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3QgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIHVzZXItbGFuZCBzaWRlLWVmZmVjdCBjbGVhbiB1cFxuICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiAhaGl0cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRlbHRhIDw9IDIpIHtcbiAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbik7XG4gICAgICAgICAgaWYgKG9uUG9pbnRlck1pc3NlZCkgb25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVGFrZSBjYXJlIG9mIHVuaG92ZXJcbiAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSBjYW5jZWxQb2ludGVyKGhpdHMpO1xuICAgICAgZnVuY3Rpb24gb25JbnRlcnNlY3QoZGF0YSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGRhdGEuZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2Ugb2YgaGFuZGxlcnNcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlLmhhbmRsZXJzO1xuXG4gICAgICAgIC8qXHJcbiAgICAgICAgTUFZQkUgVE9ETywgREVMRVRFIElGIE5PVDogXHJcbiAgICAgICAgICBDaGVjayBpZiB0aGUgb2JqZWN0IGlzIGNhcHR1cmVkLCBjYXB0dXJlZCBldmVudHMgc2hvdWxkIG5vdCBoYXZlIGludGVyc2VjdHMgcnVubmluZyBpbiBwYXJhbGxlbFxyXG4gICAgICAgICAgQnV0IHdvdWxkbid0IGl0IGJlIGJldHRlciB0byBqdXN0IHJlcGxhY2UgY2FwdHVyZWRNYXAgd2l0aCBhIHNpbmdsZSBlbnRyeT9cclxuICAgICAgICAgIEFsc28sIGFyZSB3ZSBPSyB3aXRoIHN0cmFpZ2h0IHVwIG1ha2luZyBwaWNraW5nIHVwIG11bHRpcGxlIG9iamVjdHMgaW1wb3NzaWJsZT9cclxuICAgICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IChkYXRhIGFzIFRocmVlRXZlbnQ8UG9pbnRlckV2ZW50PikucG9pbnRlcklkICAgICAgICBcclxuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNhcHR1cmVkTWVzaFNldCA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChwb2ludGVySWQpXHJcbiAgICAgICAgICBpZiAoY2FwdHVyZWRNZXNoU2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZWRNZXNoU2V0LmdldChldmVudE9iamVjdClcclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVkICYmIGNhcHR1cmVkLmxvY2FsU3RhdGUuc3RvcHBlZCkgcmV0dXJuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZW50IC4uLlxuICAgICAgICAgIGlmIChoYW5kbGVycy5vblBvaW50ZXJPdmVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlck91dCB8fCBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck92ZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckVudGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJFbnRlcihkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck1vdmUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgYWxsIGV2ZW50cyBiYWNrIHRvIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNsaWNrIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgICAgaWYgKCFpc0NsaWNrRXZlbnQgfHwgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgICAgLy8gTm93IGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvblBvaW50ZXJNaXNzZWQgb24gYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBwb2ludGVyIG92ZXIvb3V0IGhhbmRsZXJzLCBidXQgbm90IGNsaWNrIGFuZCB3ZXJlbid0IGhpdFxuICAgICAgICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlSW50ZXJzZWN0cyhoaXRzLCBldmVudCwgZGVsdGEsIG9uSW50ZXJzZWN0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9O1xufVxuXG5jb25zdCBpc1JlbmRlcmVyID0gZGVmID0+ICEhKGRlZiAhPSBudWxsICYmIGRlZi5yZW5kZXIpO1xuY29uc3QgY29udGV4dCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdG9yZSA9IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCBkZWZhdWx0VGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0ZW1wVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhID0gZ2V0KCkuY2FtZXJhLCB0YXJnZXQgPSBkZWZhdWx0VGFyZ2V0LCBzaXplID0gZ2V0KCkuc2l6ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnRcbiAgICAgIH0gPSBzaXplO1xuICAgICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICBpZiAodGFyZ2V0LmlzVmVjdG9yMykgdGVtcFRhcmdldC5jb3B5KHRhcmdldCk7ZWxzZSB0ZW1wVGFyZ2V0LnNldCguLi50YXJnZXQpO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmEuZ2V0V29ybGRQb3NpdGlvbihwb3NpdGlvbikuZGlzdGFuY2VUbyh0ZW1wVGFyZ2V0KTtcbiAgICAgIGlmIChpc09ydGhvZ3JhcGhpY0NhbWVyYShjYW1lcmEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoIC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IDEsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmb3YgPSBjYW1lcmEuZm92ICogTWF0aC5QSSAvIDE4MDsgLy8gY29udmVydCB2ZXJ0aWNhbCBmb3YgdG8gcmFkaWFuc1xuICAgICAgICBjb25zdCBoID0gMiAqIE1hdGgudGFuKGZvdiAvIDIpICogZGlzdGFuY2U7IC8vIHZpc2libGUgaGVpZ2h0XG4gICAgICAgIGNvbnN0IHcgPSBoICogKHdpZHRoIC8gaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiB3aWR0aCAvIHcsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwZXJmb3JtYW5jZVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2V0UGVyZm9ybWFuY2VDdXJyZW50ID0gY3VycmVudCA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICBjdXJyZW50XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBvaW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHtcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIE1vY2sgb2JqZWN0cyB0aGF0IGhhdmUgdG8gYmUgY29uZmlndXJlZFxuICAgICAgZ2w6IG51bGwsXG4gICAgICBjYW1lcmE6IG51bGwsXG4gICAgICByYXljYXN0ZXI6IG51bGwsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgcHJpb3JpdHk6IDEsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvbm5lY3RlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIHhyOiBudWxsLFxuICAgICAgaW52YWxpZGF0ZTogKGZyYW1lcyA9IDEpID0+IGludmFsaWRhdGUoZ2V0KCksIGZyYW1lcyksXG4gICAgICBhZHZhbmNlOiAodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzKSA9PiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cywgZ2V0KCkpLFxuICAgICAgbGVnYWN5OiBmYWxzZSxcbiAgICAgIGxpbmVhcjogZmFsc2UsXG4gICAgICBmbGF0OiBmYWxzZSxcbiAgICAgIGNvbnRyb2xzOiBudWxsLFxuICAgICAgY2xvY2s6IG5ldyBUSFJFRS5DbG9jaygpLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgZnJhbWVsb29wOiAnYWx3YXlzJyxcbiAgICAgIG9uUG9pbnRlck1pc3NlZDogdW5kZWZpbmVkLFxuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgY3VycmVudDogMSxcbiAgICAgICAgbWluOiAwLjUsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgZGVib3VuY2U6IDIwMCxcbiAgICAgICAgcmVncmVzczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGltZW91dFxuICAgICAgICAgIGlmIChwZXJmb3JtYW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChwZXJmb3JtYW5jZVRpbWVvdXQpO1xuICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBwZXJmb3JtYW5jZVxuICAgICAgICAgIGlmIChzdGF0ZS5wZXJmb3JtYW5jZS5jdXJyZW50ICE9PSBzdGF0ZS5wZXJmb3JtYW5jZS5taW4pIHNldFBlcmZvcm1hbmNlQ3VycmVudChzdGF0ZS5wZXJmb3JtYW5jZS5taW4pO1xuICAgICAgICAgIC8vIEdvIGJhY2sgdG8gdXBwZXIgYm91bmQgcGVyZm9ybWFuY2UgYWZ0ZXIgYSB3aGlsZSB1bmxlc3Mgc29tZXRoaW5nIHJlZ3Jlc3NlcyBtZWFud2hpbGVcbiAgICAgICAgICBwZXJmb3JtYW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFBlcmZvcm1hbmNlQ3VycmVudChnZXQoKS5wZXJmb3JtYW5jZS5tYXgpLCBzdGF0ZS5wZXJmb3JtYW5jZS5kZWJvdW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGluaXRpYWxEcHI6IDAsXG4gICAgICAgIGRwcjogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBhc3BlY3Q6IDAsXG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBmYWN0b3I6IDAsXG4gICAgICAgIGdldEN1cnJlbnRWaWV3cG9ydFxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSksXG4gICAgICBzZXRTaXplOiAod2lkdGgsIGhlaWdodCwgdG9wID0gMCwgbGVmdCA9IDApID0+IHtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gZ2V0KCkuY2FtZXJhO1xuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdFxuICAgICAgICB9O1xuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIC4uLmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIGRlZmF1bHRUYXJnZXQsIHNpemUpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgc2V0RHByOiBkcHIgPT4gc2V0KHN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBjYWxjdWxhdGVEcHIoZHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICBkcHI6IHJlc29sdmVkLFxuICAgICAgICAgICAgaW5pdGlhbERwcjogc3RhdGUudmlld3BvcnQuaW5pdGlhbERwciB8fCByZXNvbHZlZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgc2V0RnJhbWVsb29wOiAoZnJhbWVsb29wID0gJ2Fsd2F5cycpID0+IHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBnZXQoKS5jbG9jaztcblxuICAgICAgICAvLyBpZiBmcmFtZWxvb3AgPT09IFwibmV2ZXJcIiBjbG9jay5lbGFwc2VkVGltZSBpcyB1cGRhdGVkIHVzaW5nIGFkdmFuY2UodGltZXN0YW1wKVxuICAgICAgICBjbG9jay5zdG9wKCk7XG4gICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgaWYgKGZyYW1lbG9vcCAhPT0gJ25ldmVyJykge1xuICAgICAgICAgIGNsb2NrLnN0YXJ0KCk7XG4gICAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNldCgoKSA9PiAoe1xuICAgICAgICAgIGZyYW1lbG9vcFxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgcHJldmlvdXNSb290OiB1bmRlZmluZWQsXG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgaW50ZXJhY3Rpb246IFtdLFxuICAgICAgICBob3ZlcmVkOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgaW5pdGlhbENsaWNrOiBbMCwgMF0sXG4gICAgICAgIGluaXRpYWxIaXRzOiBbXSxcbiAgICAgICAgY2FwdHVyZWRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgbGFzdEV2ZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCksXG4gICAgICAgIC8vIFVwZGF0ZXNcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZnJhbWVzOiAwLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgc3Vic2NyaWJlOiAocmVmLCBwcmlvcml0eSwgc3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIHdlIHN3aXRjaCBvZmYgYXV0b21hdGljIHJlbmRlcmluZyBhbmQgaW5jcmVhc2UgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGlzIGZsYWcgaXMgcG9zaXRpdmUgdGhlcmUgY2FuIGJlIG5vIGludGVybmFsIHJlbmRlcmluZyBhdCBhbGxcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHJlbmRlciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSArIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3Vic2NyaWJlciBhbmQgc29ydCBsYXllcnMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgbWVhbmluZyxcbiAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5IHJlbmRlcnMgbGFzdCAob24gdG9wIG9mIHRoZSBvdGhlciBmcmFtZXMpXG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCAmJiBpbnRlcm5hbC5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAvLyBEZWNyZWFzZSBtYW51YWwgZmxhZyBpZiB0aGlzIHN1YnNjcmlwdGlvbiBoYWQgYSBwcmlvcml0eVxuICAgICAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5IC0gKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuZmlsdGVyKHMgPT4gcy5yZWYgIT09IHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJvb3RTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gcm9vdFN0b3JlLmdldFN0YXRlKCk7XG4gIGxldCBvbGRTaXplID0gc3RhdGUuc2l6ZTtcbiAgbGV0IG9sZERwciA9IHN0YXRlLnZpZXdwb3J0LmRwcjtcbiAgbGV0IG9sZENhbWVyYSA9IHN0YXRlLmNhbWVyYTtcbiAgcm9vdFN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZXJhLFxuICAgICAgc2l6ZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZ2wsXG4gICAgICBzZXRcbiAgICB9ID0gcm9vdFN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBSZXNpemUgY2FtZXJhIGFuZCByZW5kZXJlciBvbiBjaGFuZ2VzIHRvIHNpemUgYW5kIHBpeGVscmF0aW9cbiAgICBpZiAoc2l6ZS53aWR0aCAhPT0gb2xkU2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gb2xkU2l6ZS5oZWlnaHQgfHwgdmlld3BvcnQuZHByICE9PSBvbGREcHIpIHtcbiAgICAgIG9sZFNpemUgPSBzaXplO1xuICAgICAgb2xkRHByID0gdmlld3BvcnQuZHByO1xuICAgICAgLy8gVXBkYXRlIGNhbWVyYSAmIHJlbmRlcmVyXG4gICAgICB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICAgIGlmICh2aWV3cG9ydC5kcHIgPiAwKSBnbC5zZXRQaXhlbFJhdGlvKHZpZXdwb3J0LmRwcik7XG4gICAgICBjb25zdCB1cGRhdGVTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wuZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgZ2wuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdXBkYXRlU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3cG9ydCBvbmNlIHRoZSBjYW1lcmEgY2hhbmdlc1xuICAgIGlmIChjYW1lcmEgIT09IG9sZENhbWVyYSkge1xuICAgICAgb2xkQ2FtZXJhID0gY2FtZXJhO1xuICAgICAgLy8gVXBkYXRlIHZpZXdwb3J0XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhKVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbnZhbGlkYXRlIG9uIGFueSBjaGFuZ2VcbiAgcm9vdFN0b3JlLnN1YnNjcmliZShzdGF0ZSA9PiBpbnZhbGlkYXRlKHN0YXRlKSk7XG5cbiAgLy8gUmV0dXJuIHJvb3Qgc3RhdGVcbiAgcmV0dXJuIHJvb3RTdG9yZTtcbn07XG5cbi8qKlxyXG4gKiBFeHBvc2VzIGFuIG9iamVjdCdzIHtAbGluayBJbnN0YW5jZX0uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyN1c2VJbnN0YW5jZUhhbmRsZVxyXG4gKlxyXG4gKiAqKk5vdGUqKjogdGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggdG8gcmVhY3QtaW50ZXJuYWwgZmllbGRzLiBFeHBlY3QgdGhpcyB0byBjaGFuZ2Ugc2lnbmlmaWNhbnRseSBiZXR3ZWVuIHZlcnNpb25zLlxyXG4gKi9cbmZ1bmN0aW9uIHVzZUluc3RhbmNlSGFuZGxlKHJlZikge1xuICBjb25zdCBpbnN0YW5jZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShpbnN0YW5jZSwgKCkgPT4gcmVmLmN1cnJlbnQuX19yM2YsIFtyZWZdKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgUjNGIENhbnZhcycgWnVzdGFuZCBzdG9yZS4gVXNlZnVsIGZvciBbdHJhbnNpZW50IHVwZGF0ZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZCN0cmFuc2llbnQtdXBkYXRlcy1mb3Itb2Z0ZW4tb2NjdXJyaW5nLXN0YXRlLWNoYW5nZXMpLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VzdG9yZVxyXG4gKi9cbmZ1bmN0aW9uIHVzZVN0b3JlKCkge1xuICBjb25zdCBzdG9yZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gIGlmICghc3RvcmUpIHRocm93IG5ldyBFcnJvcignUjNGOiBIb29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCEnKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG4vKipcclxuICogQWNjZXNzZXMgUjNGJ3MgaW50ZXJuYWwgc3RhdGUsIGNvbnRhaW5pbmcgcmVuZGVyZXIsIGNhbnZhcywgc2NlbmUsIGV0Yy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNldGhyZWVcclxuICovXG5mdW5jdGlvbiB1c2VUaHJlZShzZWxlY3RvciA9IHN0YXRlID0+IHN0YXRlLCBlcXVhbGl0eUZuKSB7XG4gIHJldHVybiB1c2VTdG9yZSgpKHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cblxuLyoqXHJcbiAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgYmVmb3JlIHJlbmRlciBpbiBhIHNoYXJlZCBmcmFtZSBsb29wLlxyXG4gKiBDYW4gb3JkZXIgZWZmZWN0cyB3aXRoIHJlbmRlciBwcmlvcml0eSBvciBtYW51YWxseSByZW5kZXIgd2l0aCBhIHBvc2l0aXZlIHByaW9yaXR5LlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VmcmFtZVxyXG4gKi9cbmZ1bmN0aW9uIHVzZUZyYW1lKGNhbGxiYWNrLCByZW5kZXJQcmlvcml0eSA9IDApIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSBzdG9yZS5nZXRTdGF0ZSgpLmludGVybmFsLnN1YnNjcmliZTtcbiAgLy8gTWVtb2l6ZSByZWZcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgLy8gU3Vic2NyaWJlIG9uIG1vdW50LCB1bnN1YnNjcmliZSBvbiB1bm1vdW50XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gc3Vic2NyaWJlKHJlZiwgcmVuZGVyUHJpb3JpdHksIHN0b3JlKSwgW3JlbmRlclByaW9yaXR5LCBzdWJzY3JpYmUsIHN0b3JlXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgZ3JhcGggb2YgYW4gb2JqZWN0IHdpdGggbmFtZWQgbm9kZXMgJiBtYXRlcmlhbHMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWdyYXBoXHJcbiAqL1xuZnVuY3Rpb24gdXNlR3JhcGgob2JqZWN0KSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGJ1aWxkR3JhcGgob2JqZWN0KSwgW29iamVjdF0pO1xufVxuY29uc3QgbWVtb2l6ZWRMb2FkZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGlzQ29uc3RydWN0b3IkMSA9IHZhbHVlID0+IHtcbiAgdmFyIF92YWx1ZSRwcm90b3R5cGU7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiAoX3ZhbHVlJHByb3RvdHlwZSA9IHZhbHVlLnByb3RvdHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF92YWx1ZSRwcm90b3R5cGUuY29uc3RydWN0b3IpID09PSB2YWx1ZTtcbn07XG5mdW5jdGlvbiBsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICByZXR1cm4gZnVuY3Rpb24gKFByb3RvLCAuLi5pbnB1dCkge1xuICAgIGxldCBsb2FkZXI7XG5cbiAgICAvLyBDb25zdHJ1Y3QgYW5kIGNhY2hlIGxvYWRlciBpZiBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkXG4gICAgaWYgKGlzQ29uc3RydWN0b3IkMShQcm90bykpIHtcbiAgICAgIGxvYWRlciA9IG1lbW9pemVkTG9hZGVycy5nZXQoUHJvdG8pO1xuICAgICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyID0gbmV3IFByb3RvKCk7XG4gICAgICAgIG1lbW9pemVkTG9hZGVycy5zZXQoUHJvdG8sIGxvYWRlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRlciA9IFByb3RvO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGxvYWRlciBleHRlbnNpb25zXG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcblxuICAgIC8vIEdvIHRocm91Z2ggdGhlIHVybHMgYW5kIGxvYWQgdGhlbVxuICAgIHJldHVybiBQcm9taXNlLmFsbChpbnB1dC5tYXAoaW5wdXQgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqZWN0KSA9PiBsb2FkZXIubG9hZChpbnB1dCwgZGF0YSA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QzRChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLnNjZW5lKSkgT2JqZWN0LmFzc2lnbihkYXRhLCBidWlsZEdyYXBoKGRhdGEuc2NlbmUpKTtcbiAgICAgIHJlcyhkYXRhKTtcbiAgICB9LCBvblByb2dyZXNzLCBlcnJvciA9PiByZWplY3QobmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCAke2lucHV0fTogJHtlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZX1gKSkpKSkpO1xuICB9O1xufVxuXG4vKipcclxuICogU3luY2hyb25vdXNseSBsb2FkcyBhbmQgY2FjaGVzIGFzc2V0cyB3aXRoIGEgdGhyZWUgbG9hZGVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIGhvb2sncyBjYWxsZXIgbXVzdCBiZSB3cmFwcGVkIHdpdGggYFJlYWN0LlN1c3BlbnNlYFxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2Vsb2FkZXJcclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXIobG9hZGVyLCBpbnB1dCwgZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICAvLyBVc2Ugc3VzcGVuc2UgdG8gbG9hZCBhc3luYyBhc3NldHNcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICBjb25zdCByZXN1bHRzID0gc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtsb2FkZXIsIC4uLmtleXNdLCB7XG4gICAgZXF1YWw6IGlzLmVxdVxuICB9KTtcbiAgLy8gUmV0dXJuIHRoZSBvYmplY3QocylcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpID8gcmVzdWx0cyA6IHJlc3VsdHNbMF07XG59XG5cbi8qKlxyXG4gKiBQcmVsb2FkcyBhbiBhc3NldCBpbnRvIGNhY2hlIGFzIGEgc2lkZS1lZmZlY3QuXHJcbiAqL1xudXNlTG9hZGVyLnByZWxvYWQgPSBmdW5jdGlvbiAobG9hZGVyLCBpbnB1dCwgZXh0ZW5zaW9ucykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBwcmVsb2FkKGxvYWRpbmdGbihleHRlbnNpb25zKSwgW2xvYWRlciwgLi4ua2V5c10pO1xufTtcblxuLyoqXHJcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cclxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAobG9hZGVyLCBpbnB1dCkge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBjbGVhcihbbG9hZGVyLCAuLi5rZXlzXSk7XG59O1xuXG4vLyBUT0RPOiB1cHN0cmVhbSB0byBEZWZpbml0ZWx5VHlwZWQgZm9yIFJlYWN0IDE5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI4OTU2XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlY29uY2lsZXIoY29uZmlnKSB7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKGNvbmZpZyk7XG4gIHJlY29uY2lsZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgICBidW5kbGVUeXBlOiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IDEgOiAwLFxuICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdAcmVhY3QtdGhyZWUvZmliZXInLFxuICAgIHZlcnNpb246IFJlYWN0LnZlcnNpb25cbiAgfSk7XG4gIHJldHVybiByZWNvbmNpbGVyO1xufVxuY29uc3QgTm9FdmVudFByaW9yaXR5ID0gMDtcblxuLy8gVE9ETzogaGFuZGxlIGNvbnN0cnVjdG9yIG92ZXJsb2Fkc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI5MzFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzcwNzlcblxuY29uc3QgY2F0YWxvZ3VlID0ge307XG5jb25zdCBQUkVGSVhfUkVHRVggPSAvXnRocmVlKD89W0EtWl0pLztcbmNvbnN0IHRvUGFzY2FsQ2FzZSA9IHR5cGUgPT4gYCR7dHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7dHlwZS5zbGljZSgxKX1gO1xubGV0IGkgPSAwO1xuY29uc3QgaXNDb25zdHJ1Y3RvciA9IG9iamVjdCA9PiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xuZnVuY3Rpb24gZXh0ZW5kKG9iamVjdHMpIHtcbiAgaWYgKGlzQ29uc3RydWN0b3Iob2JqZWN0cykpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBgJHtpKyt9YDtcbiAgICBjYXRhbG9ndWVbQ29tcG9uZW50XSA9IG9iamVjdHM7XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMpIHtcbiAgLy8gR2V0IHRhcmdldCBmcm9tIGNhdGFsb2d1ZVxuICBjb25zdCBuYW1lID0gYCR7dHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7dHlwZS5zbGljZSgxKX1gO1xuICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG5cbiAgLy8gVmFsaWRhdGUgZWxlbWVudCB0YXJnZXRcbiAgaWYgKHR5cGUgIT09ICdwcmltaXRpdmUnICYmICF0YXJnZXQpIHRocm93IG5ldyBFcnJvcihgUjNGOiAke25hbWV9IGlzIG5vdCBwYXJ0IG9mIHRoZSBUSFJFRSBuYW1lc3BhY2UhIERpZCB5b3UgZm9yZ2V0IHRvIGV4dGVuZD8gU2VlOiBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvb2JqZWN0cyN1c2luZy0zcmQtcGFydHktb2JqZWN0cy1kZWNsYXJhdGl2ZWx5YCk7XG5cbiAgLy8gVmFsaWRhdGUgcHJpbWl0aXZlc1xuICBpZiAodHlwZSA9PT0gJ3ByaW1pdGl2ZScgJiYgIXByb3BzLm9iamVjdCkgdGhyb3cgbmV3IEVycm9yKGBSM0Y6IFByaW1pdGl2ZXMgd2l0aG91dCAnb2JqZWN0JyBhcmUgaW52YWxpZCFgKTtcblxuICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gIGlmIChwcm9wcy5hcmdzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkocHJvcHMuYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcywgcm9vdCkge1xuICB2YXIgX3Byb3BzJG9iamVjdDtcbiAgLy8gUmVtb3ZlIHRocmVlKiBwcmVmaXggZnJvbSBlbGVtZW50c1xuICB0eXBlID0gdHlwZS5yZXBsYWNlKFBSRUZJWF9SRUdFWCwgJycpO1xuICB2YWxpZGF0ZUluc3RhbmNlKHR5cGUsIHByb3BzKTtcblxuICAvLyBSZWdlbmVyYXRlIHRoZSBSM0YgaW5zdGFuY2UgZm9yIHByaW1pdGl2ZXMgdG8gc2ltdWxhdGUgYSBuZXcgb2JqZWN0XG4gIGlmICh0eXBlID09PSAncHJpbWl0aXZlJyAmJiAoX3Byb3BzJG9iamVjdCA9IHByb3BzLm9iamVjdCkgIT0gbnVsbCAmJiBfcHJvcHMkb2JqZWN0Ll9fcjNmKSBkZWxldGUgcHJvcHMub2JqZWN0Ll9fcjNmO1xuICByZXR1cm4gcHJlcGFyZShwcm9wcy5vYmplY3QsIHJvb3QsIHR5cGUsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpZiAoIWluc3RhbmNlLmlzSGlkZGVuKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwYXJlbnQ7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmF0dGFjaCAmJiAoX2luc3RhbmNlJHBhcmVudCA9IGluc3RhbmNlLnBhcmVudCkgIT0gbnVsbCAmJiBfaW5zdGFuY2UkcGFyZW50Lm9iamVjdCkge1xuICAgICAgZGV0YWNoKGluc3RhbmNlLnBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpKSB7XG4gICAgICBpbnN0YW5jZS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpbnN0YW5jZS5pc0hpZGRlbiA9IHRydWU7XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmlzSGlkZGVuKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwYXJlbnQyO1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2ggJiYgKF9pbnN0YW5jZSRwYXJlbnQyID0gaW5zdGFuY2UucGFyZW50KSAhPSBudWxsICYmIF9pbnN0YW5jZSRwYXJlbnQyLm9iamVjdCkge1xuICAgICAgYXR0YWNoKGluc3RhbmNlLnBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpICYmIGluc3RhbmNlLnByb3BzLnZpc2libGUgIT09IGZhbHNlKSB7XG4gICAgICBpbnN0YW5jZS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGluc3RhbmNlLmlzSGlkZGVuID0gZmFsc2U7XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4vLyBUaGlzIHdpbGwgbWFrZSBzdXJlIGV2ZW50cyBhbmQgYXR0YWNoIGFyZSBvbmx5IGhhbmRsZWQgb25jZSB3aGVuIHRyZWVzIGFyZSBjb21wbGV0ZVxuZnVuY3Rpb24gaGFuZGxlQ29udGFpbmVyRWZmZWN0cyhwYXJlbnQsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAvLyBCYWlsIGlmIHRyZWUgaXNuJ3QgbW91bnRlZCBvciBwYXJlbnQgaXMgbm90IGEgY29udGFpbmVyLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdHJlZSBpcyBmaW5hbGl6ZWQgYW5kIFJlYWN0IHdvbid0IGRpc2NhcmQgcmVzdWx0cyB0byBTdXNwZW5zZVxuICBjb25zdCBzdGF0ZSA9IGNoaWxkLnJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKCFwYXJlbnQucGFyZW50ICYmIHBhcmVudC5vYmplY3QgIT09IHN0YXRlLnNjZW5lKSByZXR1cm47XG5cbiAgLy8gQ3JlYXRlICYgbGluayBvYmplY3Qgb24gZmlyc3QgcnVuXG4gIGlmICghY2hpbGQub2JqZWN0KSB7XG4gICAgdmFyIF9jaGlsZCRwcm9wcyRvYmplY3QsIF9jaGlsZCRwcm9wcyRhcmdzO1xuICAgIC8vIEdldCB0YXJnZXQgZnJvbSBjYXRhbG9ndWVcbiAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbdG9QYXNjYWxDYXNlKGNoaWxkLnR5cGUpXTtcblxuICAgIC8vIENyZWF0ZSBvYmplY3RcbiAgICBjaGlsZC5vYmplY3QgPSAoX2NoaWxkJHByb3BzJG9iamVjdCA9IGNoaWxkLnByb3BzLm9iamVjdCkgIT0gbnVsbCA/IF9jaGlsZCRwcm9wcyRvYmplY3QgOiBuZXcgdGFyZ2V0KC4uLigoX2NoaWxkJHByb3BzJGFyZ3MgPSBjaGlsZC5wcm9wcy5hcmdzKSAhPSBudWxsID8gX2NoaWxkJHByb3BzJGFyZ3MgOiBbXSkpO1xuICAgIGNoaWxkLm9iamVjdC5fX3IzZiA9IGNoaWxkO1xuICB9XG5cbiAgLy8gU2V0IGluaXRpYWwgcHJvcHNcbiAgYXBwbHlQcm9wcyhjaGlsZC5vYmplY3QsIGNoaWxkLnByb3BzKTtcblxuICAvLyBBcHBlbmQgaW5zdGFuY2VcbiAgaWYgKGNoaWxkLnByb3BzLmF0dGFjaCkge1xuICAgIGF0dGFjaChwYXJlbnQsIGNoaWxkKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdDNEKGNoaWxkLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJlbnQub2JqZWN0LmNoaWxkcmVuLmluZGV4T2YoYmVmb3JlQ2hpbGQgPT0gbnVsbCA/IHZvaWQgMCA6IGJlZm9yZUNoaWxkLm9iamVjdCk7XG4gICAgaWYgKGJlZm9yZUNoaWxkICYmIGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICBjaGlsZC5vYmplY3QucGFyZW50ID0gcGFyZW50Lm9iamVjdDtcbiAgICAgIHBhcmVudC5vYmplY3QuY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkLm9iamVjdCk7XG4gICAgICBjaGlsZC5vYmplY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgIH0pO1xuICAgICAgcGFyZW50Lm9iamVjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2NoaWxkYWRkZWQnLFxuICAgICAgICBjaGlsZDogY2hpbGQub2JqZWN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Lm9iamVjdC5hZGQoY2hpbGQub2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvLyBMaW5rIHN1YnRyZWVcbiAgZm9yIChjb25zdCBjaGlsZEluc3RhbmNlIG9mIGNoaWxkLmNoaWxkcmVuKSBoYW5kbGVDb250YWluZXJFZmZlY3RzKGNoaWxkLCBjaGlsZEluc3RhbmNlKTtcblxuICAvLyBUcmVlIHdhcyB1cGRhdGVkLCByZXF1ZXN0IGEgZnJhbWVcbiAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gIC8vIExpbmsgaW5zdGFuY2VzXG4gIGNoaWxkLnBhcmVudCA9IHBhcmVudDtcbiAgcGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gIC8vIEF0dGFjaCB0cmVlIG9uY2UgY29tcGxldGVcbiAgaGFuZGxlQ29udGFpbmVyRWZmZWN0cyhwYXJlbnQsIGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnQsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCkgcmV0dXJuO1xuXG4gIC8vIExpbmsgaW5zdGFuY2VzXG4gIGNoaWxkLnBhcmVudCA9IHBhcmVudDtcbiAgY29uc3QgY2hpbGRJbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkKTtlbHNlIHBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAvLyBBdHRhY2ggdHJlZSBvbmNlIGNvbXBsZXRlXG4gIGhhbmRsZUNvbnRhaW5lckVmZmVjdHMocGFyZW50LCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xufVxuZnVuY3Rpb24gZGlzcG9zZU9uSWRsZShvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QuZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGhhbmRsZURpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIG5vLW9wXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEluIGEgdGVzdGluZyBlbnZpcm9ubWVudCwgY2xlYW51cCBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJykgaGFuZGxlRGlzcG9zZSgpO1xuICAgIC8vIE90aGVyd2lzZSwgdXNpbmcgYSByZWFsIEdQVSBzbyBzY2hlZHVsZSBjbGVhbnVwIHRvIHByZXZlbnQgc3RhbGxzXG4gICAgZWxzZSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHVuc3RhYmxlX0lkbGVQcmlvcml0eSwgaGFuZGxlRGlzcG9zZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQsIGRpc3Bvc2UpIHtcbiAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gIC8vIFVubGluayBpbnN0YW5jZXNcbiAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgY29uc3QgY2hpbGRJbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuXG4gIC8vIEVhZ2VybHkgdGVhciBkb3duIHRyZWVcbiAgaWYgKGNoaWxkLnByb3BzLmF0dGFjaCkge1xuICAgIGRldGFjaChwYXJlbnQsIGNoaWxkKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdDNEKGNoaWxkLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgIHBhcmVudC5vYmplY3QucmVtb3ZlKGNoaWxkLm9iamVjdCk7XG4gICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShmaW5kSW5pdGlhbFJvb3QoY2hpbGQpLCBjaGlsZC5vYmplY3QpO1xuICB9XG5cbiAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiB1bm1vdW50IGRpc3Bvc2FsIHdpdGggZGlzcG9zZT17bnVsbH1cbiAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9IGNoaWxkLnByb3BzLmRpc3Bvc2UgIT09IG51bGwgJiYgZGlzcG9zZSAhPT0gZmFsc2U7XG5cbiAgLy8gUmVjdXJzaXZlbHkgcmVtb3ZlIGluc3RhbmNlIGNoaWxkcmVuXG4gIGZvciAobGV0IGkgPSBjaGlsZC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG5vZGUgPSBjaGlsZC5jaGlsZHJlbltpXTtcbiAgICByZW1vdmVDaGlsZChjaGlsZCwgbm9kZSwgc2hvdWxkRGlzcG9zZSk7XG4gIH1cbiAgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAvLyBVbmxpbmsgaW5zdGFuY2Ugb2JqZWN0XG4gIGRlbGV0ZSBjaGlsZC5vYmplY3QuX19yM2Y7XG5cbiAgLy8gRGlzcG9zZSBvYmplY3Qgd2hlbmV2ZXIgdGhlIHJlY29uY2lsZXIgZmVlbHMgbGlrZSBpdC5cbiAgLy8gTmV2ZXIgZGlzcG9zZSBvZiBwcmltaXRpdmVzIGJlY2F1c2UgdGhlaXIgc3RhdGUgbWF5IGJlIGtlcHQgb3V0c2lkZSBvZiBSZWFjdCFcbiAgLy8gSW4gb3JkZXIgZm9yIGFuIG9iamVjdCB0byBiZSBhYmxlIHRvIGRpc3Bvc2UgaXRcbiAgLy8gICAtIGhhcyBhIGRpc3Bvc2UgbWV0aG9kXG4gIC8vICAgLSBjYW5ub3QgYmUgYSA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSAvPlxuICAvLyAgIC0gY2Fubm90IGJlIGEgVEhSRUUuU2NlbmUsIGJlY2F1c2UgdGhyZWUgaGFzIGJyb2tlbiBpdHMgb3duIEFQSVxuICBpZiAoc2hvdWxkRGlzcG9zZSAmJiBjaGlsZC50eXBlICE9PSAncHJpbWl0aXZlJyAmJiBjaGlsZC5vYmplY3QudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgIGRpc3Bvc2VPbklkbGUoY2hpbGQub2JqZWN0KTtcbiAgfVxuXG4gIC8vIFRyZWUgd2FzIHVwZGF0ZWQsIHJlcXVlc3QgYSBmcmFtZSBmb3IgdG9wLWxldmVsIGluc3RhbmNlXG4gIGlmIChkaXNwb3NlID09PSB1bmRlZmluZWQpIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRGaWJlclJlZihmaWJlciwgcHVibGljSW5zdGFuY2UpIHtcbiAgZm9yIChjb25zdCBfZmliZXIgb2YgW2ZpYmVyLCBmaWJlci5hbHRlcm5hdGVdKSB7XG4gICAgaWYgKF9maWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBfZmliZXIucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9maWJlci5yZWZDbGVhbnVwID09IG51bGwgPyB2b2lkIDAgOiBfZmliZXIucmVmQ2xlYW51cCgpO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gX2ZpYmVyLnJlZihwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykgX2ZpYmVyLnJlZkNsZWFudXAgPSBjbGVhbnVwO1xuICAgICAgfSBlbHNlIGlmIChfZmliZXIucmVmKSB7XG4gICAgICAgIF9maWJlci5yZWYuY3VycmVudCA9IHB1YmxpY0luc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgcmVjb25zdHJ1Y3RlZCA9IFtdO1xuZnVuY3Rpb24gc3dhcEluc3RhbmNlcygpIHtcbiAgLy8gRGV0YWNoIGluc3RhbmNlXG4gIGZvciAoY29uc3QgW2luc3RhbmNlXSBvZiByZWNvbnN0cnVjdGVkKSB7XG4gICAgY29uc3QgcGFyZW50ID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgICAgICBwYXJlbnQub2JqZWN0LnJlbW92ZShpbnN0YW5jZS5vYmplY3QpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQucHJvcHMuYXR0YWNoKSB7XG4gICAgICAgICAgZGV0YWNoKGluc3RhbmNlLCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSkge1xuICAgICAgICAgIGluc3RhbmNlLm9iamVjdC5yZW1vdmUoY2hpbGQub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbGQgaW5zdGFuY2UgaXMgaGlkZGVuLCB3ZSBuZWVkIHRvIHVuaGlkZSBpdC5cbiAgICAvLyBSZWFjdCBhc3N1bWVzIGl0IGNhbiBkaXNjYXJkIGluc3RhbmNlcyBzaW5jZSB0aGV5J3JlIHB1cmUgZm9yIERPTS5cbiAgICAvLyBUaGlzIGlzbid0IHRydWUgZm9yIHVzIHNpbmNlIG91ciBsaWZldGltZXMgYXJlIGltcHVyZSBhbmQgbG9uZ2xpdmluZy5cbiAgICAvLyBTbywgd2UgbWFudWFsbHkgY2hlY2sgaWYgYW4gaW5zdGFuY2Ugd2FzIGhpZGRlbiBhbmQgdW5oaWRlIGl0LlxuICAgIGlmIChpbnN0YW5jZS5pc0hpZGRlbikgdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuXG4gICAgLy8gRGlzcG9zZSBvZiBvbGQgb2JqZWN0IGlmIGFibGVcbiAgICBpZiAoaW5zdGFuY2Uub2JqZWN0Ll9fcjNmKSBkZWxldGUgaW5zdGFuY2Uub2JqZWN0Ll9fcjNmO1xuICAgIGlmIChpbnN0YW5jZS50eXBlICE9PSAncHJpbWl0aXZlJykgZGlzcG9zZU9uSWRsZShpbnN0YW5jZS5vYmplY3QpO1xuICB9XG5cbiAgLy8gVXBkYXRlIGluc3RhbmNlXG4gIGZvciAoY29uc3QgW2luc3RhbmNlLCBwcm9wcywgZmliZXJdIG9mIHJlY29uc3RydWN0ZWQpIHtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGNvbnN0IHBhcmVudCA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHByb3BzJG9iamVjLCBfaW5zdGFuY2UkcHJvcHMkYXJncztcbiAgICAgIC8vIEdldCB0YXJnZXQgZnJvbSBjYXRhbG9ndWVcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNhdGFsb2d1ZVt0b1Bhc2NhbENhc2UoaW5zdGFuY2UudHlwZSldO1xuXG4gICAgICAvLyBDcmVhdGUgb2JqZWN0XG4gICAgICBpbnN0YW5jZS5vYmplY3QgPSAoX2luc3RhbmNlJHByb3BzJG9iamVjID0gaW5zdGFuY2UucHJvcHMub2JqZWN0KSAhPSBudWxsID8gX2luc3RhbmNlJHByb3BzJG9iamVjIDogbmV3IHRhcmdldCguLi4oKF9pbnN0YW5jZSRwcm9wcyRhcmdzID0gaW5zdGFuY2UucHJvcHMuYXJncykgIT0gbnVsbCA/IF9pbnN0YW5jZSRwcm9wcyRhcmdzIDogW10pKTtcbiAgICAgIGluc3RhbmNlLm9iamVjdC5fX3IzZiA9IGluc3RhbmNlO1xuICAgICAgc2V0RmliZXJSZWYoZmliZXIsIGluc3RhbmNlLm9iamVjdCk7XG5cbiAgICAgIC8vIFNldCBpbml0aWFsIHByb3BzXG4gICAgICBhcHBseVByb3BzKGluc3RhbmNlLm9iamVjdCwgaW5zdGFuY2UucHJvcHMpO1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSAmJiBpc09iamVjdDNEKHBhcmVudC5vYmplY3QpKSB7XG4gICAgICAgIHBhcmVudC5vYmplY3QuYWRkKGluc3RhbmNlLm9iamVjdCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5wcm9wcy5hdHRhY2gpIHtcbiAgICAgICAgICBhdHRhY2goaW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGNoaWxkLm9iamVjdCkgJiYgaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpKSB7XG4gICAgICAgICAgaW5zdGFuY2Uub2JqZWN0LmFkZChjaGlsZC5vYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyZWUgd2FzIHVwZGF0ZWQsIHJlcXVlc3QgYSBmcmFtZVxuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgcmVjb25zdHJ1Y3RlZC5sZW5ndGggPSAwO1xufVxuXG4vLyBEb24ndCBoYW5kbGUgdGV4dCBpbnN0YW5jZXMsIG1ha2UgaXQgbm8tb3BcbmNvbnN0IGhhbmRsZVRleHRJbnN0YW5jZSA9ICgpID0+IHt9O1xuY29uc3QgTk9fQ09OVEVYVCA9IHt9O1xubGV0IGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IE5vRXZlbnRQcmlvcml0eTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyRmxhZ3MuanNcbmNvbnN0IE5vRmxhZ3MgPSAwO1xuY29uc3QgVXBkYXRlID0gNDtcbmNvbnN0IHJlY29uY2lsZXIgPSAvKiBAX19QVVJFX18gKi9jcmVhdGVSZWNvbmNpbGVyKHtcbiAgaXNQcmltYXJ5UmVuZGVyZXI6IGZhbHNlLFxuICB3YXJuc0lmTm90QWN0aW5nOiBmYWxzZSxcbiAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgc3VwcG9ydHNQZXJzaXN0ZW5jZTogZmFsc2UsXG4gIHN1cHBvcnRzSHlkcmF0aW9uOiBmYWxzZSxcbiAgY3JlYXRlSW5zdGFuY2UsXG4gIHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZCxcbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgaW5zZXJ0QmVmb3JlLFxuICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLl9fcjNmO1xuICAgIGlmICghY2hpbGQgfHwgIXNjZW5lKSByZXR1cm47XG4gICAgYXBwZW5kQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgfSxcbiAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLl9fcjNmO1xuICAgIGlmICghY2hpbGQgfHwgIXNjZW5lKSByZXR1cm47XG4gICAgcmVtb3ZlQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgfSxcbiAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLl9fcjNmO1xuICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkIHx8ICFzY2VuZSkgcmV0dXJuO1xuICAgIGluc2VydEJlZm9yZShzY2VuZSwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSxcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBOT19DT05URVhULFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiAoKSA9PiBOT19DT05URVhULFxuICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICB2YXIgX25ld1Byb3BzJGFyZ3MsIF9vbGRQcm9wcyRhcmdzLCBfbmV3UHJvcHMkYXJnczI7XG4gICAgdmFsaWRhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcyk7XG4gICAgbGV0IHJlY29uc3RydWN0ID0gZmFsc2U7XG5cbiAgICAvLyBSZWNvbnN0cnVjdCBwcmltaXRpdmVzIGlmIG9iamVjdCBwcm9wIGNoYW5nZXNcbiAgICBpZiAoaW5zdGFuY2UudHlwZSA9PT0gJ3ByaW1pdGl2ZScgJiYgb2xkUHJvcHMub2JqZWN0ICE9PSBuZXdQcm9wcy5vYmplY3QpIHJlY29uc3RydWN0ID0gdHJ1ZTtcbiAgICAvLyBSZWNvbnN0cnVjdCBpbnN0YW5jZSBpZiBhcmdzIHdlcmUgYWRkZWQgb3IgcmVtb3ZlZFxuICAgIGVsc2UgaWYgKCgoX25ld1Byb3BzJGFyZ3MgPSBuZXdQcm9wcy5hcmdzKSA9PSBudWxsID8gdm9pZCAwIDogX25ld1Byb3BzJGFyZ3MubGVuZ3RoKSAhPT0gKChfb2xkUHJvcHMkYXJncyA9IG9sZFByb3BzLmFyZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfb2xkUHJvcHMkYXJncy5sZW5ndGgpKSByZWNvbnN0cnVjdCA9IHRydWU7XG4gICAgLy8gUmVjb25zdHJ1Y3QgaW5zdGFuY2UgaWYgYXJncyB3ZXJlIGNoYW5nZWRcbiAgICBlbHNlIGlmICgoX25ld1Byb3BzJGFyZ3MyID0gbmV3UHJvcHMuYXJncykgIT0gbnVsbCAmJiBfbmV3UHJvcHMkYXJnczIuc29tZSgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICB2YXIgX29sZFByb3BzJGFyZ3MyO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAoKF9vbGRQcm9wcyRhcmdzMiA9IG9sZFByb3BzLmFyZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfb2xkUHJvcHMkYXJnczJbaW5kZXhdKTtcbiAgICB9KSkgcmVjb25zdHJ1Y3QgPSB0cnVlO1xuXG4gICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgIGlmIChyZWNvbnN0cnVjdCkge1xuICAgICAgcmVjb25zdHJ1Y3RlZC5wdXNoKFtpbnN0YW5jZSwge1xuICAgICAgICAuLi5uZXdQcm9wc1xuICAgICAgfSwgZmliZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGEgZGlmZi1zZXQsIGZsYWcgaWYgdGhlcmUgYXJlIGFueSBjaGFuZ2VzXG4gICAgICBjb25zdCBjaGFuZ2VkUHJvcHMgPSBkaWZmUHJvcHMoaW5zdGFuY2UsIG5ld1Byb3BzKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhjaGFuZ2VkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLnByb3BzLCBjaGFuZ2VkUHJvcHMpO1xuICAgICAgICBhcHBseVByb3BzKGluc3RhbmNlLm9iamVjdCwgY2hhbmdlZFByb3BzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGbHVzaCByZWNvbnN0cnVjdGVkIHNpYmxpbmdzIHdoZW4gd2UgaGl0IHRoZSBsYXN0IHVwZGF0ZWQgY2hpbGQgaW4gYSBzZXF1ZW5jZVxuICAgIGNvbnN0IGlzVGFpbFNpYmxpbmcgPSBmaWJlci5zaWJsaW5nID09PSBudWxsIHx8IChmaWJlci5mbGFncyAmIFVwZGF0ZSkgPT09IE5vRmxhZ3M7XG4gICAgaWYgKGlzVGFpbFNpYmxpbmcpIHN3YXBJbnN0YW5jZXMoKTtcbiAgfSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46ICgpID0+IGZhbHNlLFxuICBjb21taXRNb3VudCgpIHt9LFxuICBnZXRQdWJsaWNJbnN0YW5jZTogaW5zdGFuY2UgPT4gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLm9iamVjdCxcbiAgcHJlcGFyZUZvckNvbW1pdDogKCkgPT4gbnVsbCxcbiAgcHJlcGFyZVBvcnRhbE1vdW50OiBjb250YWluZXIgPT4gcHJlcGFyZShjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSwgY29udGFpbmVyLCAnJywge30pLFxuICByZXNldEFmdGVyQ29tbWl0OiAoKSA9PiB7fSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6ICgpID0+IGZhbHNlLFxuICBjbGVhckNvbnRhaW5lcjogKCkgPT4gZmFsc2UsXG4gIGhpZGVJbnN0YW5jZSxcbiAgdW5oaWRlSW5zdGFuY2UsXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICBoaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gIHVuaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICBzY2hlZHVsZVRpbWVvdXQ6IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZCxcbiAgY2FuY2VsVGltZW91dDogdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZCxcbiAgbm9UaW1lb3V0OiAtMSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogKCkgPT4gbnVsbCxcbiAgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyKCkge30sXG4gIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyKCkge30sXG4gIGRldGFjaERlbGV0ZWRJbnN0YW5jZSgpIHt9LFxuICBwcmVwYXJlU2NvcGVVcGRhdGUoKSB7fSxcbiAgZ2V0SW5zdGFuY2VGcm9tU2NvcGU6ICgpID0+IG51bGwsXG4gIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb246ICgpID0+IGZhbHNlLFxuICB0cmFja1NjaGVkdWxlckV2ZW50OiAoKSA9PiB7fSxcbiAgcmVzb2x2ZUV2ZW50VHlwZTogKCkgPT4gbnVsbCxcbiAgcmVzb2x2ZUV2ZW50VGltZVN0YW1wOiAoKSA9PiAtMS4xLFxuICByZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2soKSB7fSxcbiAgbWF5U3VzcGVuZENvbW1pdDogKCkgPT4gZmFsc2UsXG4gIHByZWxvYWRJbnN0YW5jZTogKCkgPT4gdHJ1ZSxcbiAgLy8gdHJ1ZSBpbmRpY2F0ZXMgYWxyZWFkeSBsb2FkZWRcbiAgc3RhcnRTdXNwZW5kaW5nQ29tbWl0KCkge30sXG4gIHN1c3BlbmRJbnN0YW5jZSgpIHt9LFxuICB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5OiAoKSA9PiBudWxsLFxuICBOb3RQZW5kaW5nVHJhbnNpdGlvbjogbnVsbCxcbiAgSG9zdFRyYW5zaXRpb25Db250ZXh0OiAvKiBAX19QVVJFX18gKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpLFxuICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHkpIHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbiAgfSxcbiAgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCkge1xuICAgIHJldHVybiBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG4gIH0sXG4gIHJlc29sdmVVcGRhdGVQcmlvcml0eSgpIHtcbiAgICB2YXIgX3dpbmRvdyRldmVudDtcbiAgICBpZiAoY3VycmVudFVwZGF0ZVByaW9yaXR5ICE9PSBOb0V2ZW50UHJpb3JpdHkpIHJldHVybiBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG4gICAgc3dpdGNoICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF93aW5kb3ckZXZlbnQgPSB3aW5kb3cuZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JGV2ZW50LnR5cGUpKSB7XG4gICAgICBjYXNlICdjbGljayc6XG4gICAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBjYXNlICdkYmxjbGljayc6XG4gICAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJ1cCc6XG4gICAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgICBjYXNlICdwb2ludGVybGVhdmUnOlxuICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gICAgfVxuICB9LFxuICByZXNldEZvcm1JbnN0YW5jZSgpIHt9XG59KTtcblxuY29uc3QgX3Jvb3RzID0gbmV3IE1hcCgpO1xuY29uc3Qgc2hhbGxvd0xvb3NlID0ge1xuICBvYmplY3RzOiAnc2hhbGxvdycsXG4gIHN0cmljdDogZmFsc2Vcbn07XG5mdW5jdGlvbiBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBzaXplKSB7XG4gIGlmICghc2l6ZSAmJiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0XG4gICAgfSA9IGNhbnZhcy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFzaXplICYmIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgLi4uc2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vdChjYW52YXMpIHtcbiAgLy8gQ2hlY2sgYWdhaW5zdCBtaXN0YWtlbiB1c2Ugb2YgY3JlYXRlUm9vdFxuICBjb25zdCBwcmV2Um9vdCA9IF9yb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLFxuICAvLyBjb250YWluZXJcbiAgQ29uY3VycmVudFJvb3QsXG4gIC8vIHRhZ1xuICBudWxsLFxuICAvLyBoeWRyYXRpb24gY2FsbGJhY2tzXG4gIGZhbHNlLFxuICAvLyBpc1N0cmljdE1vZGVcbiAgbnVsbCxcbiAgLy8gY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZVxuICAnJyxcbiAgLy8gaWRlbnRpZmllclByZWZpeFxuICBsb2dSZWNvdmVyYWJsZUVycm9yLFxuICAvLyBvblVuY2F1Z2h0RXJyb3JcbiAgbG9nUmVjb3ZlcmFibGVFcnJvcixcbiAgLy8gb25DYXVnaHRFcnJvclxuICBsb2dSZWNvdmVyYWJsZUVycm9yLFxuICAvLyBvblJlY292ZXJhYmxlRXJyb3JcbiAgbnVsbCAvLyB0cmFuc2l0aW9uQ2FsbGJhY2tzXG4gICk7XG4gIC8vIE1hcCBpdFxuICBpZiAoIXByZXZSb290KSBfcm9vdHMuc2V0KGNhbnZhcywge1xuICAgIGZpYmVyLFxuICAgIHN0b3JlXG4gIH0pO1xuXG4gIC8vIExvY2Fsc1xuICBsZXQgb25DcmVhdGVkO1xuICBsZXQgbGFzdENhbWVyYTtcbiAgbGV0IGNvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgbGV0IHBlbmRpbmcgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGNvbmZpZ3VyZShwcm9wcyA9IHt9KSB7XG4gICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShfcmVzb2x2ZSA9PiByZXNvbHZlID0gX3Jlc29sdmUpO1xuICAgICAgbGV0IHtcbiAgICAgICAgZ2w6IGdsQ29uZmlnLFxuICAgICAgICBzaXplOiBwcm9wc1NpemUsXG4gICAgICAgIHNjZW5lOiBzY2VuZU9wdGlvbnMsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWRDYWxsYmFjayxcbiAgICAgICAgc2hhZG93cyA9IGZhbHNlLFxuICAgICAgICBsaW5lYXIgPSBmYWxzZSxcbiAgICAgICAgZmxhdCA9IGZhbHNlLFxuICAgICAgICBsZWdhY3kgPSBmYWxzZSxcbiAgICAgICAgb3J0aG9ncmFwaGljID0gZmFsc2UsXG4gICAgICAgIGZyYW1lbG9vcCA9ICdhbHdheXMnLFxuICAgICAgICBkcHIgPSBbMSwgMl0sXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RPcHRpb25zLFxuICAgICAgICBjYW1lcmE6IGNhbWVyYU9wdGlvbnMsXG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSA9IHByb3BzO1xuICAgICAgbGV0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gU2V0IHVwIHJlbmRlcmVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCBnbCA9IHN0YXRlLmdsO1xuICAgICAgaWYgKCFzdGF0ZS5nbCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgIGFscGhhOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGN1c3RvbVJlbmRlcmVyID0gdHlwZW9mIGdsQ29uZmlnID09PSAnZnVuY3Rpb24nID8gYXdhaXQgZ2xDb25maWcoZGVmYXVsdFByb3BzKSA6IGdsQ29uZmlnO1xuICAgICAgICBpZiAoaXNSZW5kZXJlcihjdXN0b21SZW5kZXJlcikpIHtcbiAgICAgICAgICBnbCA9IGN1c3RvbVJlbmRlcmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICAgICAgLi4uZ2xDb25maWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIGdsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgcmF5Y2FzdGVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCByYXljYXN0ZXIgPSBzdGF0ZS5yYXljYXN0ZXI7XG4gICAgICBpZiAoIXJheWNhc3Rlcikgc3RhdGUuc2V0KHtcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbWVyYU9wdGlvbnMuaXNDYW1lcmE7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGlzQ2FtZXJhID8gY2FtZXJhT3B0aW9ucyA6IG9ydGhvZ3JhcGhpYyA/IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMC4xLCAxMDAwKSA6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykge1xuICAgICAgICAgICAgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdXNlci1kZWZpbmVkIGZydXN0dW0gaWYgcG9zc2libGVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzMxNjBcbiAgICAgICAgICAgIGlmICghY2FtZXJhLm1hbnVhbCkge1xuICAgICAgICAgICAgICBpZiAoJ2FzcGVjdCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnbGVmdCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAncmlnaHQnIGluIGNhbWVyYU9wdGlvbnMgfHwgJ2JvdHRvbScgaW4gY2FtZXJhT3B0aW9ucyB8fCAndG9wJyBpbiBjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhLm1hbnVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBbHdheXMgbG9vayBhdCBjZW50ZXIgYnkgZGVmYXVsdFxuICAgICAgICAgIGlmICghc3RhdGUuY2FtZXJhICYmICEoY2FtZXJhT3B0aW9ucyAhPSBudWxsICYmIGNhbWVyYU9wdGlvbnMucm90YXRpb24pKSBjYW1lcmEubG9va0F0KDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgY2FtZXJhXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbmZpZ3VyZSByYXljYXN0ZXJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC14ci9pc3N1ZXMvMzAwXG4gICAgICAgIHJheWNhc3Rlci5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBzY2VuZSAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnNjZW5lKSB7XG4gICAgICAgIGxldCBzY2VuZTtcbiAgICAgICAgaWYgKHNjZW5lT3B0aW9ucyAhPSBudWxsICYmIHNjZW5lT3B0aW9ucy5pc1NjZW5lKSB7XG4gICAgICAgICAgc2NlbmUgPSBzY2VuZU9wdGlvbnM7XG4gICAgICAgICAgcHJlcGFyZShzY2VuZSwgc3RvcmUsICcnLCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgICAgICBwcmVwYXJlKHNjZW5lLCBzdG9yZSwgJycsIHt9KTtcbiAgICAgICAgICBpZiAoc2NlbmVPcHRpb25zKSBhcHBseVByb3BzKHNjZW5lLCBzY2VuZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgc2NlbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIGV2ZW50cyBpbnRlcm5hbGx5XG4gICAgICBpZiAoZXZlbnRzICYmICFzdGF0ZS5ldmVudHMuaGFuZGxlcnMpIHN0YXRlLnNldCh7XG4gICAgICAgIGV2ZW50czogZXZlbnRzKHN0b3JlKVxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBzaXplLCBhbGxvdyBpdCB0byB0YWtlIG9uIGNvbnRhaW5lciBib3VuZHMgaW5pdGlhbGx5XG4gICAgICBjb25zdCBzaXplID0gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgcHJvcHNTaXplKTtcbiAgICAgIGlmICghaXMuZXF1KHNpemUsIHN0YXRlLnNpemUsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgc3RhdGUuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgc2l6ZS50b3AsIHNpemUubGVmdCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBwaXhlbHJhdGlvXG4gICAgICBpZiAoZHByICYmIHN0YXRlLnZpZXdwb3J0LmRwciAhPT0gY2FsY3VsYXRlRHByKGRwcikpIHN0YXRlLnNldERwcihkcHIpO1xuICAgICAgLy8gQ2hlY2sgZnJhbWVsb29wXG4gICAgICBpZiAoc3RhdGUuZnJhbWVsb29wICE9PSBmcmFtZWxvb3ApIHN0YXRlLnNldEZyYW1lbG9vcChmcmFtZWxvb3ApO1xuICAgICAgLy8gQ2hlY2sgcG9pbnRlciBtaXNzZWRcbiAgICAgIGlmICghc3RhdGUub25Qb2ludGVyTWlzc2VkKSBzdGF0ZS5zZXQoe1xuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgcGVyZm9ybWFuY2VcbiAgICAgIGlmIChwZXJmb3JtYW5jZSAmJiAhaXMuZXF1KHBlcmZvcm1hbmNlLCBzdGF0ZS5wZXJmb3JtYW5jZSwgc2hhbGxvd0xvb3NlKSkgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgICAgLi4ucGVyZm9ybWFuY2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgdXAgWFIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS54cikge1xuICAgICAgICB2YXIgX2dsJHhyO1xuICAgICAgICAvLyBIYW5kbGUgZnJhbWUgYmVoYXZpb3IgaW4gV2ViWFJcbiAgICAgICAgY29uc3QgaGFuZGxlWFJGcmFtZSA9ICh0aW1lc3RhbXAsIGZyYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICAgICAgICBhZHZhbmNlKHRpbWVzdGFtcCwgdHJ1ZSwgc3RhdGUsIGZyYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUb2dnbGUgcmVuZGVyIHN3aXRjaGluZyBvbiBzZXNzaW9uXG4gICAgICAgIGNvbnN0IGhhbmRsZVNlc3Npb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLmVuYWJsZWQgPSBzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmc7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuc2V0QW5pbWF0aW9uTG9vcChzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcgPyBoYW5kbGVYUkZyYW1lIDogbnVsbCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcpIGludmFsaWRhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdlYlhSIHNlc3Npb24gbWFuYWdlclxuICAgICAgICBjb25zdCB4ciA9IHtcbiAgICAgICAgICBjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJYUiBzZXNzaW9uIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mICgoX2dsJHhyID0gZ2wueHIpID09IG51bGwgPyB2b2lkIDAgOiBfZ2wkeHIuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHhyLmNvbm5lY3QoKTtcbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICB4clxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHNoYWRvd21hcFxuICAgICAgaWYgKGdsLnNoYWRvd01hcCkge1xuICAgICAgICBjb25zdCBvbGRFbmFibGVkID0gZ2wuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgICAgIGNvbnN0IG9sZFR5cGUgPSBnbC5zaGFkb3dNYXAudHlwZTtcbiAgICAgICAgZ2wuc2hhZG93TWFwLmVuYWJsZWQgPSAhIXNoYWRvd3M7XG4gICAgICAgIGlmIChpcy5ib28oc2hhZG93cykpIHtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc3RyKHNoYWRvd3MpKSB7XG4gICAgICAgICAgdmFyIF90eXBlcyRzaGFkb3dzO1xuICAgICAgICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICAgICAgYmFzaWM6IFRIUkVFLkJhc2ljU2hhZG93TWFwLFxuICAgICAgICAgICAgcGVyY2VudGFnZTogVEhSRUUuUENGU2hhZG93TWFwLFxuICAgICAgICAgICAgc29mdDogVEhSRUUuUENGU29mdFNoYWRvd01hcCxcbiAgICAgICAgICAgIHZhcmlhbmNlOiBUSFJFRS5WU01TaGFkb3dNYXBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gKF90eXBlcyRzaGFkb3dzID0gdHlwZXNbc2hhZG93c10pICE9IG51bGwgPyBfdHlwZXMkc2hhZG93cyA6IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMub2JqKHNoYWRvd3MpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihnbC5zaGFkb3dNYXAsIHNoYWRvd3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRFbmFibGVkICE9PSBnbC5zaGFkb3dNYXAuZW5hYmxlZCB8fCBvbGRUeXBlICE9PSBnbC5zaGFkb3dNYXAudHlwZSkgZ2wuc2hhZG93TWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFRIUkVFLkNvbG9yTWFuYWdlbWVudC5lbmFibGVkID0gIWxlZ2FjeTtcblxuICAgICAgLy8gU2V0IGNvbG9yIHNwYWNlIGFuZCB0b25lbWFwcGluZyBwcmVmZXJlbmNlc1xuICAgICAgaWYgKCFjb25maWd1cmVkKSB7XG4gICAgICAgIGdsLm91dHB1dENvbG9yU3BhY2UgPSBsaW5lYXIgPyBUSFJFRS5MaW5lYXJTUkdCQ29sb3JTcGFjZSA6IFRIUkVFLlNSR0JDb2xvclNwYWNlO1xuICAgICAgICBnbC50b25lTWFwcGluZyA9IGZsYXQgPyBUSFJFRS5Ob1RvbmVNYXBwaW5nIDogVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY29sb3IgbWFuYWdlbWVudCBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmxlZ2FjeSAhPT0gbGVnYWN5KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGVnYWN5XG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUubGluZWFyICE9PSBsaW5lYXIpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsaW5lYXJcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5mbGF0ICE9PSBmbGF0KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgZmxhdFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgZ2wgcHJvcHNcbiAgICAgIGlmIChnbENvbmZpZyAmJiAhaXMuZnVuKGdsQ29uZmlnKSAmJiAhaXNSZW5kZXJlcihnbENvbmZpZykgJiYgIWlzLmVxdShnbENvbmZpZywgZ2wsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMoZ2wsIGdsQ29uZmlnKTtcblxuICAgICAgLy8gU2V0IGxvY2Fsc1xuICAgICAgb25DcmVhdGVkID0gb25DcmVhdGVkQ2FsbGJhY2s7XG4gICAgICBjb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgICAvLyBUaGUgcm9vdCBoYXMgdG8gYmUgY29uZmlndXJlZCBiZWZvcmUgaXQgY2FuIGJlIHJlbmRlcmVkXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQgJiYgIXBlbmRpbmcpIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICBwZW5kaW5nLnRoZW4oKCkgPT4ge1xuICAgICAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lciggLyojX19QVVJFX18qL2pzeChQcm92aWRlciwge1xuICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWQsXG4gICAgICAgICAgcm9vdEVsZW1lbnQ6IGNhbnZhc1xuICAgICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9LFxuICAgIHVubW91bnQoKSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY2hpbGRyZW4sXG4gIG9uQ3JlYXRlZCxcbiAgcm9vdEVsZW1lbnRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIEZsYWcgdGhlIGNhbnZhcyBhY3RpdmUsIHJlbmRlcmluZyB3aWxsIG5vdyBiZWdpblxuICAgIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJuYWwsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pKTtcbiAgICAvLyBOb3RpZml5IHRoYXQgaW5pdCBpcyBjb21wbGV0ZWQsIHRoZSBzY2VuZSBncmFwaCBleGlzdHMsIGJ1dCBub3RoaW5nIGhhcyB5ZXQgcmVuZGVyZWRcbiAgICBpZiAob25DcmVhdGVkKSBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgIC8vIENvbm5lY3QgZXZlbnRzIHRvIHRoZSB0YXJnZXRzIHBhcmVudCwgdGhpcyBpcyBkb25lIHRvIGVuc3VyZSBldmVudHMgYXJlIHJlZ2lzdGVyZWQgb25cbiAgICAvLyBhIHNoYXJlZCB0YXJnZXQsIGFuZCBub3Qgb24gdGhlIGNhbnZhcyBpdHNlbGZcbiAgICBpZiAoIXN0b3JlLmdldFN0YXRlKCkuZXZlbnRzLmNvbm5lY3RlZCkgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KHJvb3RFbGVtZW50KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdCA9IF9yb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgZmliZXIgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmZpYmVyO1xuICBpZiAoZmliZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUpIHN0YXRlLmludGVybmFsLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIGZpYmVyLCBudWxsLCAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc3RhdGUkZ2wsIF9zdGF0ZSRnbCRyZW5kZXJMaXN0cywgX3N0YXRlJGdsMiwgX3N0YXRlJGdsMztcbiAgICAgICAgICAgIHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbCA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogKF9zdGF0ZSRnbCRyZW5kZXJMaXN0cyA9IF9zdGF0ZSRnbC5yZW5kZXJMaXN0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbDIgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcyA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzKCk7XG4gICAgICAgICAgICBpZiAoKF9zdGF0ZSRnbDMgPSBzdGF0ZS5nbCkgIT0gbnVsbCAmJiBfc3RhdGUkZ2wzLnhyKSBzdGF0ZS54ci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkaXNwb3NlKHN0YXRlLnNjZW5lKTtcbiAgICAgICAgICAgIF9yb290cy5kZWxldGUoY2FudmFzKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soY2FudmFzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiAuLi4gKi9cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyLCBzdGF0ZSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChQb3J0YWwsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gUG9ydGFsKHtcbiAgc3RhdGUgPSB7fSxcbiAgY2hpbGRyZW4sXG4gIGNvbnRhaW5lclxufSkge1xuICAvKiogVGhpcyBoYXMgdG8gYmUgYSBjb21wb25lbnQgYmVjYXVzZSBpdCB3b3VsZCBub3QgYmUgYWJsZSB0byBjYWxsIHVzZVRocmVlL3VzZVN0b3JlIG90aGVyd2lzZSBzaW5jZVxyXG4gICAqICBpZiB0aGlzIGlzIG91ciBlbnZpcm9ubWVudCwgdGhlbiB3ZSBhcmUgbm90IGluIHIzZidzIHJlbmRlcmVyIGJ1dCBpbiByZWFjdC1kb20sIGl0IHdvdWxkIHRyaWdnZXJcclxuICAgKiAgdGhlIFwiUjNGIGhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IVwiIHdhcm5pbmc6XHJcbiAgICogIDxDYW52YXM+XHJcbiAgICogICAge2NyZWF0ZVBvcnRhbCguLi4pfSAqL1xuICBjb25zdCB7XG4gICAgZXZlbnRzLFxuICAgIHNpemUsXG4gICAgLi4ucmVzdFxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUm9vdCA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IFtyYXljYXN0ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlJheWNhc3RlcigpKTtcbiAgY29uc3QgW3BvaW50ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlZlY3RvcjIoKSk7XG4gIGNvbnN0IGluamVjdCA9IHVzZU11dGFibGVDYWxsYmFjaygocm9vdFN0YXRlLCBpbmplY3RTdGF0ZSkgPT4ge1xuICAgIGxldCB2aWV3cG9ydCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5qZWN0U3RhdGUuY2FtZXJhICYmIHNpemUpIHtcbiAgICAgIGNvbnN0IGNhbWVyYSA9IGluamVjdFN0YXRlLmNhbWVyYTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcnJpZGUgdmlld3BvcnQsIGlmIHByZXNlbnRcbiAgICAgIHZpZXdwb3J0ID0gcm9vdFN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIG5ldyBUSFJFRS5WZWN0b3IzKCksIHNpemUpO1xuICAgICAgLy8gVXBkYXRlIHRoZSBwb3J0YWwgY2FtZXJhLCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICBpZiAoY2FtZXJhICE9PSByb290U3RhdGUuY2FtZXJhKSB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBpbnRlcnNlY3QgY29uc2lzdHMgb2YgdGhlIHByZXZpb3VzIHJvb3Qgc3RhdGVcbiAgICAgIC4uLnJvb3RTdGF0ZSxcbiAgICAgIC4uLmluamVjdFN0YXRlLFxuICAgICAgLy8gUG9ydGFscyBoYXZlIHRoZWlyIG93biBzY2VuZSwgd2hpY2ggZm9ybXMgdGhlIHJvb3QsIGEgcmF5Y2FzdGVyIGFuZCBhIHBvaW50ZXJcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICAvLyBUaGVpciBwcmV2aW91cyByb290IGlzIHRoZSBsYXllciBiZWZvcmUgaXRcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIC8vIEV2ZW50cywgc2l6ZSBhbmQgdmlld3BvcnQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGluamVjdCBsYXllclxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmluamVjdFN0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5yb290U3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgLi4udmlld3BvcnRcbiAgICAgIH0sXG4gICAgICAvLyBMYXllcnMgYXJlIGFsbG93ZWQgdG8gb3ZlcnJpZGUgZXZlbnRzXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBpbmplY3RTdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHVzZVBvcnRhbFN0b3JlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgbWlycm9yZWQgc3RvcmUsIGJhc2VkIG9uIHRoZSBwcmV2aW91cyByb290IHdpdGggYSBmZXcgb3ZlcnJpZGVzIC4uLlxuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlV2l0aEVxdWFsaXR5Rm4oKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLi4ucmVzdCxcbiAgICAgIHNldCxcbiAgICAgIGdldFxuICAgIH0pKTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBwcmV2aW91cyByb290LXN0YXRlIGFuZCBjb3B5IGNoYW5nZXMgb3ZlciB0byB0aGUgbWlycm9yZWQgcG9ydGFsLXN0YXRlXG4gICAgY29uc3Qgb25NdXRhdGUgPSBwcmV2ID0+IHN0b3JlLnNldFN0YXRlKHN0YXRlID0+IGluamVjdC5jdXJyZW50KHByZXYsIHN0YXRlKSk7XG4gICAgb25NdXRhdGUocHJldmlvdXNSb290LmdldFN0YXRlKCkpO1xuICAgIHByZXZpb3VzUm9vdC5zdWJzY3JpYmUob25NdXRhdGUpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtwcmV2aW91c1Jvb3QsIGNvbnRhaW5lcl0pO1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICAvLyBAdHMtaWdub3JlLCByZWNvbmNpbGVyIHR5cGVzIGFyZSBub3QgbWFpbnRhaW5lZFxuICAgIGpzeChGcmFnbWVudCwge1xuICAgICAgY2hpbGRyZW46IHJlY29uY2lsZXIuY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHVzZVBvcnRhbFN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pLCB1c2VQb3J0YWxTdG9yZSwgbnVsbClcbiAgICB9KVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBzdWJzKSB7XG4gIGNvbnN0IHN1YiA9IHtcbiAgICBjYWxsYmFja1xuICB9O1xuICBzdWJzLmFkZChzdWIpO1xuICByZXR1cm4gKCkgPT4gdm9pZCBzdWJzLmRlbGV0ZShzdWIpO1xufVxuY29uc3QgZ2xvYmFsRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmNvbnN0IGdsb2JhbEFmdGVyRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmNvbnN0IGdsb2JhbFRhaWxFZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRFZmZlY3RcclxuICovXG5jb25zdCBhZGRFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkQWZ0ZXJFZmZlY3RcclxuICovXG5jb25zdCBhZGRBZnRlckVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEFmdGVyRWZmZWN0cyk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZFRhaWxcclxuICovXG5jb25zdCBhZGRUYWlsID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsVGFpbEVmZmVjdHMpO1xuZnVuY3Rpb24gcnVuKGVmZmVjdHMsIHRpbWVzdGFtcCkge1xuICBpZiAoIWVmZmVjdHMuc2l6ZSkgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHtcbiAgICBjYWxsYmFja1xuICB9IG9mIGVmZmVjdHMudmFsdWVzKCkpIHtcbiAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEdsb2JhbEVmZmVjdHModHlwZSwgdGltZXN0YW1wKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxBZnRlckVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAndGFpbCc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbFRhaWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICB9XG59XG5sZXQgc3Vic2NyaWJlcnM7XG5sZXQgc3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gdXBkYXRlKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKSB7XG4gIC8vIFJ1biBsb2NhbCBlZmZlY3RzXG4gIGxldCBkZWx0YSA9IHN0YXRlLmNsb2NrLmdldERlbHRhKCk7XG5cbiAgLy8gSW4gZnJhbWVsb29wPSduZXZlcicgbW9kZSwgY2xvY2sgdGltZXMgYXJlIHVwZGF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIHRpbWVzdGFtcFxuICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInICYmIHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgZGVsdGEgPSB0aW1lc3RhbXAgLSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5vbGRUaW1lID0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2suZWxhcHNlZFRpbWUgPSB0aW1lc3RhbXA7XG4gIH1cblxuICAvLyBDYWxsIHN1YnNjcmliZXJzICh1c2VGcmFtZSlcbiAgc3Vic2NyaWJlcnMgPSBzdGF0ZS5pbnRlcm5hbC5zdWJzY3JpYmVycztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZXJzW2ldO1xuICAgIHN1YnNjcmlwdGlvbi5yZWYuY3VycmVudChzdWJzY3JpcHRpb24uc3RvcmUuZ2V0U3RhdGUoKSwgZGVsdGEsIGZyYW1lKTtcbiAgfVxuXG4gIC8vIFJlbmRlciBjb250ZW50XG4gIGlmICghc3RhdGUuaW50ZXJuYWwucHJpb3JpdHkgJiYgc3RhdGUuZ2wucmVuZGVyKSBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIHN0YXRlLmNhbWVyYSk7XG5cbiAgLy8gRGVjcmVhc2UgZnJhbWUgY291bnRcbiAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5tYXgoMCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzIC0gMSk7XG4gIHJldHVybiBzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnID8gMSA6IHN0YXRlLmludGVybmFsLmZyYW1lcztcbn1cbmxldCBydW5uaW5nID0gZmFsc2U7XG5sZXQgdXNlRnJhbWVJblByb2dyZXNzID0gZmFsc2U7XG5sZXQgcmVwZWF0O1xubGV0IGZyYW1lO1xubGV0IHN0YXRlO1xuZnVuY3Rpb24gbG9vcCh0aW1lc3RhbXApIHtcbiAgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gIHJ1bm5pbmcgPSB0cnVlO1xuICByZXBlYXQgPSAwO1xuXG4gIC8vIFJ1biBlZmZlY3RzXG4gIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcblxuICAvLyBSZW5kZXIgYWxsIHJvb3RzXG4gIHVzZUZyYW1lSW5Qcm9ncmVzcyA9IHRydWU7XG4gIGZvciAoY29uc3Qgcm9vdCBvZiBfcm9vdHMudmFsdWVzKCkpIHtcbiAgICB2YXIgX3N0YXRlJGdsJHhyO1xuICAgIHN0YXRlID0gcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gSWYgdGhlIGZyYW1lbG9vcCBpcyBpbnZhbGlkYXRlZCwgZG8gbm90IHJ1biBhbm90aGVyIGZyYW1lXG4gICAgaWYgKHN0YXRlLmludGVybmFsLmFjdGl2ZSAmJiAoc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyB8fCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPiAwKSAmJiAhKChfc3RhdGUkZ2wkeHIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIuaXNQcmVzZW50aW5nKSkge1xuICAgICAgcmVwZWF0ICs9IHVwZGF0ZSh0aW1lc3RhbXAsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgdXNlRnJhbWVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgLy8gUnVuIGFmdGVyLWVmZmVjdHNcbiAgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG5cbiAgLy8gU3RvcCB0aGUgbG9vcCBpZiBub3RoaW5nIGludmFsaWRhdGVzIGl0XG4gIGlmIChyZXBlYXQgPT09IDApIHtcbiAgICAvLyBUYWlsIGNhbGwgZWZmZWN0cywgdGhleSBhcmUgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzXG4gICAgZmx1c2hHbG9iYWxFZmZlY3RzKCd0YWlsJywgdGltZXN0YW1wKTtcblxuICAgIC8vIEZsYWcgZW5kIG9mIG9wZXJhdGlvblxuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICB9XG59XG5cbi8qKlxyXG4gKiBJbnZhbGlkYXRlcyB0aGUgdmlldywgcmVxdWVzdGluZyBhIGZyYW1lIHRvIGJlIHJlbmRlcmVkLiBXaWxsIGdsb2JhbGx5IGludmFsaWRhdGUgdW5sZXNzIHBhc3NlZCBhIHJvb3QncyBzdGF0ZS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2ludmFsaWRhdGVcclxuICovXG5mdW5jdGlvbiBpbnZhbGlkYXRlKHN0YXRlLCBmcmFtZXMgPSAxKSB7XG4gIHZhciBfc3RhdGUkZ2wkeHIyO1xuICBpZiAoIXN0YXRlKSByZXR1cm4gX3Jvb3RzLmZvckVhY2gocm9vdCA9PiBpbnZhbGlkYXRlKHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSwgZnJhbWVzKSk7XG4gIGlmICgoX3N0YXRlJGdsJHhyMiA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4cjIuaXNQcmVzZW50aW5nIHx8ICFzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgfHwgc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gIGlmIChmcmFtZXMgPiAxKSB7XG4gICAgLy8gbGVnYWN5IHN1cHBvcnQgZm9yIHBlb3BsZSB1c2luZyBmcmFtZXMgcGFyYW1ldGVyc1xuICAgIC8vIEluY3JlYXNlIGZyYW1lcywgZG8gbm90IGdvIGhpZ2hlciB0aGFuIDYwXG4gICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5taW4oNjAsIHN0YXRlLmludGVybmFsLmZyYW1lcyArIGZyYW1lcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHVzZUZyYW1lSW5Qcm9ncmVzcykge1xuICAgICAgLy9jYWxsZWQgZnJvbSB3aXRoaW4gYSB1c2VGcmFtZSwgaXQgbWVhbnMgdGhlIHVzZXIgd2FudHMgYW4gYWRkaXRpb25hbCBmcmFtZVxuICAgICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy90aGUgdXNlciBuZWVkIGEgbmV3IGZyYW1lLCBubyBuZWVkIHRvIGluY3JlbWVudCBmdXJ0aGVyIHRoYW4gMVxuICAgICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gMTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgcmVuZGVyLWxvb3AgaXNuJ3QgYWN0aXZlLCBzdGFydCBpdFxuICBpZiAoIXJ1bm5pbmcpIHtcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEFkdmFuY2VzIHRoZSBmcmFtZWxvb3AgYW5kIHJ1bnMgcmVuZGVyIGVmZmVjdHMsIHVzZWZ1bCBmb3Igd2hlbiBtYW51YWxseSByZW5kZXJpbmcgdmlhIGBmcmFtZWxvb3A9XCJuZXZlclwiYC5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkdmFuY2VcclxuICovXG5mdW5jdGlvbiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cyA9IHRydWUsIHN0YXRlLCBmcmFtZSkge1xuICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuICBpZiAoIXN0YXRlKSBmb3IgKGNvbnN0IHJvb3Qgb2YgX3Jvb3RzLnZhbHVlcygpKSB1cGRhdGUodGltZXN0YW1wLCByb290LnN0b3JlLmdldFN0YXRlKCkpO2Vsc2UgdXBkYXRlKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKTtcbiAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xufVxuXG5jb25zdCBET01fRVZFTlRTID0ge1xuICBvbkNsaWNrOiBbJ2NsaWNrJywgZmFsc2VdLFxuICBvbkNvbnRleHRNZW51OiBbJ2NvbnRleHRtZW51JywgZmFsc2VdLFxuICBvbkRvdWJsZUNsaWNrOiBbJ2RibGNsaWNrJywgZmFsc2VdLFxuICBvbldoZWVsOiBbJ3doZWVsJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckRvd246IFsncG9pbnRlcmRvd24nLCB0cnVlXSxcbiAgb25Qb2ludGVyVXA6IFsncG9pbnRlcnVwJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckxlYXZlOiBbJ3BvaW50ZXJsZWF2ZScsIHRydWVdLFxuICBvblBvaW50ZXJNb3ZlOiBbJ3BvaW50ZXJtb3ZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckNhbmNlbDogWydwb2ludGVyY2FuY2VsJywgdHJ1ZV0sXG4gIG9uTG9zdFBvaW50ZXJDYXB0dXJlOiBbJ2xvc3Rwb2ludGVyY2FwdHVyZScsIHRydWVdXG59O1xuXG4vKiogRGVmYXVsdCBSM0YgZXZlbnQgbWFuYWdlciBmb3Igd2ViICovXG5mdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnRzKHN0b3JlKSB7XG4gIGNvbnN0IHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH0gPSBjcmVhdGVFdmVudHMoc3RvcmUpO1xuICByZXR1cm4ge1xuICAgIHByaW9yaXR5OiAxLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgY29tcHV0ZShldmVudCwgc3RhdGUsIHByZXZpb3VzKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvNzgyXG4gICAgICAvLyBFdmVudHMgdHJpZ2dlciBvdXRzaWRlIG9mIGNhbnZhcyB3aGVuIG1vdmVkLCB1c2Ugb2Zmc2V0WC9ZIGJ5IGRlZmF1bHQgYW5kIGFsbG93IG92ZXJyaWRlc1xuICAgICAgc3RhdGUucG9pbnRlci5zZXQoZXZlbnQub2Zmc2V0WCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLShldmVudC5vZmZzZXRZIC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICB9LFxuICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkLFxuICAgIGhhbmRsZXJzOiBPYmplY3Qua2V5cyhET01fRVZFTlRTKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tleV06IGhhbmRsZVBvaW50ZXIoa2V5KVxuICAgIH0pLCB7fSksXG4gICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICB2YXIgX2ludGVybmFsJGxhc3RFdmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoKF9pbnRlcm5hbCRsYXN0RXZlbnQgPSBpbnRlcm5hbC5sYXN0RXZlbnQpICE9IG51bGwgJiYgX2ludGVybmFsJGxhc3RFdmVudC5jdXJyZW50ICYmIGV2ZW50cy5oYW5kbGVycykgZXZlbnRzLmhhbmRsZXJzLm9uUG9pbnRlck1vdmUoaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQpO1xuICAgIH0sXG4gICAgY29ubmVjdDogdGFyZ2V0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2V0LFxuICAgICAgICBldmVudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIGNvbm5lY3RlZDogdGFyZ2V0XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIGlmIChldmVudHMuaGFuZGxlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzLmhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGNvbnN0IFtldmVudE5hbWUsIHBhc3NpdmVdID0gRE9NX0VWRU5UU1tuYW1lXTtcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50LCB7XG4gICAgICAgICAgICBwYXNzaXZlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2V0LFxuICAgICAgICBldmVudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKGV2ZW50cy5jb25uZWN0ZWQpIHtcbiAgICAgICAgaWYgKGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBldmVudHMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzLmhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgICAgY29uc3QgW2V2ZW50TmFtZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgICAgZXZlbnRzLmNvbm5lY3RlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyB1c2VUaHJlZSBhcyBBLCBCbG9jayBhcyBCLCB1c2VGcmFtZSBhcyBDLCB1c2VHcmFwaCBhcyBELCBFcnJvckJvdW5kYXJ5IGFzIEUsIHVzZUxvYWRlciBhcyBGLCBfcm9vdHMgYXMgXywgdXNlTXV0YWJsZUNhbGxiYWNrIGFzIGEsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgYXMgYiwgY3JlYXRlUm9vdCBhcyBjLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIGFzIGQsIGV4dGVuZCBhcyBlLCBjcmVhdGVQb2ludGVyRXZlbnRzIGFzIGYsIGNyZWF0ZUV2ZW50cyBhcyBnLCBmbHVzaEdsb2JhbEVmZmVjdHMgYXMgaCwgaXNSZWYgYXMgaSwgYWRkRWZmZWN0IGFzIGosIGFkZEFmdGVyRWZmZWN0IGFzIGssIGFkZFRhaWwgYXMgbCwgaW52YWxpZGF0ZSBhcyBtLCBhZHZhbmNlIGFzIG4sIGNyZWF0ZVBvcnRhbCBhcyBvLCBjb250ZXh0IGFzIHAsIGFwcGx5UHJvcHMgYXMgcSwgcmVjb25jaWxlciBhcyByLCBnZXRSb290U3RhdGUgYXMgcywgdGhyZWVUeXBlcyBhcyB0LCB1c2VCcmlkZ2UgYXMgdSwgZGlzcG9zZSBhcyB2LCBhY3QgYXMgdywgYnVpbGRHcmFwaCBhcyB4LCB1c2VJbnN0YW5jZUhhbmRsZSBhcyB5LCB1c2VTdG9yZSBhcyB6IH07XG4iXSwibmFtZXMiOlsiVEhSRUUiLCJSZWFjdCIsIkRlZmF1bHRFdmVudFByaW9yaXR5IiwiQ29udGludW91c0V2ZW50UHJpb3JpdHkiLCJEaXNjcmV0ZUV2ZW50UHJpb3JpdHkiLCJDb25jdXJyZW50Um9vdCIsImNyZWF0ZVdpdGhFcXVhbGl0eUZuIiwiUmVjb25jaWxlciIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJzdXNwZW5kIiwicHJlbG9hZCIsImNsZWFyIiwianN4IiwiRnJhZ21lbnQiLCJ1c2VGaWJlciIsInVzZUNvbnRleHRCcmlkZ2UiLCJ0cmF2ZXJzZUZpYmVyIiwidGhyZWVUeXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImZpbmRJbml0aWFsUm9vdCIsImluc3RhbmNlIiwicm9vdCIsImdldFN0YXRlIiwicHJldmlvdXNSb290IiwiYWN0IiwiaXNPcnRob2dyYXBoaWNDYW1lcmEiLCJkZWYiLCJpc1JlZiIsIm9iaiIsImhhc093blByb3BlcnR5IiwiaXNDb2xvclJlcHJlc2VudGF0aW9uIiwidmFsdWUiLCJpc0NvbG9yIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIl93aW5kb3ckZG9jdW1lbnQiLCJfd2luZG93JG5hdmlnYXRvciIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJmbiIsInJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJ1c2VCcmlkZ2UiLCJmaWJlciIsIkNvbnRleHRCcmlkZ2UiLCJ1c2VNZW1vIiwiY2hpbGRyZW4iLCJzdHJpY3QiLCJub2RlIiwidHlwZSIsIlN0cmljdE1vZGUiLCJSb290IiwiQmxvY2siLCJzZXQiLCJQcm9taXNlIiwiRXJyb3JCb3VuZGFyeSIsIl9FcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiYXJncyIsInN0YXRlIiwiZXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVyciIsInByb3BzIiwicmVuZGVyIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiY2FsY3VsYXRlRHByIiwiZHByIiwiX3dpbmRvdyRkZXZpY2VQaXhlbFJhIiwidGFyZ2V0IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkFycmF5IiwiaXNBcnJheSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRSb290U3RhdGUiLCJfcjNmIiwiX19yM2YiLCJpcyIsImEiLCJhcnIiLCJmdW4iLCJzdHIiLCJudW0iLCJib28iLCJ1bmQiLCJudWwiLCJlcXUiLCJiIiwiYXJyYXlzIiwib2JqZWN0cyIsImlzT2JqIiwiaXNBcnIiLCJpIiwibGVuZ3RoIiwia2V5cyIsImJ1aWxkR3JhcGgiLCJvYmplY3QiLCJkYXRhIiwibm9kZXMiLCJtYXRlcmlhbHMiLCJ0cmF2ZXJzZSIsIm5hbWUiLCJtYXRlcmlhbCIsImRpc3Bvc2UiLCJwIiwicHJvcCIsIlJFQUNUX0lOVEVSTkFMX1BST1BTIiwiZ2V0SW5zdGFuY2VQcm9wcyIsInF1ZXVlIiwia2V5IiwiaW5jbHVkZXMiLCJwcmVwYXJlIiwicGFyZW50IiwiZXZlbnRDb3VudCIsImhhbmRsZXJzIiwiaXNIaWRkZW4iLCJyZXNvbHZlIiwiX3RhcmdldCIsImNoYWluIiwic3BsaXQiLCJyZWR1Y2UiLCJhY2MiLCJwb3AiLCJJTkRFWF9SRUdFWCIsImF0dGFjaCIsImNoaWxkIiwidGVzdCIsImluZGV4IiwicmVwbGFjZSIsInByZXZpb3VzQXR0YWNoIiwiZGV0YWNoIiwicHJldmlvdXMiLCJ1bmRlZmluZWQiLCJSRVNFUlZFRF9QUk9QUyIsIk1FTU9JWkVEX1BST1RPVFlQRVMiLCJNYXAiLCJnZXRNZW1vaXplZFByb3RvdHlwZSIsImN0b3IiLCJnZXQiLCJlIiwiZGlmZlByb3BzIiwibmV3UHJvcHMiLCJjaGFuZ2VkUHJvcHMiLCJvdGhlciIsInN0YXJ0c1dpdGgiLCJjb2xvck1hcHMiLCJFVkVOVF9SRUdFWCIsImFwcGx5UHJvcHMiLCJfaW5zdGFuY2Ukb2JqZWN0Iiwicm9vdFN0YXRlIiwicHJldkhhbmRsZXJzIiwiTGF5ZXJzIiwibWFzayIsIkNvbG9yIiwiY29weSIsImZyb21BcnJheSIsInNldFNjYWxhciIsIl9yb290JGtleSIsImxpbmVhciIsImlzVGV4dHVyZSIsImZvcm1hdCIsIlJHQkFGb3JtYXQiLCJVbnNpZ25lZEJ5dGVUeXBlIiwiY29sb3JTcGFjZSIsIlNSR0JDb2xvclNwYWNlIiwiaW50ZXJuYWwiLCJpc09iamVjdDNEIiwiaW50ZXJhY3Rpb24iLCJpbmRleE9mIiwic3BsaWNlIiwicmF5Y2FzdCIsInB1c2giLCJpc0J1ZmZlckdlb21ldHJ5IiwiaXNNYXRlcmlhbCIsImludmFsaWRhdGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRyb290Iiwib25VcGRhdGUiLCJmcmFtZXMiLCJpbnZhbGlkYXRlIiwidXBkYXRlQ2FtZXJhIiwiY2FtZXJhIiwic2l6ZSIsIm1hbnVhbCIsImxlZnQiLCJ3aWR0aCIsInJpZ2h0IiwidG9wIiwiaGVpZ2h0IiwiYm90dG9tIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsIm1ha2VJZCIsImV2ZW50IiwiZXZlbnRPYmplY3QiLCJ1dWlkIiwiaW5zdGFuY2VJZCIsInJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlIiwiY2FwdHVyZWRNYXAiLCJjYXB0dXJlcyIsInBvaW50ZXJJZCIsImNhcHR1cmVEYXRhIiwiZGVsZXRlIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwicmVtb3ZlSW50ZXJhY3Rpdml0eSIsInN0b3JlIiwiZmlsdGVyIiwibyIsImluaXRpYWxIaXRzIiwiaG92ZXJlZCIsImZvckVhY2giLCJjcmVhdGVFdmVudHMiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImR4Iiwib2Zmc2V0WCIsImluaXRpYWxDbGljayIsImR5Iiwib2Zmc2V0WSIsInJvdW5kIiwic3FydCIsImZpbHRlclBvaW50ZXJFdmVudHMiLCJzb21lIiwiaW50ZXJzZWN0IiwiZHVwbGljYXRlcyIsIlNldCIsImludGVyc2VjdGlvbnMiLCJldmVudHNPYmplY3RzIiwicmF5Y2FzdGVyIiwiZXZlbnRzIiwiY29tcHV0ZSIsImhhbmRsZVJheWNhc3QiLCJlbmFibGVkIiwiX3N0YXRlJHByZXZpb3VzUm9vdCIsImludGVyc2VjdE9iamVjdCIsImhpdHMiLCJmbGF0TWFwIiwic29ydCIsImFTdGF0ZSIsImJTdGF0ZSIsImRpc3RhbmNlIiwicHJpb3JpdHkiLCJpdGVtIiwiaWQiLCJoYXMiLCJhZGQiLCJoaXQiLCJfcjNmMiIsInZhbHVlcyIsImludGVyc2VjdGlvbiIsImhhbmRsZUludGVyc2VjdHMiLCJkZWx0YSIsImNhbGxiYWNrIiwibG9jYWxTdGF0ZSIsInN0b3BwZWQiLCJ0cmF2ZXJzZUFuY2VzdG9ycyIsInBhcmVudFN0YXRlIiwicG9pbnRlciIsInVucHJvamVjdGVkUG9pbnQiLCJWZWN0b3IzIiwieCIsInkiLCJ1bnByb2plY3QiLCJoYXNQb2ludGVyQ2FwdHVyZSIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcCIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcDIiLCJzZXRQb2ludGVyQ2FwdHVyZSIsImV4dHJhY3RFdmVudFByb3BzIiwicHJvcGVydHkiLCJyYXljYXN0RXZlbnQiLCJyYXkiLCJzdG9wUHJvcGFnYXRpb24iLCJjYXB0dXJlc0ZvclBvaW50ZXIiLCJmcm9tIiwiZmluZCIsImhpZ2hlciIsInNsaWNlIiwiY2FuY2VsUG9pbnRlciIsImN1cnJlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsImhvdmVyZWRPYmoiLCJvblBvaW50ZXJPdXQiLCJvblBvaW50ZXJMZWF2ZSIsInBvaW50ZXJNaXNzZWQiLCJvblBvaW50ZXJNaXNzZWQiLCJoYW5kbGVQb2ludGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlRXZlbnQiLCJsYXN0RXZlbnQiLCJpc1BvaW50ZXJNb3ZlIiwiaXNDbGlja0V2ZW50IiwibWFwIiwib25JbnRlcnNlY3QiLCJvblBvaW50ZXJPdmVyIiwib25Qb2ludGVyRW50ZXIiLCJob3ZlcmVkSXRlbSIsIm9uUG9pbnRlck1vdmUiLCJoYW5kbGVyIiwiaXNSZW5kZXJlciIsImNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlU3RvcmUiLCJhZHZhbmNlIiwicm9vdFN0b3JlIiwicG9zaXRpb24iLCJkZWZhdWx0VGFyZ2V0IiwidGVtcFRhcmdldCIsImdldEN1cnJlbnRWaWV3cG9ydCIsImlzVmVjdG9yMyIsImdldFdvcmxkUG9zaXRpb24iLCJkaXN0YW5jZVRvIiwiem9vbSIsImZhY3RvciIsImZvdiIsIlBJIiwiaCIsInRhbiIsInciLCJwZXJmb3JtYW5jZVRpbWVvdXQiLCJzZXRQZXJmb3JtYW5jZUN1cnJlbnQiLCJwZXJmb3JtYW5jZSIsIlZlY3RvcjIiLCJnbCIsImNvbm5lY3RlZCIsInNjZW5lIiwieHIiLCJ0aW1lc3RhbXAiLCJydW5HbG9iYWxFZmZlY3RzIiwibGVnYWN5IiwiZmxhdCIsImNvbnRyb2xzIiwiY2xvY2siLCJDbG9jayIsIm1vdXNlIiwiZnJhbWVsb29wIiwiZGVib3VuY2UiLCJyZWdyZXNzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInZpZXdwb3J0IiwiaW5pdGlhbERwciIsInNldEV2ZW50cyIsInNldFNpemUiLCJzZXREcHIiLCJyZXNvbHZlZCIsInNldEZyYW1lbG9vcCIsInN0b3AiLCJlbGFwc2VkVGltZSIsInN0YXJ0Iiwic3Vic2NyaWJlcnMiLCJjcmVhdGVSZWYiLCJhY3RpdmUiLCJzdWJzY3JpYmUiLCJzIiwib2xkU2l6ZSIsIm9sZERwciIsIm9sZENhbWVyYSIsInNldFBpeGVsUmF0aW8iLCJ1cGRhdGVTdHlsZSIsIkhUTUxDYW52YXNFbGVtZW50IiwiZG9tRWxlbWVudCIsInVzZUluc3RhbmNlSGFuZGxlIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZVN0b3JlIiwidXNlQ29udGV4dCIsIkVycm9yIiwidXNlVGhyZWUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJ1c2VGcmFtZSIsInJlbmRlclByaW9yaXR5IiwidXNlR3JhcGgiLCJtZW1vaXplZExvYWRlcnMiLCJXZWFrTWFwIiwiaXNDb25zdHJ1Y3RvciQxIiwiX3ZhbHVlJHByb3RvdHlwZSIsInByb3RvdHlwZSIsImxvYWRpbmdGbiIsImV4dGVuc2lvbnMiLCJvblByb2dyZXNzIiwiUHJvdG8iLCJpbnB1dCIsImxvYWRlciIsImFsbCIsInJlcyIsInJlamVjdCIsImxvYWQiLCJhc3NpZ24iLCJtZXNzYWdlIiwidXNlTG9hZGVyIiwicmVzdWx0cyIsImVxdWFsIiwiY3JlYXRlUmVjb25jaWxlciIsImNvbmZpZyIsInJlY29uY2lsZXIiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwicHJvY2VzcyIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJ2ZXJzaW9uIiwiTm9FdmVudFByaW9yaXR5IiwiY2F0YWxvZ3VlIiwiUFJFRklYX1JFR0VYIiwidG9QYXNjYWxDYXNlIiwidG9VcHBlckNhc2UiLCJpc0NvbnN0cnVjdG9yIiwiZXh0ZW5kIiwidmFsaWRhdGVJbnN0YW5jZSIsImNyZWF0ZUluc3RhbmNlIiwiX3Byb3BzJG9iamVjdCIsImhpZGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRwYXJlbnQiLCJ2aXNpYmxlIiwidW5oaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkcGFyZW50MiIsImhhbmRsZUNvbnRhaW5lckVmZmVjdHMiLCJiZWZvcmVDaGlsZCIsIl9jaGlsZCRwcm9wcyRvYmplY3QiLCJfY2hpbGQkcHJvcHMkYXJncyIsImNoaWxkSW5kZXgiLCJkaXNwYXRjaEV2ZW50IiwiY2hpbGRJbnN0YW5jZSIsImFwcGVuZENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiZGlzcG9zZU9uSWRsZSIsImhhbmRsZURpc3Bvc2UiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJyZW1vdmVDaGlsZCIsInJlbW92ZSIsInNob3VsZERpc3Bvc2UiLCJzZXRGaWJlclJlZiIsInB1YmxpY0luc3RhbmNlIiwiX2ZpYmVyIiwiYWx0ZXJuYXRlIiwicmVmQ2xlYW51cCIsImNsZWFudXAiLCJyZWNvbnN0cnVjdGVkIiwic3dhcEluc3RhbmNlcyIsIl9pbnN0YW5jZSRwcm9wcyRvYmplYyIsIl9pbnN0YW5jZSRwcm9wcyRhcmdzIiwiaGFuZGxlVGV4dEluc3RhbmNlIiwiTk9fQ09OVEVYVCIsImN1cnJlbnRVcGRhdGVQcmlvcml0eSIsIk5vRmxhZ3MiLCJVcGRhdGUiLCJpc1ByaW1hcnlSZW5kZXJlciIsIndhcm5zSWZOb3RBY3RpbmciLCJzdXBwb3J0c011dGF0aW9uIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImNvbnRhaW5lciIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsImNvbW1pdFVwZGF0ZSIsIm9sZFByb3BzIiwiX25ld1Byb3BzJGFyZ3MiLCJfb2xkUHJvcHMkYXJncyIsIl9uZXdQcm9wcyRhcmdzMiIsInJlY29uc3RydWN0IiwiX29sZFByb3BzJGFyZ3MyIiwiaXNUYWlsU2libGluZyIsInNpYmxpbmciLCJmbGFncyIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwiY29tbWl0TW91bnQiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJyZXNldEFmdGVyQ29tbWl0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJjbGVhckNvbnRhaW5lciIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJzY2hlZHVsZVRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0Iiwibm9UaW1lb3V0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uIiwidHJhY2tTY2hlZHVsZXJFdmVudCIsInJlc29sdmVFdmVudFR5cGUiLCJyZXNvbHZlRXZlbnRUaW1lU3RhbXAiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJtYXlTdXNwZW5kQ29tbWl0IiwicHJlbG9hZEluc3RhbmNlIiwic3RhcnRTdXNwZW5kaW5nQ29tbWl0Iiwic3VzcGVuZEluc3RhbmNlIiwid2FpdEZvckNvbW1pdFRvQmVSZWFkeSIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwiSG9zdFRyYW5zaXRpb25Db250ZXh0Iiwic2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwibmV3UHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJyZXNvbHZlVXBkYXRlUHJpb3JpdHkiLCJfd2luZG93JGV2ZW50IiwicmVzZXRGb3JtSW5zdGFuY2UiLCJfcm9vdHMiLCJzaGFsbG93TG9vc2UiLCJjb21wdXRlSW5pdGlhbFNpemUiLCJjYW52YXMiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlUm9vdCIsInByZXZSb290IiwicHJldkZpYmVyIiwicHJldlN0b3JlIiwiY29uc29sZSIsIndhcm4iLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwicmVwb3J0RXJyb3IiLCJjcmVhdGVDb250YWluZXIiLCJvbkNyZWF0ZWQiLCJsYXN0Q2FtZXJhIiwiY29uZmlndXJlZCIsInBlbmRpbmciLCJjb25maWd1cmUiLCJfcmVzb2x2ZSIsImdsQ29uZmlnIiwicHJvcHNTaXplIiwic2NlbmVPcHRpb25zIiwib25DcmVhdGVkQ2FsbGJhY2siLCJzaGFkb3dzIiwib3J0aG9ncmFwaGljIiwicmF5Y2FzdE9wdGlvbnMiLCJjYW1lcmFPcHRpb25zIiwiZGVmYXVsdFByb3BzIiwicG93ZXJQcmVmZXJlbmNlIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJjdXN0b21SZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJSYXljYXN0ZXIiLCJwYXJhbXMiLCJvcHRpb25zIiwiaXNDYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsInoiLCJyb3RhdGlvbiIsImxvb2tBdCIsImlzU2NlbmUiLCJTY2VuZSIsIl9nbCR4ciIsImhhbmRsZVhSRnJhbWUiLCJmcmFtZSIsImhhbmRsZVNlc3Npb25DaGFuZ2UiLCJpc1ByZXNlbnRpbmciLCJzZXRBbmltYXRpb25Mb29wIiwiY29ubmVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNoYWRvd01hcCIsIm9sZEVuYWJsZWQiLCJvbGRUeXBlIiwiUENGU29mdFNoYWRvd01hcCIsIl90eXBlcyRzaGFkb3dzIiwidHlwZXMiLCJiYXNpYyIsIkJhc2ljU2hhZG93TWFwIiwicGVyY2VudGFnZSIsIlBDRlNoYWRvd01hcCIsInNvZnQiLCJ2YXJpYW5jZSIsIlZTTVNoYWRvd01hcCIsIm5lZWRzVXBkYXRlIiwiQ29sb3JNYW5hZ2VtZW50Iiwib3V0cHV0Q29sb3JTcGFjZSIsIkxpbmVhclNSR0JDb2xvclNwYWNlIiwidG9uZU1hcHBpbmciLCJOb1RvbmVNYXBwaW5nIiwiQUNFU0ZpbG1pY1RvbmVNYXBwaW5nIiwidGhlbiIsInVwZGF0ZUNvbnRhaW5lciIsIlByb3ZpZGVyIiwicm9vdEVsZW1lbnQiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsIl9zdGF0ZSRnbCIsIl9zdGF0ZSRnbCRyZW5kZXJMaXN0cyIsIl9zdGF0ZSRnbDIiLCJfc3RhdGUkZ2wzIiwicmVuZGVyTGlzdHMiLCJmb3JjZUNvbnRleHRMb3NzIiwiY3JlYXRlUG9ydGFsIiwiUG9ydGFsIiwicmVzdCIsInVzZVN0YXRlIiwiaW5qZWN0IiwiaW5qZWN0U3RhdGUiLCJ1c2VQb3J0YWxTdG9yZSIsIm9uTXV0YXRlIiwicHJldiIsInNldFN0YXRlIiwiY3JlYXRlU3VicyIsInN1YnMiLCJzdWIiLCJnbG9iYWxFZmZlY3RzIiwiZ2xvYmFsQWZ0ZXJFZmZlY3RzIiwiZ2xvYmFsVGFpbEVmZmVjdHMiLCJhZGRFZmZlY3QiLCJhZGRBZnRlckVmZmVjdCIsImFkZFRhaWwiLCJydW4iLCJlZmZlY3RzIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwic3Vic2NyaXB0aW9uIiwidXBkYXRlIiwiZ2V0RGVsdGEiLCJvbGRUaW1lIiwicnVubmluZyIsInVzZUZyYW1lSW5Qcm9ncmVzcyIsInJlcGVhdCIsImxvb3AiLCJfc3RhdGUkZ2wkeHIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIl9zdGF0ZSRnbCR4cjIiLCJET01fRVZFTlRTIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbkRvdWJsZUNsaWNrIiwib25XaGVlbCIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlckNhbmNlbCIsIm9uTG9zdFBvaW50ZXJDYXB0dXJlIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsInNldEZyb21DYW1lcmEiLCJfaW50ZXJuYWwkbGFzdEV2ZW50IiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIl8iLCJjIiwiZCIsImYiLCJnIiwiaiIsImsiLCJsIiwibSIsIm4iLCJxIiwiciIsInQiLCJ1IiwidiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-0dc84b81.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   act: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   advance: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   context: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   events: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   extend: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)\n/* harmony export */ });\n/* harmony import */ var _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-0dc84b81.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-0dc84b81.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction CanvasImpl({ ref, children, fallback, resize, style, gl, events = _events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.f, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"CanvasImpl.useMemo\": ()=>(0,_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__)\n    }[\"CanvasImpl.useMemo\"], []);\n    const Bridge = (0,_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, {\n        \"CanvasImpl.useImperativeHandle\": ()=>canvasRef.current\n    }[\"CanvasImpl.useImperativeHandle\"]);\n    const handlePointerMissed = (0,_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    (0,_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)({\n        \"CanvasImpl.useIsomorphicLayoutEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n                if (!root.current) root.current = (0,_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(canvas);\n                async function run() {\n                    await root.current.configure({\n                        gl,\n                        scene,\n                        events,\n                        shadows,\n                        linear,\n                        flat,\n                        legacy,\n                        orthographic,\n                        frameloop,\n                        dpr,\n                        performance,\n                        raycaster,\n                        camera,\n                        size: containerRect,\n                        // Pass mutable reference to onPointerMissed so it's free to update\n                        onPointerMissed: {\n                            \"CanvasImpl.useIsomorphicLayoutEffect.run\": (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args)\n                        }[\"CanvasImpl.useIsomorphicLayoutEffect.run\"],\n                        onCreated: {\n                            \"CanvasImpl.useIsomorphicLayoutEffect.run\": (state)=>{\n                                // Connect to event source\n                                state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                                // Set up compute function\n                                if (eventPrefix) {\n                                    state.setEvents({\n                                        compute: {\n                                            \"CanvasImpl.useIsomorphicLayoutEffect.run\": (event, state)=>{\n                                                const x = event[eventPrefix + 'X'];\n                                                const y = event[eventPrefix + 'Y'];\n                                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                                            }\n                                        }[\"CanvasImpl.useIsomorphicLayoutEffect.run\"]\n                                    });\n                                }\n                                // Call onCreated callback\n                                onCreated == null ? void 0 : onCreated(state);\n                            }\n                        }[\"CanvasImpl.useIsomorphicLayoutEffect.run\"]\n                    });\n                    root.current.render(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                            set: setError,\n                            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                                fallback: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                                    set: setBlock\n                                }),\n                                children: children != null ? children : null\n                            })\n                        })\n                    }));\n                }\n                run();\n            }\n        }\n    }[\"CanvasImpl.useIsomorphicLayoutEffect\"]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"CanvasImpl.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (canvas) return ({\n                \"CanvasImpl.useEffect\": ()=>(0,_events_0dc84b81_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas)\n            })[\"CanvasImpl.useEffect\"];\n        }\n    }[\"CanvasImpl.useEffect\"], []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? 'none' : 'auto';\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        ref: divRef,\n        style: {\n            position: 'relative',\n            width: '100%',\n            height: '100%',\n            overflow: 'hidden',\n            pointerEvents,\n            ...style\n        },\n        ...props,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            ref: containerRef,\n            style: {\n                width: '100%',\n                height: '100%'\n            },\n            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    display: 'block'\n                },\n                children: fallback\n            })\n        })\n    });\n}\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */ function Canvas(props) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_8__.FiberProvider, {\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n            ...props\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb1A7QUFDa1E7QUFDdmQ7QUFDQTtBQUNZO0FBQ0Y7QUFDRDtBQUNKO0FBQ1A7QUFDSDtBQUNQO0FBQ0k7QUFFdkIsU0FBU3dFLFdBQVcsRUFDbEJDLEdBQUcsRUFDSEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxFQUFFLEVBQ0ZoQyxTQUFTM0Isc0RBQW1CLEVBQzVCNEQsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLE9BQU8sRUFDUEMsTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsWUFBWSxFQUNaQyxTQUFTLEVBQ1RDLEdBQUcsRUFDSEMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxlQUFlLEVBQ2ZDLFNBQVMsRUFDVCxHQUFHQyxPQUNKO0lBQ0Msc0RBQXNEO0lBQ3RELDRFQUE0RTtJQUM1RSx5REFBeUQ7SUFDekQzQiwwQ0FBYTs4QkFBQyxJQUFNbEUsMERBQU1BLENBQUNtRSxrQ0FBS0E7NkJBQUcsRUFBRTtJQUNyQyxNQUFNNEIsU0FBUzdGLDBEQUFTQTtJQUN4QixNQUFNLENBQUM4RixjQUFjQyxjQUFjLEdBQUc3Qiw2REFBVUEsQ0FBQztRQUMvQzhCLFFBQVE7UUFDUkMsVUFBVTtZQUNSRCxRQUFRO1lBQ1J2QixRQUFRO1FBQ1Y7UUFDQSxHQUFHQSxNQUFNO0lBQ1g7SUFDQSxNQUFNeUIsWUFBWWxDLHlDQUFZLENBQUM7SUFDL0IsTUFBTW9DLFNBQVNwQyx5Q0FBWSxDQUFDO0lBQzVCQSxzREFBeUIsQ0FBQ007MENBQUssSUFBTTRCLFVBQVVJLE9BQU87O0lBQ3RELE1BQU1DLHNCQUFzQnJHLDBEQUFrQkEsQ0FBQ3VGO0lBQy9DLE1BQU0sQ0FB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QUFDLE9BQU87UUFDN0JFLEtBQUs4QjtRQUNMMUIsT0FBTztZQUNMdUQsVUFBVTtZQUNWbEIsT0FBTztZQUNQQyxRQUFRO1lBQ1JrQixVQUFVO1lBQ1ZGO1lBQ0EsR0FBR3RELEtBQUs7UUFDVjtRQUNBLEdBQUdpQixLQUFLO1FBQ1JwQixVQUFVLFdBQVcsR0FBRUgsc0RBQUdBLENBQUMsT0FBTztZQUNoQ0UsS0FBS3dCO1lBQ0xwQixPQUFPO2dCQUNMcUMsT0FBTztnQkFDUEMsUUFBUTtZQUNWO1lBQ0F6QyxVQUFVLFdBQVcsR0FBRUgsc0RBQUdBLENBQUMsVUFBVTtnQkFDbkNFLEtBQUs0QjtnQkFDTHhCLE9BQU87b0JBQ0x5RCxTQUFTO2dCQUNYO2dCQUNBNUQsVUFBVUM7WUFDWjtRQUNGO0lBQ0Y7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELFNBQVM0RCxPQUFPekMsS0FBSztJQUNuQixPQUFPLFdBQVcsR0FBRXZCLHNEQUFHQSxDQUFDRCxtREFBYUEsRUFBRTtRQUNyQ0ksVUFBVSxXQUFXLEdBQUVILHNEQUFHQSxDQUFDQyxZQUFZO1lBQ3JDLEdBQUdzQixLQUFLO1FBQ1Y7SUFDRjtBQUNGO0FBRWtCIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9EZXNrdG9wL3NtYXJ0X2xlYXJuaW5nL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9yZWFjdC10aHJlZS1maWJlci5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZSBhcyBleHRlbmQsIHUgYXMgdXNlQnJpZGdlLCBhIGFzIHVzZU11dGFibGVDYWxsYmFjaywgYiBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBjIGFzIGNyZWF0ZVJvb3QsIGkgYXMgaXNSZWYsIEUgYXMgRXJyb3JCb3VuZGFyeSwgQiBhcyBCbG9jaywgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLCBmIGFzIGNyZWF0ZVBvaW50ZXJFdmVudHMgfSBmcm9tICcuL2V2ZW50cy0wZGM4NGI4MS5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyBSZWFjdFRocmVlRmliZXIsIF8gYXMgX3Jvb3RzLCB3IGFzIGFjdCwgayBhcyBhZGRBZnRlckVmZmVjdCwgaiBhcyBhZGRFZmZlY3QsIGwgYXMgYWRkVGFpbCwgbiBhcyBhZHZhbmNlLCBxIGFzIGFwcGx5UHJvcHMsIHggYXMgYnVpbGRHcmFwaCwgcCBhcyBjb250ZXh0LCBnIGFzIGNyZWF0ZUV2ZW50cywgbyBhcyBjcmVhdGVQb3J0YWwsIGMgYXMgY3JlYXRlUm9vdCwgdiBhcyBkaXNwb3NlLCBmIGFzIGV2ZW50cywgZSBhcyBleHRlbmQsIGggYXMgZmx1c2hHbG9iYWxFZmZlY3RzLCBzIGFzIGdldFJvb3RTdGF0ZSwgbSBhcyBpbnZhbGlkYXRlLCByIGFzIHJlY29uY2lsZXIsIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgQyBhcyB1c2VGcmFtZSwgRCBhcyB1c2VHcmFwaCwgeSBhcyB1c2VJbnN0YW5jZUhhbmRsZSwgRiBhcyB1c2VMb2FkZXIsIHogYXMgdXNlU3RvcmUsIEEgYXMgdXNlVGhyZWUgfSBmcm9tICcuL2V2ZW50cy0wZGM4NGI4MS5lc20uanMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHVzZU1lYXN1cmUgZnJvbSAncmVhY3QtdXNlLW1lYXN1cmUnO1xuaW1wb3J0IHsgRmliZXJQcm92aWRlciB9IGZyb20gJ2l0cy1maW5lJztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0ICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgJ3NjaGVkdWxlcic7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuXG5mdW5jdGlvbiBDYW52YXNJbXBsKHtcbiAgcmVmLFxuICBjaGlsZHJlbixcbiAgZmFsbGJhY2ssXG4gIHJlc2l6ZSxcbiAgc3R5bGUsXG4gIGdsLFxuICBldmVudHMgPSBjcmVhdGVQb2ludGVyRXZlbnRzLFxuICBldmVudFNvdXJjZSxcbiAgZXZlbnRQcmVmaXgsXG4gIHNoYWRvd3MsXG4gIGxpbmVhcixcbiAgZmxhdCxcbiAgbGVnYWN5LFxuICBvcnRob2dyYXBoaWMsXG4gIGZyYW1lbG9vcCxcbiAgZHByLFxuICBwZXJmb3JtYW5jZSxcbiAgcmF5Y2FzdGVyLFxuICBjYW1lcmEsXG4gIHNjZW5lLFxuICBvblBvaW50ZXJNaXNzZWQsXG4gIG9uQ3JlYXRlZCxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgLy8gQ3JlYXRlIGEga25vd24gY2F0YWxvZ3VlIG9mIFRocmVlanMtbmF0aXZlIGVsZW1lbnRzXG4gIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBlbnRpcmUgVEhSRUUgbmFtZXNwYWNlIGJ5IGRlZmF1bHQsIHVzZXJzIGNhbiBleHRlbmRcbiAgLy8gdGhlaXIgb3duIGVsZW1lbnRzIGJ5IHVzaW5nIHRoZSBjcmVhdGVSb290IEFQSSBpbnN0ZWFkXG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKFRIUkVFKSwgW10pO1xuICBjb25zdCBCcmlkZ2UgPSB1c2VCcmlkZ2UoKTtcbiAgY29uc3QgW2NvbnRhaW5lclJlZiwgY29udGFpbmVyUmVjdF0gPSB1c2VNZWFzdXJlKHtcbiAgICBzY3JvbGw6IHRydWUsXG4gICAgZGVib3VuY2U6IHtcbiAgICAgIHNjcm9sbDogNTAsXG4gICAgICByZXNpemU6IDBcbiAgICB9LFxuICAgIC4uLnJlc2l6ZVxuICB9KTtcbiAgY29uc3QgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkaXZSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBjYW52YXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNaXNzZWQgPSB1c2VNdXRhYmxlQ2FsbGJhY2sob25Qb2ludGVyTWlzc2VkKTtcbiAgY29uc3QgW2Jsb2NrLCBzZXRCbG9ja10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFN1c3BlbmQgdGhpcyBjb21wb25lbnQgaWYgYmxvY2sgaXMgYSBwcm9taXNlICgybmQgcnVuKVxuICBpZiAoYmxvY2spIHRocm93IGJsb2NrO1xuICAvLyBUaHJvdyBleGNlcHRpb24gb3V0d2FyZHMgaWYgYW55dGhpbmcgd2l0aGluIGNhbnZhcyB0aHJvd3NcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgcm9vdCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNvbnRhaW5lclJlY3Qud2lkdGggPiAwICYmIGNvbnRhaW5lclJlY3QuaGVpZ2h0ID4gMCAmJiBjYW52YXMpIHtcbiAgICAgIGlmICghcm9vdC5jdXJyZW50KSByb290LmN1cnJlbnQgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gICAgICBhc3luYyBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgIGF3YWl0IHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICAgIGdsLFxuICAgICAgICAgIHNjZW5lLFxuICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICBzaGFkb3dzLFxuICAgICAgICAgIGxpbmVhcixcbiAgICAgICAgICBmbGF0LFxuICAgICAgICAgIGxlZ2FjeSxcbiAgICAgICAgICBvcnRob2dyYXBoaWMsXG4gICAgICAgICAgZnJhbWVsb29wLFxuICAgICAgICAgIGRwcixcbiAgICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgIHNpemU6IGNvbnRhaW5lclJlY3QsXG4gICAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICAgIG9uUG9pbnRlck1pc3NlZDogKC4uLmFyZ3MpID0+IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50KC4uLmFyZ3MpLFxuICAgICAgICAgIG9uQ3JlYXRlZDogc3RhdGUgPT4ge1xuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICAgIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChldmVudFNvdXJjZSA/IGlzUmVmKGV2ZW50U291cmNlKSA/IGV2ZW50U291cmNlLmN1cnJlbnQgOiBldmVudFNvdXJjZSA6IGRpdlJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIC8vIFNldCB1cCBjb21wdXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc2V0RXZlbnRzKHtcbiAgICAgICAgICAgICAgICBjb21wdXRlOiAoZXZlbnQsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1knXTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KHggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oeSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgb25DcmVhdGVkIGNhbGxiYWNrXG4gICAgICAgICAgICBvbkNyZWF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcm9vdC5jdXJyZW50LnJlbmRlciggLyojX19QVVJFX18qL2pzeChCcmlkZ2UsIHtcbiAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICBzZXQ6IHNldEVycm9yLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goUmVhY3QuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3goQmxvY2ssIHtcbiAgICAgICAgICAgICAgICBzZXQ6IHNldEJsb2NrXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4gIT0gbnVsbCA/IGNoaWxkcmVuIDogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBydW4oKTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHJldHVybiAoKSA9PiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gIH0sIFtdKTtcblxuICAvLyBXaGVuIHRoZSBldmVudCBzb3VyY2UgaXMgbm90IHRoaXMgZGl2LCB3ZSBuZWVkIHRvIHNldCBwb2ludGVyLWV2ZW50cyB0byBub25lXG4gIC8vIE9yIGVsc2UgdGhlIGNhbnZhcyB3aWxsIGJsb2NrIGV2ZW50cyBmcm9tIHJlYWNoaW5nIHRoZSBldmVudCBzb3VyY2VcbiAgY29uc3QgcG9pbnRlckV2ZW50cyA9IGV2ZW50U291cmNlID8gJ25vbmUnIDogJ2F1dG8nO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJjYW52YXNcIiwge1xuICAgICAgICByZWY6IGNhbnZhc1JlZixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBmYWxsYmFja1xuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn1cblxuLyoqXHJcbiAqIEEgRE9NIGNhbnZhcyB3aGljaCBhY2NlcHRzIHRocmVlanMgZWxlbWVudHMgYXMgY2hpbGRyZW4uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xyXG4gKi9cbmZ1bmN0aW9uIENhbnZhcyhwcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGaWJlclByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ2FudmFzSW1wbCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KTtcbn1cblxuZXhwb3J0IHsgQ2FudmFzIH07XG4iXSwibmFtZXMiOlsiZSIsImV4dGVuZCIsInUiLCJ1c2VCcmlkZ2UiLCJhIiwidXNlTXV0YWJsZUNhbGxiYWNrIiwiYiIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjIiwiY3JlYXRlUm9vdCIsImkiLCJpc1JlZiIsIkUiLCJFcnJvckJvdW5kYXJ5IiwiQiIsIkJsb2NrIiwiZCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJmIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsInQiLCJSZWFjdFRocmVlRmliZXIiLCJfIiwiX3Jvb3RzIiwidyIsImFjdCIsImsiLCJhZGRBZnRlckVmZmVjdCIsImoiLCJhZGRFZmZlY3QiLCJsIiwiYWRkVGFpbCIsIm4iLCJhZHZhbmNlIiwicSIsImFwcGx5UHJvcHMiLCJ4IiwiYnVpbGRHcmFwaCIsInAiLCJjb250ZXh0IiwiZyIsImNyZWF0ZUV2ZW50cyIsIm8iLCJjcmVhdGVQb3J0YWwiLCJ2IiwiZGlzcG9zZSIsImV2ZW50cyIsImgiLCJmbHVzaEdsb2JhbEVmZmVjdHMiLCJzIiwiZ2V0Um9vdFN0YXRlIiwibSIsImludmFsaWRhdGUiLCJyIiwicmVjb25jaWxlciIsIkMiLCJ1c2VGcmFtZSIsIkQiLCJ1c2VHcmFwaCIsInkiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsIkYiLCJ1c2VMb2FkZXIiLCJ6IiwidXNlU3RvcmUiLCJBIiwidXNlVGhyZWUiLCJSZWFjdCIsIlRIUkVFIiwidXNlTWVhc3VyZSIsIkZpYmVyUHJvdmlkZXIiLCJqc3giLCJDYW52YXNJbXBsIiwicmVmIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsInJlc2l6ZSIsInN0eWxlIiwiZ2wiLCJldmVudFNvdXJjZSIsImV2ZW50UHJlZml4Iiwic2hhZG93cyIsImxpbmVhciIsImZsYXQiLCJsZWdhY3kiLCJvcnRob2dyYXBoaWMiLCJmcmFtZWxvb3AiLCJkcHIiLCJwZXJmb3JtYW5jZSIsInJheWNhc3RlciIsImNhbWVyYSIsInNjZW5lIiwib25Qb2ludGVyTWlzc2VkIiwib25DcmVhdGVkIiwicHJvcHMiLCJ1c2VNZW1vIiwiQnJpZGdlIiwiY29udGFpbmVyUmVmIiwiY29udGFpbmVyUmVjdCIsInNjcm9sbCIsImRlYm91bmNlIiwiY2FudmFzUmVmIiwidXNlUmVmIiwiZGl2UmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImN1cnJlbnQiLCJoYW5kbGVQb2ludGVyTWlzc2VkIiwiYmxvY2siLCJzZXRCbG9jayIsInVzZVN0YXRlIiwiZXJyb3IiLCJzZXRFcnJvciIsInJvb3QiLCJjYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsInJ1biIsImNvbmZpZ3VyZSIsInNpemUiLCJhcmdzIiwic3RhdGUiLCJjb25uZWN0Iiwic2V0RXZlbnRzIiwiY29tcHV0ZSIsImV2ZW50IiwicG9pbnRlciIsInNldCIsInNldEZyb21DYW1lcmEiLCJyZW5kZXIiLCJTdXNwZW5zZSIsInVzZUVmZmVjdCIsInBvaW50ZXJFdmVudHMiLCJwb3NpdGlvbiIsIm92ZXJmbG93IiwiZGlzcGxheSIsIkNhbnZhcyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/traditional.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/zustand/esm/traditional.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWithEqualityFn: () => (/* binding */ createWithEqualityFn),\n/* harmony export */   useStoreWithEqualityFn: () => (/* binding */ useStoreWithEqualityFn)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/vanilla */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/vanilla.mjs\");\n\n\n\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__;\nconst identity = (arg)=>arg;\nfunction useStoreWithEqualityFn(api, selector = identity, equalityFn) {\n    const slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getInitialState, selector, equalityFn);\n    react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(slice);\n    return slice;\n}\nconst createWithEqualityFnImpl = (createState, defaultEqualityFn)=>{\n    const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__.createStore)(createState);\n    const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn)=>useStoreWithEqualityFn(api, selector, equalityFn);\n    Object.assign(useBoundStoreWithEqualityFn, api);\n    return useBoundStoreWithEqualityFn;\n};\nconst createWithEqualityFn = (createState, defaultEqualityFn)=>createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS90cmFkaXRpb25hbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFDOEQ7QUFDMUM7QUFFOUMsTUFBTSxFQUFFRyxnQ0FBZ0MsRUFBRSxHQUFHRiwwRUFBMkJBO0FBQ3hFLE1BQU1HLFdBQVcsQ0FBQ0MsTUFBUUE7QUFDMUIsU0FBU0MsdUJBQXVCQyxHQUFHLEVBQUVDLFdBQVdKLFFBQVEsRUFBRUssVUFBVTtJQUNsRSxNQUFNQyxRQUFRUCxpQ0FDWkksSUFBSUksU0FBUyxFQUNiSixJQUFJSyxRQUFRLEVBQ1pMLElBQUlNLGVBQWUsRUFDbkJMLFVBQ0FDO0lBRUZULGdEQUFtQixDQUFDVTtJQUNwQixPQUFPQTtBQUNUO0FBQ0EsTUFBTUssMkJBQTJCLENBQUNDLGFBQWFDO0lBQzdDLE1BQU1WLE1BQU1MLDREQUFXQSxDQUFDYztJQUN4QixNQUFNRSw4QkFBOEIsQ0FBQ1YsVUFBVUMsYUFBYVEsaUJBQWlCLEdBQUtYLHVCQUF1QkMsS0FBS0MsVUFBVUM7SUFDeEhVLE9BQU9DLE1BQU0sQ0FBQ0YsNkJBQTZCWDtJQUMzQyxPQUFPVztBQUNUO0FBQ0EsTUFBTUcsdUJBQXdCLENBQUNMLGFBQWFDLG9CQUFzQkQsY0FBY0QseUJBQXlCQyxhQUFhQyxxQkFBcUJGO0FBRW5GIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9EZXNrdG9wL3NtYXJ0X2xlYXJuaW5nL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL3RyYWRpdGlvbmFsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlRXhwb3J0cyBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICd6dXN0YW5kL3ZhbmlsbGEnO1xuXG5jb25zdCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHM7XG5jb25zdCBpZGVudGl0eSA9IChhcmcpID0+IGFyZztcbmZ1bmN0aW9uIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oYXBpLCBzZWxlY3RvciA9IGlkZW50aXR5LCBlcXVhbGl0eUZuKSB7XG4gIGNvbnN0IHNsaWNlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgYXBpLnN1YnNjcmliZSxcbiAgICBhcGkuZ2V0U3RhdGUsXG4gICAgYXBpLmdldEluaXRpYWxTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBlcXVhbGl0eUZuXG4gICk7XG4gIFJlYWN0LnVzZURlYnVnVmFsdWUoc2xpY2UpO1xuICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBjcmVhdGVXaXRoRXF1YWxpdHlGbkltcGwgPSAoY3JlYXRlU3RhdGUsIGRlZmF1bHRFcXVhbGl0eUZuKSA9PiB7XG4gIGNvbnN0IGFwaSA9IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKTtcbiAgY29uc3QgdXNlQm91bmRTdG9yZVdpdGhFcXVhbGl0eUZuID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuID0gZGVmYXVsdEVxdWFsaXR5Rm4pID0+IHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oYXBpLCBzZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gIE9iamVjdC5hc3NpZ24odXNlQm91bmRTdG9yZVdpdGhFcXVhbGl0eUZuLCBhcGkpO1xuICByZXR1cm4gdXNlQm91bmRTdG9yZVdpdGhFcXVhbGl0eUZuO1xufTtcbmNvbnN0IGNyZWF0ZVdpdGhFcXVhbGl0eUZuID0gKChjcmVhdGVTdGF0ZSwgZGVmYXVsdEVxdWFsaXR5Rm4pID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlV2l0aEVxdWFsaXR5Rm5JbXBsKGNyZWF0ZVN0YXRlLCBkZWZhdWx0RXF1YWxpdHlGbikgOiBjcmVhdGVXaXRoRXF1YWxpdHlGbkltcGwpO1xuXG5leHBvcnQgeyBjcmVhdGVXaXRoRXF1YWxpdHlGbiwgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbiB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3luY0V4dGVybmFsU3RvcmVFeHBvcnRzIiwiY3JlYXRlU3RvcmUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsImlkZW50aXR5IiwiYXJnIiwidXNlU3RvcmVXaXRoRXF1YWxpdHlGbiIsImFwaSIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsInNsaWNlIiwic3Vic2NyaWJlIiwiZ2V0U3RhdGUiLCJnZXRJbml0aWFsU3RhdGUiLCJ1c2VEZWJ1Z1ZhbHVlIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm5JbXBsIiwiY3JlYXRlU3RhdGUiLCJkZWZhdWx0RXF1YWxpdHlGbiIsInVzZUJvdW5kU3RvcmVXaXRoRXF1YWxpdHlGbiIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZVdpdGhFcXVhbGl0eUZuIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/traditional.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/vanilla.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/zustand/esm/vanilla.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: () => (/* binding */ createStore)\n/* harmony export */ });\nconst createStoreImpl = (createState)=>{\n    let state;\n    const listeners = /* @__PURE__ */ new Set();\n    const setState = (partial, replace)=>{\n        const nextState = typeof partial === \"function\" ? partial(state) : partial;\n        if (!Object.is(nextState, state)) {\n            const previousState = state;\n            state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n            listeners.forEach((listener)=>listener(state, previousState));\n        }\n    };\n    const getState = ()=>state;\n    const getInitialState = ()=>initialState;\n    const subscribe = (listener)=>{\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    };\n    const api = {\n        setState,\n        getState,\n        getInitialState,\n        subscribe\n    };\n    const initialState = state = createState(setState, getState, api);\n    return api;\n};\nconst createStore = (createState)=>createState ? createStoreImpl(createState) : createStoreImpl;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsa0JBQWtCLENBQUNDO0lBQ3ZCLElBQUlDO0lBQ0osTUFBTUMsWUFBWSxhQUFhLEdBQUcsSUFBSUM7SUFDdEMsTUFBTUMsV0FBVyxDQUFDQyxTQUFTQztRQUN6QixNQUFNQyxZQUFZLE9BQU9GLFlBQVksYUFBYUEsUUFBUUosU0FBU0k7UUFDbkUsSUFBSSxDQUFDRyxPQUFPQyxFQUFFLENBQUNGLFdBQVdOLFFBQVE7WUFDaEMsTUFBTVMsZ0JBQWdCVDtZQUN0QkEsUUFBUSxDQUFDSyxXQUFXLE9BQU9BLFVBQVUsT0FBT0MsY0FBYyxZQUFZQSxjQUFjLElBQUcsSUFBS0EsWUFBWUMsT0FBT0csTUFBTSxDQUFDLENBQUMsR0FBR1YsT0FBT007WUFDaklMLFVBQVVVLE9BQU8sQ0FBQyxDQUFDQyxXQUFhQSxTQUFTWixPQUFPUztRQUNsRDtJQUNGO0lBQ0EsTUFBTUksV0FBVyxJQUFNYjtJQUN2QixNQUFNYyxrQkFBa0IsSUFBTUM7SUFDOUIsTUFBTUMsWUFBWSxDQUFDSjtRQUNqQlgsVUFBVWdCLEdBQUcsQ0FBQ0w7UUFDZCxPQUFPLElBQU1YLFVBQVVpQixNQUFNLENBQUNOO0lBQ2hDO0lBQ0EsTUFBTU8sTUFBTTtRQUFFaEI7UUFBVVU7UUFBVUM7UUFBaUJFO0lBQVU7SUFDN0QsTUFBTUQsZUFBZWYsUUFBUUQsWUFBWUksVUFBVVUsVUFBVU07SUFDN0QsT0FBT0E7QUFDVDtBQUNBLE1BQU1DLGNBQWUsQ0FBQ3JCLGNBQWdCQSxjQUFjRCxnQkFBZ0JDLGVBQWVEO0FBRTVEIiwic291cmNlcyI6WyIvaG9tZS9jb2Rlci9EZXNrdG9wL3NtYXJ0X2xlYXJuaW5nL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL3ZhbmlsbGEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyZWF0ZVN0b3JlSW1wbCA9IChjcmVhdGVTdGF0ZSkgPT4ge1xuICBsZXQgc3RhdGU7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHNldFN0YXRlID0gKHBhcnRpYWwsIHJlcGxhY2UpID0+IHtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiID8gcGFydGlhbChzdGF0ZSkgOiBwYXJ0aWFsO1xuICAgIGlmICghT2JqZWN0LmlzKG5leHRTdGF0ZSwgc3RhdGUpKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gc3RhdGU7XG4gICAgICBzdGF0ZSA9IChyZXBsYWNlICE9IG51bGwgPyByZXBsYWNlIDogdHlwZW9mIG5leHRTdGF0ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXh0U3RhdGUgPT09IG51bGwpID8gbmV4dFN0YXRlIDogT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHN0YXRlLCBwcmV2aW91c1N0YXRlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHN0YXRlO1xuICBjb25zdCBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZSA9IChsaXN0ZW5lcikgPT4ge1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfTtcbiAgY29uc3QgYXBpID0geyBzZXRTdGF0ZSwgZ2V0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgc3Vic2NyaWJlIH07XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHN0YXRlID0gY3JlYXRlU3RhdGUoc2V0U3RhdGUsIGdldFN0YXRlLCBhcGkpO1xuICByZXR1cm4gYXBpO1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKChjcmVhdGVTdGF0ZSkgPT4gY3JlYXRlU3RhdGUgPyBjcmVhdGVTdG9yZUltcGwoY3JlYXRlU3RhdGUpIDogY3JlYXRlU3RvcmVJbXBsKTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVTdG9yZUltcGwiLCJjcmVhdGVTdGF0ZSIsInN0YXRlIiwibGlzdGVuZXJzIiwiU2V0Iiwic2V0U3RhdGUiLCJwYXJ0aWFsIiwicmVwbGFjZSIsIm5leHRTdGF0ZSIsIk9iamVjdCIsImlzIiwicHJldmlvdXNTdGF0ZSIsImFzc2lnbiIsImZvckVhY2giLCJsaXN0ZW5lciIsImdldFN0YXRlIiwiZ2V0SW5pdGlhbFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic3Vic2NyaWJlIiwiYWRkIiwiZGVsZXRlIiwiYXBpIiwiY3JlYXRlU3RvcmUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/vanilla.mjs\n");

/***/ })

};
;